{"version":3,"file":"c1p.js","lineCount":202,"mappings":"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","sources":["versions/c1pjs/1.61.0/c1p-uncompiled.js"," [synthetic:util/objectcreate] "," [synthetic:es6/util/setprototypeof] "," [synthetic:es6/util/inherits] "," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:util/polyfill] "," [synthetic:es6/math/trunc] "," [synthetic:es6/number/parseint] "],"names":["$jscomp.objectCreate","$jscomp.setPrototypeOf","$jscomp.defineProperty","$jscomp.global","$jscomp.polyfill","toHex","n","cch","fPrefix","v","Math","abs","nGrouping","s","isNaN","pow","radix","ceil","log","g","d","String","fromCharCode","trunc","sPrefix","toHexByte","b","Str.toHex","toHexWord","w","getBaseName","sFileName","sBaseName","i","lastIndexOf","substr","indexOf","getExtension","sExtension","toLowerCase","escapeHTML","sHTML","replace","m","Str.HTMLEscapeMap","Usr.getTime","Date","now","getResource","sURL","done","type","fAsync","nErrorCode","resource","resources","request","window","XMLHttpRequest","ActiveXObject","fArrayBuffer","fXHR2","responseType","callback","readyState","response","responseText","err","status","length","location","protocol","onreadystatechange","sPost","p","hasOwnProperty","encodeURIComponent","open","setRequestHeader","send","overrideMimeType","isUserAgent","userAgent","navigator","match","isMobile","sDevice","sMobile","Web.getURLParm","Web.isUserAgent","fInvert","getURLParm","sParm","Web.parmsURL","sParms","aParms","search","pl","exec","decodeURIComponent","onCountRepeat","fnRepeat","fnComplete","fnTimeout","doCountRepeat","setTimeout","onClickRepeat","e","fn","doClickRepeat","msRepeat","ms","timer","fIgnoreMouseEvents","onmousedown","e.onmousedown","msDelay","ontouchstart","e.ontouchstart","onmouseup","onmouseout","e.onmouseout","clearTimeout","ontouchend","ontouchcancel","e.ontouchcancel","onPageEvent","sFunc","fnPrev","onInit","Web.aPageEventHandlers","push","doPageEvent","afn","Web.fPageEventsEnabled","Component.alertUser","message","enablePageEvents","fEnable","Web.fPageLoaded","Web.sendPageEvent","Web.fPageShowed","sendPageEvent","sEvent","Web.doPageEvent","Web.onPageEvent","onPageLoad","onPageShow","onPageUnload","constructor","Component","parms","bitsMessage","id","name","bindings","idMachine","flags","ready","busy","busyCancel","initDone","powered","unloading","error","fnReady","clearError","dbg","cpu","cmp","Component.components.push","component","alertUser","sMessage","alert","appendControl","control","sText","value","scrollTop","scrollHeight","bindComponentControls","element","aeControls","Component.getElementsByClass","parentNode","iControl","aeChildNodes","childNodes","iNode","nodeType","sClass","getAttribute","aClasses","split","iClass","Component.getComponentParms","undefined","setBinding","getComponentByID","idRelated","Component.components.length","Component.components","getComponentByType","sType","componentPrev","getComponentParms","eval","getElementsByClass","sObjClass","getElementsByClassName","j","ae","aeAll","getElementsByTagName","re","RegExp","test","className","processCommands","fSuccess","aCommands","Component.commands","aTokens","splice","sCommand","fnCallReady","Component.asyncCommands.indexOf","processNextCommand","Component.processCommands","fnCommand","Component.globalCommands","Component.getComponentByType","Component.componentCommands","exports","call","Component.prototype","?.prototype","toString","sHTMLType","sBinding","onclick","clearControl","notice","this.notice","println","print","printControl","Component.appendControl","printlnControl","Component.PRINT.PROGRESS","slice","fPrintOnly","computer","console","setError","isReady","setReady","isBusy","fCancel","setBusy","fBusy","messageEnabled","bitsEnabled","PROGRESS","Component.machines","Component.asyncCommands","scriptAlert","scriptSleep","fnCallback","sDelay","scriptSelect","sValue","aBindings","options","textContent","selectedIndex","Array","prototype","Array.prototype.indexOf","obj","start","isArray","Array.isArray","arg","Object","Function","bind","Function.prototype.bind","fnBound","fToBind","apply","fnNOP","args","concat","arguments","TypeError","C1PPanel","parmsPanel","$jscomp.inherits","kbd","setPower","fOn","C1PPanel.init","init","fReady","aePanels","document","APPCLASS","iPanel","ePanel","panel","Component.getComponentByID","Component.bindComponentControls","Web.onInit","C1PCPU","parmsCPU","clearRegs","running","fAutoStart","SPEED_SLOW","SPEED_FAST","SPEED_MAX","speed","nVideoUpdatesPerSecond","nStatusUpdatesPerSecond","mhzFast","aSpeeds","aSpeedDescs","aReadNotify","aWriteNotify","addrReadLower","addrReadUpper","addrWriteLower","addrWriteUpper","OP_JSR","OP_SIM","SIMOP_MSG","aOpcodeFuncs","opBRK","opORAindx","opSim","opUndefined","opORAzp","opASLzp","opPHP","opORAimm","opASLacc","opORAabs","opASLabs","opBPL","opORAindy","opORAzpx","opASLzpx","opCLC","opORAabsy","opORAabsx","opASLabsx","opJSRabs","opANDindx","opBITzp","opANDzp","opROLzp","opPLP","opANDimm","opROLacc","opBITabs","opANDabs","opROLabs","opBMI","opANDindy","opANDzpx","opROLzpx","opSEC","opANDabsy","opANDabsx","opROLabsx","opRTI","opEORindx","opEORzp","opLSRzp","opPHA","opEORimm","opLSRacc","opJMPimm16","opEORabs","opLSRabs","opBVC","opEORindy","opEORzpx","opLSRzpx","opCLI","opEORabsy","opEORabsx","opLSRabsx","opRTS","opADCindx","opADCzp","opRORzp","opPLA","opADCimm","opRORacc","opJMPabs16","opADCabs","opRORabs","opBVS","opADCindy","opADCzpx","opRORzpx","opSEI","opADCabsy","opADCabsx","opRORabsx","opSTAindx","opSTYzp","opSTAzp","opSTXzp","opDEY","opTXA","opSTYabs","opSTAabs","opSTXabs","opBCC","opSTAindy","opSTYzpx","opSTAzpx","opSTXzpy","opTYA","opSTAabsy","opTXS","opSTAabsx","opLDYimm","opLDAindx","opLDXimm","opLDYzp","opLDAzp","opLDXzp","opTAY","opLDAimm","opTAX","opLDYabs","opLDAabs","opLDXabs","opBCS","opLDAindy","opLDYzpx","opLDAzpx","opLDXzpy","opCLV","opLDAabsy","opTSX","opLDYabsx","opLDAabsx","opLDXabsy","opCPYimm","opCMPindx","opCPYzp","opCMPzp","opDECzp","opINY","opCMPimm","opDEX","opCPYabs","opCMPabs","opDECabs","opBNE","opCMPindy","opCMPzpx","opDECzpx","opCLD","opCMPabsy","opCMPabsx","opDECabsx","opCPXimm","opSBCindx","opCPXzp","opSBCzp","opINCzp","opINX","opSBCimm","opNOP","opCPXabs","opSBCabs","opINCabs","opBEQ","opSBCindy","opSBCzpx","opINCzpx","opSED","opSBCabsy","opSBCabsx","opINCabsx","aOpcodeCycles","C1PCPU.prototype","reset","fPowerOn","halt","regPC","getWord","abMem","VECTOR_RESET","run","fBound","setSpeed","setBuffer","abMemory","end","offMem","cbMem","offLimit","video","displayVideo","updateScreen","setFocus","update","addReadNotify","findNotify","checkReadNotify","addrRead","addrFrom","addWriteNotify","checkWriteNotify","addrWrite","aNotify","fOnClick","innerHTML","nRunCycles","msRunStart","calcCycles","displayReg","sReg","vReg","len","toUpperCase","displayStatus","regA","regX","regY","regP","getRegP","BIT_PC","BIT_PZ","BIT_PI","BIT_PD","BIT_PB","BIT_PV","BIT_PN","regS","mhz","toFixed","fRecalc","nMostUpdatesPerSecond","nYieldsPerSecond","vMultiplier","msPerYield","round","nCyclesPerBurst","floor","nCyclesPerSecond","nCyclesPerYield","nCyclesPerVideoUpdate","nCyclesPerStatusUpdate","nCyclesNextYield","nCyclesNextVideoUpdate","nCyclesNextStatusUpdate","nRecalcCycles","calcRemainingTime","msCurrent","msYield","nCyclesThisRun","msRemainsThisRun","msStartThisRun","msElapsed","calcSpeed","calcStartTime","step","nCycles","nBurstCycles","nStepCycles","stack","stop","nMinCycles","fCompleted","regEA","regEAWrite","aExecBreak","aReadBreak","aWriteBreak","bOpCode","fDebugCheck","fBreak","checkBreakpoint","addr","cIns","aaOpcodeFreqs","aStepHistory","iStepHistory","Str.toHexWord","yieldCPU","getCycles","getByte","regRC","regRZ","regRV","regRU","regRN","setBCD","opADCindxBCD","opADCzpBCD","opADCimmBCD","opADCabsBCD","opADCindyBCD","opADCzpxBCD","opADCabsyBCD","opADCabsxBCD","opSBCindxBCD","opSBCzpBCD","opSBCimmBCD","opSBCabsBCD","opSBCindyBCD","opSBCzpxBCD","opSBCabsyBCD","opSBCabsxBCD","clearBCD","addBCD","reg","mem","carry","r","subBCD","notcarry","bSimOp","SIMOP_HLT","Str.toHexByte","aeCPUs","iCPU","eCPU","C1PROM","parmsROM","abImage","cbROM","sImage","sFileURL","sFileExt","Str.getExtension","FORMAT","host","SITEHOST","rom","Web.getResource","sResponse","convertImage","offROM","setByte","copyImage","messageIO","MESSAGE_PORT","offset","sImageName","sImageData","charAt","ab","asData","sData","parseInt","cbImage","aeROM","iROM","eROM","C1PRAM","parmsRAM","aeRAM","iRAM","eRAM","ram","C1PKeyboard","parmsKbd","nDefaultModel","KEYCODE_DELETE","KEYCODE_LF","KEYCODE_CR","KEYCODE_ESC","CHARCODE_DELETE","CHARCODE_LF","CHARCODE_CR","CHARCODE_ESC","CHARCODE_CTRL","CHARCODE_BREAK","CHARCODE_CTRLC","CHARCODE_CTRLO","BIT_SHIFTLOCK","aButtonCodeMap","aCharCodeMap","CHARCODE_LSHIFT","CHARCODE_RSHIFT","CHARCODE_SHIFTLOCK","C1PKeyboard.prototype","setModel","bitsShift","bKbdRows","abKbdCols","aKbdStates","aKeyTimers","prevKeyDown","prevCharDown","bWriteLast","abKbdColsLast","nCyclesSinceLastEvent","nWritesSinceLastEvent","sInjectBuffer","onkeydown","event","keyEvent","onkeypress","fPass","charCode","which","keyCode","BIT_COMMAND","keyPressSimulate","MESSAGE_KBD","onkeyup","sButton","offKbd","cbKbd","offKbdLimit","nModel","bInvert","fMobile","iOS","calcReleaseDelay","fRepeat","msReleaseRepeat","msReleaseDelay","autoClear","notCharCode","keyEventSimulate","SIMCODE_AUTOCLEAR","injectKeys","sKeyCodes","injectKeysFromBuffer","msInjectDelay","ch","charCodeAt","fDown","fAutoClear","BIT_LSHIFT","PSEUDO_CHARCODE","BIT_RSHIFT","BIT_CTRL","KEYCODE_COMMAND","KEYCODE_TAB","SIMCODE_KEYEVENT","fSimulated","SIMCODE_KEYPRESS","SIMCODE_KEYRELEASE","SIMCODE_KEYTIMEOUT","simCode","bShift","bCode","iRow","iCol","BITS_SIMULATE","fPropagate","updateMemory","C1PKeyboard_prototype$setByte","nCycleDelta","nCyclesThreshold","shift","aeKbd","iKbd","eKbd","C1PVideo","parmsVideo","canvas","context","imgChars","nDefaultCols","nDefaultRows","cxScreen","cyScreen","cxChar","cyChar","setDimensions","canvasScreen","contextScreen","asWebPrefixes","fSmoothing","sSmoothing","C1PVideo.prototype","offVideo","offVideoLimit","random","initScreen","cbVideo","addrVideoPort","nCols","nRows","iRowTop","nRowsVisible","cbScreen","setDrawingDimensions","cxCharDst","cyCharDst","focus","addrGuard","tripGuard","width","height","MESSAGE_VIDEO","nCyclesHigh","C1PVideo_prototype$setByte","aBounds","addrLower","addrUpper","abScreen","row","writeByte","xChar","drawImage","aeVideo","iVideo","eVideo","eCanvas","createElement","getContext","setAttribute","style","backgroundColor","clientWidth","onresize","eParent","eChild","cx","cy","appendChild","imgCharSet","Image","eContext","onload","src","C1PSerialPort","parmsSerial","fDemo","C1PSerialPort.prototype","fHard","autoLoad","C1PSerialPort.AUTOLOAD_6502","bInput","iInput","sInput","nMachine","getMachineNum","aDigits","fConvertLF","C1PSerialPort.AUTOLOAD_NONE","serial","C1PSerialPort.AUTOLOAD_BASIC","control.onclick","loadFile","Web.isMobile","onchange","controlInput.onchange","fieldset","children","submit","disabled","files","onsubmit","controlInput.onsubmit","file","currentTarget","reader","FileReader","reader.onload","result","readAsText","removeChild","offPort","cbPort","offPortLimit","sFileData","nResponse","sSuffix","data","advanceInput","C1PSerialPort_prototype$setByte","MESSAGE_SERIAL","C1PSerialPort.STATUS_DATA","C1PSerialPort.STATUS_NONE","aeSerial","iSerial","eSerial","C1PDiskController","parmsDC","C1PDiskController.prototype","resetRegs","iDriveSelect","aDrives","resetDrive","iDrive","iType","DRIVETYPE_5INCH","nTracks","MAXTRACKS_5INCH","fProtected","nIndexPulse","iTrackSelect","iTrackOffset","aTracks","regDDA","bits","PDA_SD2","read","controller","regCRA","CR_PD_SEL","writePort","PORT_DDA","regPDA","bPDA","setSelectedDrive","regPDB","drive","stopDriveData","advanceDriveData","PORT_PDA","PORT_CRA","regDDB","regCRB","PORT_DDB","bPDB","PDB_ST","PDB_STI","MESSAGE_DISK","PDA_IHD","PORT_PDB","PORT_CRB","regCTRL","CTRL_CDIV","regSTAT","bSTAT","STAT_RDRF","PORT_STAT","regDATA","PORT_DATA","regUnknown","sFilePath","Str.getBaseName","loadDisk","addrController","sDiskName","sDiskData","aHeads","iTrack","iTrackNum","track","sectors","Error","trackData","pushSig","pushBCD","pushBin","iSector","sector","sectorData","a","o","k","cb","getReg","port","fWrite","PORT_CTRL","sName","C1PDiskController_prototype$setByte","aBitIDs","bTest","bChanged","PDB_SD1","aeDC","iDC","eDC","C1PDebugger","parmsDbg","nextAddr","prevCmd","fAssemble","addrAssembleNext","clearBreakpoints","MESSAGE_NONE","aMessageCategories","aOpCodes","aOpSimCodes","setOpModes","aaOperations","OP_BRK","OP_ORA","MODE_INDX","MODE_ZP","OP_ASL","OP_PHP","MODE_IMM","MODE_ACC","MODE_ABS","OP_BPL","MODE_DISP","MODE_INDY","MODE_ZPX","OP_CLC","MODE_ABSY","MODE_ABSX","MODE_IMM16","OP_AND","OP_BIT","OP_ROL","OP_PLP","OP_BMI","OP_SEC","OP_RTI","OP_EOR","OP_LSR","OP_PHA","OP_JMP","OP_BVC","OP_CLI","OP_RTS","OP_ADC","OP_ROR","OP_PLA","MODE_ABS16","OP_BVS","OP_SEI","OP_STA","OP_STY","OP_STX","OP_DEY","OP_TXA","OP_BCC","MODE_ZPY","OP_TYA","OP_TXS","OP_LDY","OP_LDA","OP_LDX","OP_TAY","OP_TAX","OP_BCS","OP_CLV","OP_TSX","OP_CPY","OP_CMP","OP_DEC","OP_INY","OP_DEX","OP_BNE","OP_CLD","OP_CPX","OP_SBC","OP_INC","OP_INX","OP_NOP","OP_BEQ","OP_SED","C1PDebugger.prototype","eDebug","C1PDebugger.input","Web.onClickRepeat","fClassic","sRegEx","aOpModes","iMode","sMode","regexOpModes","aImm16Codes","isCPUOK","fStep","fStepOver","doUnassemble","doRegisters","msStart","msTotal","clearTempBreakpoint","addSignedByte","addExecBreakpoint","findBreakpoint","findExecBreakpoint","fRemove","aBreak","fMatch","setTempBreakpoint","addrTempBP","aBreakpoints","getInstruction","nIns","sLine","aOpDesc","abOperand","OP_DB","sOperand","bOpMode","pop","nextIns","getUserAddr","sAddr","nBase","doFreqs","cData","aaSortedOpcodeFreqs","sort","q","bOpcode","cFreq","sAddrEnd","addrEnd","sIns","asArgs","fIns","getRegs","doTrace","sCount","c","Web.onCountRepeat","input","sCmd","aOpBytes","sCode","iCode","aModeMatch","cModes","asHex","nHex","cBreaks","aAddrs","cLines","sLen","line","sChars","sBytes","addrLine","sOption","sCategory","iHistory","aHistory","nextHistory","nInsHistory","aeDbg","iDbg","eDbg","C1PComputer","parmsComputer","modules","power","C1PComputer.power","aeComputers","iComputer","eComputer","addrStart","iAddr","addrInfo","controlPrint","aComponents","iComponent","cAsyncMachines","loadXML","sXMLFile","fResolve","display","doneLoadXML","sURLName","sXML","parseXML","buildXML","sError","pathname","xmlDoc","async","parseFromString","DOMParser","resolveXML","matchRef","reRef","sRefFile","doneReadXML","sXMLRef","sRefAttrs","aXMLRefTag","sXMLNewTag","matchAttr","reAttr","embedMachine","sXSLFile","displayMessage","eWarning","aeWarning","eMachine","Str.escapeHTML","displayError","Web.enablePageEvents","getElementById","css","head","styleSheet","cssText","createTextNode","processXML","xml","transformXML","sXSL","xsl","sFragment","outerHTML","implementation","createDocument","xsltProcessor","XSLTProcessor","eFragment","replaceChild","embedC1P","commandMachine","fSingle","sComponent","sToken","chQuote"],"sourcesContent":["\"use strict\";\n\n/**\n * @copyright https://www.pcjs.org/modules/shared/lib/defines.js (C) Jeff Parsons 2012-2018\n */\n\n/**\n * @define {string}\n */\nvar APPVERSION = \"\";            // this @define is overridden by the Closure Compiler with the version in machines.json\n\nvar XMLVERSION = null;          // this is set in non-COMPILED builds by embedMachine() if a version number was found in the machine XML\n\nvar COPYRIGHT = \"Copyright  2012-2018 Jeff Parsons <Jeff@pcjs.org>\";\n\nvar LICENSE = \"License: GPL version 3 or later <http://gnu.org/licenses/gpl.html>\";\n\nvar CSSCLASS = \"pcjs\";\n\n/**\n * @define {string}\n */\nvar SITEHOST = \"localhost:8088\";// this @define is overridden by the Closure Compiler with \"www.pcjs.org\"\n\n/**\n * @define {boolean}\n */\nvar COMPILED = false;           // this @define is overridden by the Closure Compiler (to true)\n\n/**\n * @define {boolean}\n */\nvar DEBUG = true;               // this @define is overridden by the Closure Compiler (to false) to remove DEBUG-only code\n\n/**\n * @define {boolean}\n */\nvar MAXDEBUG = false;           // this @define is overridden by the Closure Compiler (to false) to remove MAXDEBUG-only code\n\n/**\n * @define {boolean}\n */\nvar PRIVATE = false;            // this @define is overridden by the Closure Compiler (to false) to enable PRIVATE code\n\n/*\n * RS-232 DB-25 Pin Definitions, mapped to bits 1-25 in a 32-bit status value.\n *\n * SerialPorts in PCjs machines are considered DTE (Data Terminal Equipment), which means they should be \"virtually\"\n * connected to each other via a null-modem cable, which assumes the following cross-wiring:\n *\n *     G       1  <->  1        G       (Ground)\n *     TD      2  <->  3        RD      (Received Data)\n *     RD      3  <->  2        TD      (Transmitted Data)\n *     RTS     4  <->  5        CTS     (Clear To Send)\n *     CTS     5  <->  4        RTS     (Request To Send)\n *     DSR   6+8  <->  20       DTR     (Data Terminal Ready)\n *     SG      7  <->  7        SG      (Signal Ground)\n *     DTR    20  <->  6+8      DSR     (Data Set Ready + Carrier Detect)\n *     RI     22  <->  22       RI      (Ring Indicator)\n *\n * TODO: Move these definitions to a more appropriate shared file at some point.\n */\nvar RS232 = {\n    RTS: {\n        PIN:  4,\n        MASK: 0x00000010\n    },\n    CTS: {\n        PIN:  5,\n        MASK: 0x00000020\n    },\n    DSR: {\n        PIN:  6,\n        MASK: 0x00000040\n    },\n    CD: {\n        PIN:  8,\n        MASK: 0x00000100\n    },\n    DTR: {\n        PIN:  20,\n        MASK: 0x00100000\n    },\n    RI: {\n        PIN:  22,\n        MASK: 0x00400000\n    }\n};\n\n/*\n * NODE should be true if we're running under NodeJS (eg, command-line), false if not (eg, web browser)\n */\nvar NODE = false;\n\n\n/**\n * @copyright https://www.pcjs.org/modules/shared/lib/dumpapi.js (C) Jeff Parsons 2012-2018\n */\n\n/*\n * Our \"DiskDump API\", such as it was, used to look like:\n *\n *      http://jsmachines.net/bin/convdisk.php?disk=/disks/pc/dos/ibm/2.00/PCDOS200-DISK1.json&format=img\n *\n * To make it (a bit) more \"REST-like\", the above request now looks like:\n *\n *      http://www.pcjs.org/api/v1/dump?disk=/disks/pc/dos/ibm/2.00/PCDOS200-DISK1.json&format=img\n *\n * Similarly, our \"FileDump API\" used to look like:\n *\n *      http://jsmachines.net/bin/convrom.php?rom=/devices/pc/rom/5150/1981-04-24/PCBIOS-REV1.rom&format=json\n *\n * and that request now looks like:\n *\n *      http://www.pcjs.org/api/v1/dump?file=/devices/pc/rom/5150/1981-04-24/PCBIOS-REV1.rom&format=json\n *\n * I don't think it makes sense to avoid \"query\" parameters, because blending the path of a disk image with the\n * the rest of the URL would be (a) confusing, and (b) more work to parse.\n */\nvar DumpAPI = {\n    ENDPOINT:       \"/api/v1/dump\",\n    QUERY: {\n        DIR:        \"dir\",      // value is path of a directory (DiskDump only)\n        DISK:       \"disk\",     // value is path of a disk image (DiskDump only)\n        FILE:       \"file\",     // value is path of a ROM image file (FileDump only)\n        IMG:        \"img\",      // alias for DISK\n        PATH:       \"path\",     // value is path of a one or more files (DiskDump only)\n        FORMAT:     \"format\",   // value is one of FORMAT values below\n        COMMENTS:   \"comments\", // value is either \"true\" or \"false\"\n        DECIMAL:    \"decimal\",  // value is either \"true\" to force all numbers to decimal, \"false\" or undefined otherwise\n        MBHD:       \"mbhd\",     // value is hard drive size in Mb (formerly \"mbsize\") (DiskDump only) (DEPRECATED)\n        SIZE:       \"size\"      // value is target disk size in Kb (supersedes \"mbhd\") (DiskDump only)\n    },\n    FORMAT: {\n        JSON:       \"json\",     // default\n        JSON_GZ:    \"gz\",       // gzip is currently used ONLY for compressed JSON\n        DATA:       \"data\",     // same as \"json\", but built without JSON.stringify() (DiskDump only)\n        HEX:        \"hex\",      // deprecated\n        OCTAL:      \"octal\",    // displays data as octal words\n        BYTES:      \"bytes\",    // displays data as hex bytes; normally used only when comments are enabled\n        WORDS:      \"words\",    // displays data as hex words; normally used only when comments are enabled\n        LONGS:      \"longs\",    // displays data as dwords\n        IMG:        \"img\",      // returns the raw disk data (ie, using a Buffer object) (DiskDump only)\n        ROM:        \"rom\"       // returns the raw file data (ie, using a Buffer object) (FileDump only)\n    }\n};\n\n/*\n * Because we use an overloaded API endpoint (ie, one that's shared with the FileDump module), we must\n * also provide a list of commands which, when combined with the endpoint, define a unique request.\n */\nDumpAPI.asDiskCommands = [DumpAPI.QUERY.DIR, DumpAPI.QUERY.DISK, DumpAPI.QUERY.PATH];\nDumpAPI.asFileCommands = [DumpAPI.QUERY.FILE];\n\n\n\n/**\n * @copyright https://www.pcjs.org/modules/shared/lib/reportapi.js (C) Jeff Parsons 2012-2018\n */\n\nvar ReportAPI = {\n    ENDPOINT:       \"/api/v1/report\",\n    QUERY: {\n        APP:        \"app\",\n        VER:        \"ver\",\n        URL:        \"url\",\n        USER:       \"user\",\n        TYPE:       \"type\",\n        DATA:       \"data\"\n    },\n    TYPE: {\n        BUG:        \"bug\"\n    },\n    RES: {\n        OK:         \"Thank you\"\n    }\n};\n\n\n\n/**\n * @copyright https://www.pcjs.org/modules/shared/lib/strlib.js (C) Jeff Parsons 2012-2018\n */\n\nclass Str {\n    /**\n     * isValidInt(s, base)\n     *\n     * The built-in parseInt() function has the annoying feature of returning a partial value (ie,\n     * up to the point where it encounters an invalid character); eg, parseInt(\"foo\", 16) returns 0xf.\n     *\n     * So it's best to use our own Str.parseInt() function, which will in turn use this function to\n     * validate the entire string.\n     *\n     * @param {string} s is the string representation of some number\n     * @param {number} [base] is the radix to use (default is 10); only 2, 8, 10 and 16 are supported\n     * @return {boolean} true if valid, false if invalid (or the specified base isn't supported)\n     */\n    static isValidInt(s, base)\n    {\n        if (!base || base == 10) return s.match(/^-?[0-9]+$/) !== null;\n        if (base == 16) return s.match(/^-?[0-9a-f]+$/i) !== null;\n        if (base == 8) return s.match(/^-?[0-7]+$/) !== null;\n        if (base == 2) return s.match(/^-?[01]+$/) !== null;\n        return false;\n    }\n\n    /**\n     * parseInt(s, base)\n     *\n     * This is a wrapper around the built-in parseInt() function.  Our wrapper recognizes certain prefixes\n     * ('$' or \"0x\" for hex, '#' or \"0o\" for octal) and suffixes ('.' for decimal, 'h' for hex, 'y' for\n     * binary), and then calls isValidInt() to ensure we don't convert strings that contain partial values;\n     * see isValidInt() for details.\n     *\n     * The use of multiple prefix/suffix combinations is undefined (although for the record, we process\n     * prefixes first).  We do NOT support the \"0b\" prefix to indicate binary UNLESS one or more commas are\n     * also present (because \"0b\" is also a valid hex sequence), and we do NOT support a single leading zero\n     * to indicate octal (because such a number could also be decimal or hex).  Any number of commas are\n     * allowed; we remove them all before calling the built-in parseInt().\n     *\n     * More recently, we've added support for \"^D\", \"^O\", and \"^B\" prefixes to accommodate the base overrides\n     * that the PDP-10's MACRO-10 assembly language supports (decimal, octal, and binary, respectively).\n     * If this support turns out to adversely affect other debuggers, then it will have to be \"conditionalized\".\n     * Similarly, we've added support for \"K\", \"M\", and \"G\" MACRO-10-style suffixes that add 3, 6, or 9 zeros\n     * to the value to be parsed, respectively.\n     *\n     * @param {string} s is the string representation of some number\n     * @param {number} [base] is the radix to use (default is 10); can be overridden by prefixes/suffixes\n     * @return {number|undefined} corresponding value, or undefined if invalid\n     */\n    static parseInt(s, base)\n    {\n        var value;\n\n        if (s) {\n            if (!base) base = 10;\n\n            var ch, chPrefix, chSuffix;\n            var fCommas = (s.indexOf(',') > 0);\n            if (fCommas) s = s.replace(/,/g, '');\n\n            ch = chPrefix = s.charAt(0);\n            if (chPrefix == '#') {\n                base = 8;\n                chPrefix = '';\n            }\n            else if (chPrefix == '$') {\n                base = 16;\n                chPrefix = '';\n            }\n            if (ch != chPrefix) {\n                s = s.substr(1);\n            }\n            else {\n                ch = chPrefix = s.substr(0, 2);\n                if (chPrefix == '0b' && fCommas || chPrefix == '^B') {\n                    base = 2;\n                    chPrefix = '';\n                }\n                else if (chPrefix == '0o' || chPrefix == '^O') {\n                    base = 8;\n                    chPrefix = '';\n                }\n                else if (chPrefix == '^D') {\n                    base = 10;\n                    chPrefix = '';\n                }\n                else if (chPrefix == '0x') {\n                    base = 16;\n                    chPrefix = '';\n                }\n                if (ch != chPrefix) s = s.substr(2);\n            }\n            ch = chSuffix = s.slice(-1);\n            if (chSuffix == 'Y' || chSuffix == 'y') {\n                base = 2;\n                chSuffix = '';\n            }\n            else if (chSuffix == '.') {\n                base = 10;\n                chSuffix = '';\n            }\n            else if (chSuffix == 'H' || chSuffix == 'h') {\n                base = 16;\n                chSuffix = '';\n            }\n            else if (chSuffix == 'K') {\n                chSuffix = '000';\n            }\n            else if (chSuffix == 'M') {\n                chSuffix = '000000';\n            }\n            else if (chSuffix == 'G') {\n                chSuffix = '000000000';\n            }\n            if (ch != chSuffix) s = s.slice(0, -1) + chSuffix;\n            /*\n             * This adds support for the MACRO-10 binary shifting (Bn) suffix, which must be stripped from the\n             * number before parsing, and then applied to the value after parsing.  If n is omitted, 35 is assumed,\n             * which is a net shift of zero.  If n < 35, then a left shift of (35 - n) is required; if n > 35, then\n             * a right shift of -(35 - n) is required.\n             */\n            var v, shift = 0;\n            if (base <= 10) {\n                var match = s.match(/(-?[0-9]+)B([0-9]*)/);\n                if (match) {\n                    s = match[1];\n                    shift = 35 - ((match[2] || 35) & 0xff);\n                }\n            }\n            if (Str.isValidInt(s, base) && !isNaN(v = parseInt(s, base))) {\n                /*\n                 * With the need to support larger (eg, 36-bit) integers, truncating to 32 bits is no longer helpful.\n                 *\n                 *      value = v|0;\n                 */\n                if (shift) {\n                    /*\n                     * Since binary shifting is a logical operation, and since shifting by division only works properly\n                     * with positive numbers, we must convert a negative value to a positive value, by computing the two's\n                     * complement.\n                     */\n                    if (v < 0) v += Math.pow(2, 36);\n                    if (shift > 0) {\n                        v *= Math.pow(2, shift);\n                    } else {\n                        v = Math.trunc(v / Math.pow(2, -shift));\n                    }\n                }\n                value = v;\n            }\n        }\n        return value;\n    }\n\n    /**\n     * toBase(n, radix, cch, sPrefix, nGrouping)\n     *\n     * Displays the given number as an unsigned integer using the specified radix and number of digits.\n     *\n     * @param {number|*} n\n     * @param {number} radix (ie, the base)\n     * @param {number} cch (the desired number of digits)\n     * @param {string} [sPrefix] (default is none)\n     * @param {number} [nGrouping]\n     * @return {string}\n     */\n    static toBase(n, radix, cch, sPrefix = \"\", nGrouping = 0)\n    {\n        /*\n         * We can't rely entirely on isNaN(), because isNaN(null) returns false, and we can't rely\n         * entirely on typeof either, because typeof Nan returns \"number\".  Sigh.\n         *\n         * Alternatively, we could mask and shift n regardless of whether it's null/undefined/NaN,\n         * since JavaScript coerces such operands to zero, but I think there's \"value\" in seeing those\n         * values displayed differently.\n         */\n        var s = \"\";\n        if (isNaN(n) || typeof n != \"number\") {\n            n = null;\n        } else {\n            /*\n             * Callers that produced an input by dividing by a power of two rather than shifting (in order\n             * to access more than 32 bits) may produce a fractional result, which ordinarily we would simply\n             * ignore, but if the integer portion is zero and the sign is negative, we should probably treat\n             * this value as a sign-extension.\n             */\n            if (n < 0 && n > -1) n = -1;\n            /*\n             * Negative values should be two's complemented according to the number of digits; for example,\n             * 12 octal digits implies an upper limit 8^12.\n             */\n            if (n < 0) {\n                n += Math.pow(radix, cch);\n            }\n            if (n >= Math.pow(radix, cch)) {\n                cch = Math.ceil(Math.log(n) / Math.log(radix));\n            }\n        }\n        var g = nGrouping || -1;\n        while (cch-- > 0) {\n            if (!g) {\n                s = ',' + s;\n                g = nGrouping;\n            }\n            if (n == null) {\n                s = '?' + s;\n            } else {\n                var d = n % radix;\n                d += (d >= 0 && d <= 9? 0x30 : 0x41 - 10);\n                s = String.fromCharCode(d) + s;\n                n = Math.trunc(n / radix);\n            }\n            g--;\n        }\n        return sPrefix + s;\n    }\n\n    /**\n     * toBin(n, cch, nGrouping)\n     *\n     * Converts an integer to binary, with the specified number of digits (up to a maximum of 36).\n     *\n     * @param {number|*} n (supports integers up to 36 bits now)\n     * @param {number} [cch] is the desired number of binary digits (0 or undefined for default of either 8, 18, or 36)\n     * @param {number} [nGrouping]\n     * @return {string} the binary representation of n\n     */\n    static toBin(n, cch, nGrouping)\n    {\n        if (!cch) {\n            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.LN2) || 1;\n            var v = Math.abs(n);\n            if (v <= 0b11111111) {\n                cch = 8;\n            } else if (v <= 0b111111111111111111) {\n                cch = 18;\n            } else {\n                cch = 36;\n            }\n        } else if (cch > 36) cch = 36;\n        return Str.toBase(n, 2, cch, \"\", nGrouping);\n    }\n\n    /**\n     * toBinBytes(n, cb, fPrefix)\n     *\n     * Converts an integer to binary, with the specified number of bytes (up to the default of 4).\n     *\n     * @param {number|null|undefined} n (interpreted as a 32-bit value)\n     * @param {number} [cb] is the desired number of binary bytes (4 is both the default and the maximum)\n     * @param {boolean} [fPrefix]\n     * @return {string} the binary representation of n\n     */\n    static toBinBytes(n, cb, fPrefix)\n    {\n        var s = \"\";\n        if (!cb || cb > 4) cb = 4;\n        for (var i = 0; i < cb; i++) {\n            if (s) s = ',' + s;\n            s = Str.toBin(n & 0xff, 8) + s;\n            n >>= 8;\n        }\n        return (fPrefix? \"0b\" : \"\") + s;\n    }\n\n    /**\n     * toOct(n, cch, fPrefix)\n     *\n     * Converts an integer to octal, with the specified number of digits (default of 6; max of 12)\n     *\n     * You might be tempted to use the built-in n.toString(8) instead, but it doesn't zero-pad and it\n     * doesn't properly convert negative values.  Moreover, if n is undefined, n.toString() will throw\n     * an exception, whereas this function will return '?' characters.\n     *\n     * @param {number|*} n (supports integers up to 36 bits now)\n     * @param {number} [cch] is the desired number of octal digits (0 or undefined for default of either 6, 8, or 12)\n     * @param {boolean} [fPrefix]\n     * @return {string} the octal representation of n\n     */\n    static toOct(n, cch, fPrefix)\n    {\n        if (!cch) {\n            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.log(8)) || 1;\n            var v = Math.abs(n);\n            if (v <= 0o777777) {\n                cch = 6;\n            } else if (v <= 0o77777777) {\n                cch = 8;\n            } else {\n                cch = 12;\n            }\n        } else if (cch > 12) cch = 12;\n        return Str.toBase(n, 8, cch, fPrefix? \"0o\" : \"\");\n    }\n\n    /**\n     * toDec(n, cch)\n     *\n     * Converts an integer to decimal, with the specified number of digits (default of 5; max of 11)\n     *\n     * You might be tempted to use the built-in n.toString(10) instead, but it doesn't zero-pad and it\n     * doesn't properly convert negative values.  Moreover, if n is undefined, n.toString() will throw\n     * an exception, whereas this function will return '?' characters.\n     *\n     * @param {number|*} n (supports integers up to 36 bits now)\n     * @param {number} [cch] is the desired number of decimal digits (0 or undefined for default of either 5 or 11)\n     * @return {string} the decimal representation of n\n     */\n    static toDec(n, cch)\n    {\n        if (!cch) {\n            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.LN10) || 1;\n            var v = Math.abs(n);\n            if (v <= 99999) {\n                cch = 5;\n            } else {\n                cch = 11;\n            }\n        } else if (cch > 11) cch = 11;\n        return Str.toBase(n, 10, cch);\n    }\n\n    /**\n     * toHex(n, cch, fPrefix)\n     *\n     * Converts an integer to hex, with the specified number of digits (default of 4 or 8, max of 9).\n     *\n     * You might be tempted to use the built-in n.toString(16) instead, but it doesn't zero-pad and it\n     * doesn't properly convert negative values; for example, if n is -2147483647, then n.toString(16)\n     * will return \"-7fffffff\" instead of \"80000001\".  Moreover, if n is undefined, n.toString() will\n     * throw an exception, whereas this function will return '?' characters.\n     *\n     * NOTE: The following work-around (adapted from code found on StackOverflow) would be another solution,\n     * taking care of negative values, zero-padding, and upper-casing, but not null/undefined/NaN values:\n     *\n     *      s = (n < 0? n + 0x100000000 : n).toString(16);\n     *      s = \"00000000\".substr(0, 8 - s.length) + s;\n     *      s = s.substr(0, cch).toUpperCase();\n     *\n     * @param {number|*} n (supports integers up to 36 bits now)\n     * @param {number} [cch] is the desired number of hex digits (0 or undefined for default of either 4, 8, or 9)\n     * @param {boolean} [fPrefix]\n     * @return {string} the hex representation of n\n     */\n    static toHex(n, cch, fPrefix)\n    {\n        if (!cch) {\n            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.log(16)) || 1;\n            var v = Math.abs(n);\n            if (v <= 0xffff) {\n                cch = 4;\n            } else if (v <= 0xffffffff) {\n                cch = 8;\n            } else {\n                cch = 9;\n            }\n        } else if (cch > 9) cch = 9;\n        return Str.toBase(n, 16, cch, fPrefix? \"0x\" : \"\");\n    }\n\n    /**\n     * toHexByte(b)\n     *\n     * Alias for Str.toHex(b, 2, true)\n     *\n     * @param {number|null|undefined} b is a byte value\n     * @return {string} the hex representation of b\n     */\n    static toHexByte(b)\n    {\n        return Str.toHex(b, 2, true);\n    }\n\n    /**\n     * toHexWord(w)\n     *\n     * Alias for Str.toHex(w, 4, true)\n     *\n     * @param {number|null|undefined} w is a word (16-bit) value\n     * @return {string} the hex representation of w\n     */\n    static toHexWord(w)\n    {\n        return Str.toHex(w, 4, true);\n    }\n\n    /**\n     * toHexLong(l)\n     *\n     * Alias for Str.toHex(l, 8, true)\n     *\n     * @param {number|null|undefined} l is a dword (32-bit) value\n     * @return {string} the hex representation of w\n     */\n    static toHexLong(l)\n    {\n        return Str.toHex(l, 8, true);\n    }\n\n    /**\n     * getBaseName(sFileName, fStripExt)\n     *\n     * This is a poor-man's version of Node's path.basename(), which Node-only components should use instead.\n     *\n     * Note that if fStripExt is true, this strips ANY extension, whereas path.basename() strips the extension only\n     * if it matches the second parameter (eg, path.basename(\"/foo/bar/baz/asdf/quux.html\", \".html\") returns \"quux\").\n     *\n     * @param {string} sFileName\n     * @param {boolean} [fStripExt]\n     * @return {string}\n     */\n    static getBaseName(sFileName, fStripExt)\n    {\n        var sBaseName = sFileName;\n\n        var i = sFileName.lastIndexOf('/');\n        if (i >= 0) sBaseName = sFileName.substr(i + 1);\n\n        /*\n         * This next bit is a kludge to clean up names that are part of a URL that includes unsightly query parameters.\n         */\n        i = sBaseName.indexOf('&');\n        if (i > 0) sBaseName = sBaseName.substr(0, i);\n\n        if (fStripExt) {\n            i = sBaseName.lastIndexOf(\".\");\n            if (i > 0) {\n                sBaseName = sBaseName.substring(0, i);\n            }\n        }\n        return sBaseName;\n    }\n\n    /**\n     * getExtension(sFileName)\n     *\n     * This is a poor-man's version of Node's path.extname(), which Node-only components should use instead.\n     *\n     * Note that we EXCLUDE the period from the returned extension, whereas path.extname() includes it.\n     *\n     * @param {string} sFileName\n     * @return {string} the filename's extension (in lower-case and EXCLUDING the \".\"), or an empty string\n     */\n    static getExtension(sFileName)\n    {\n        var sExtension = \"\";\n        var i = sFileName.lastIndexOf(\".\");\n        if (i >= 0) {\n            sExtension = sFileName.substr(i + 1).toLowerCase();\n        }\n        return sExtension;\n    }\n\n    /**\n     * endsWith(s, sSuffix)\n     *\n     * @param {string} s\n     * @param {string} sSuffix\n     * @return {boolean} true if s ends with sSuffix, false if not\n     */\n    static endsWith(s, sSuffix)\n    {\n        return s.indexOf(sSuffix, s.length - sSuffix.length) !== -1;\n    }\n\n    /**\n     * escapeHTML(sHTML)\n     *\n     * @param {string} sHTML\n     * @return {string} with HTML entities \"escaped\", similar to PHP's htmlspecialchars()\n     */\n    static escapeHTML(sHTML)\n    {\n        return sHTML.replace(/[&<>\"']/g, function(m)\n        {\n            return Str.HTMLEscapeMap[m];\n        });\n    }\n\n    /**\n     * replace(sSearch, sReplace, s)\n     *\n     * The JavaScript replace() function ALWAYS interprets \"$\" specially in replacement strings, even when\n     * the search string is NOT a RegExp; specifically:\n     *\n     *      $$  Inserts a \"$\"\n     *      $&  Inserts the matched substring\n     *      $`  Inserts the portion of the string that precedes the matched substring\n     *      $'  Inserts the portion of the string that follows the matched substring\n     *      $n  Where n is a positive integer less than 100, inserts the nth parenthesized sub-match string,\n     *          provided the first argument was a RegExp object\n     *\n     * So, if a replacement string containing dollar signs passes through a series of replace() calls, untold\n     * problems could result.  Hence, this function, which simply uses the replacement string as-is.\n     *\n     * Similar to the JavaScript replace() method (when sSearch is a string), this replaces only ONE occurrence\n     * (ie, the FIRST occurrence); it might be nice to add options to replace the LAST occurrence and/or ALL\n     * occurrences, but we'll revisit that later.\n     *\n     * @param {string} sSearch\n     * @param {string} sReplace\n     * @param {string} s\n     * @return {string}\n     */\n    static replace(sSearch, sReplace, s)\n    {\n        var i = s.indexOf(sSearch);\n        if (i >= 0) {\n            s = s.substr(0, i) + sReplace + s.substr(i + sSearch.length);\n        }\n        return s;\n    }\n\n    /**\n     * replaceAll(sSearch, sReplace, s)\n     *\n     * @param {string} sSearch\n     * @param {string} sReplace\n     * @param {string} s\n     * @return {string}\n     */\n    static replaceAll(sSearch, sReplace, s)\n    {\n        var a = {};\n        a[sSearch] = sReplace;\n        return Str.replaceArray(a, s);\n    }\n\n    /**\n     * replaceArray(a, s)\n     *\n     * @param {Object} a\n     * @param {string} s\n     * @return {string}\n     */\n    static replaceArray(a, s)\n    {\n        var sMatch = \"\";\n        for (var k in a) {\n            /*\n             * As noted in:\n             *\n             *      http://www.regexguru.com/2008/04/escape-characters-only-when-necessary/\n             *\n             * inside character classes, only backslash, caret, hyphen and the closing bracket need to be\n             * escaped.  And in fact, if you ensure that the closing bracket is first, the caret is not first,\n             * and the hyphen is last, you can avoid escaping those as well.\n             */\n            k = k.replace(/([\\\\[\\]*{}().+?|$])/g, \"\\\\$1\");\n            sMatch += (sMatch? '|' : '') + k;\n        }\n        return s.replace(new RegExp('(' + sMatch + ')', \"g\"), function(m)\n        {\n            return a[m];\n        });\n    }\n\n    /**\n     * pad(s, cch, fPadLeft)\n     *\n     * NOTE: the maximum amount of padding currently supported is 40 spaces.\n     *\n     * @param {string} s is a string\n     * @param {number} cch is desired length\n     * @param {boolean} [fPadLeft] (default is padding on the right)\n     * @return {string} the original string (s) with spaces padding it to the specified length\n     */\n    static pad(s, cch, fPadLeft)\n    {\n        var sPadding = \"                                        \";\n        return fPadLeft? (sPadding + s).slice(-cch) : (s + sPadding).slice(0, cch);\n    }\n\n    /**\n     * sprintf(format, ...args)\n     *\n     * Copied from the CCjs project (https://github.com/jeffpar/ccjs/blob/master/lib/stdio.js) and extended.\n     *\n     * Far from complete, let alone sprintf-compatible, but it's adequate for the handful of sprintf-style format\n     * specifiers that I use.\n     *\n     * @param {string} format\n     * @param {...} args\n     * @return {string}\n     */\n    static sprintf(format, ...args)\n    {\n        let buffer = \"\";\n        let aParts = format.split(/%([-+ 0#]?)([0-9]*)(\\.?)([0-9]*)([hlL]?)([A-Za-z%])/);\n\n        let iArg = 0, iPart;\n        for (iPart = 0; iPart < aParts.length - 7; iPart += 7) {\n\n            buffer += aParts[iPart];\n\n            let arg = args[iArg++];\n            let flags = aParts[iPart+1];\n            let minimum = +aParts[iPart+2] || 0;\n            let precision = +aParts[iPart+4] || 0;\n            let conversion = aParts[iPart+6];\n            let ach = null, s;\n\n            switch(conversion) {\n            case 'd':\n                /*\n                 * We could use \"arg |= 0\", but there may be some value to supporting integers > 32 bits.\n                 * \n                 * Also, unlike the 'X' and 'x' hexadecimal cases, there's no need to explicitly check for a string\n                 * arguments, because the call to trunc() automatically coerces any string value to a (decimal) number.\n                 */\n                arg = Math.trunc(arg);\n                /* falls through */\n\n            case 'f':\n                s = Math.trunc(arg) + \"\";\n                if (precision) {\n                    minimum -= (precision + 1);\n                }\n                if (s.length < minimum) {\n                    if (flags == '0') {\n                        if (arg < 0) minimum--;\n                        s = (\"0000000000\" + Math.abs(arg)).slice(-minimum);\n                        if (arg < 0) s = '-' + s;\n                    } else {\n                        s = (\"          \" + s).slice(-minimum);\n                    }\n                }\n                if (precision) {\n                    arg = Math.round((arg - Math.trunc(arg)) * Math.pow(10, precision));\n                    s += '.' + (\"0000000000\" + Math.abs(arg)).slice(-precision);\n                }\n                buffer += s;\n                break;\n\n            case 'c':\n                arg = String.fromCharCode(arg);\n                /* falls through */\n\n            case 's':\n                if (typeof arg == \"string\") {\n                    while (arg.length < minimum) {\n                        if (flags == '-') {\n                            arg += ' ';\n                        } else {\n                            arg = ' ' + arg;\n                        }\n                    }\n                }\n                buffer += arg;\n                break;\n\n            case 'X':\n                ach = Str.HexUpperCase;\n                /* falls through */\n\n            case 'x':\n                if (!ach) ach = Str.HexLowerCase;\n                s = \"\";\n                if (typeof arg == \"string\") {\n                    /*\n                     * Since we're advised to ALWAYS pass a radix to parseInt(), we must detect explicitly\n                     * hex values ourselves, because using a radix of 10 with any \"0x...\" value always returns 0.\n                     * \n                     * And if the value CAN be interpreted as decimal, then we MUST interpret it as decimal, because\n                     * we have sprintf() calls in /modules/lib/testmon.js that depend on this code to perform decimal\n                     * to hex conversion.  We're allowed to make our own rules here, since passing numbers in string\n                     * form isn't part of the sprintf \"spec\". \n                     */\n                    arg = Number.parseInt(arg, arg.match(/(^0x|[a-f])/i)? 16 : 10);\n                } \n                do {\n                    s = ach[arg & 0xf] + s;\n                    arg >>>= 4;\n                } while (--minimum > 0 || arg);\n                buffer += s;\n                break;\n\n            default:\n                /*\n                 * The supported ANSI C set of conversions: \"dioxXucsfeEgGpn%\"\n                 */\n                buffer += \"(unrecognized printf conversion %\" + conversion + \")\";\n                break;\n            }\n        }\n\n        buffer += aParts[iPart];\n        return buffer;\n    }\n\n    /**\n     * stripLeadingZeros(s, fPad)\n     *\n     * @param {string} s\n     * @param {boolean} [fPad]\n     * @return {string}\n     */\n    static stripLeadingZeros(s, fPad)\n    {\n        var cch = s.length;\n        s = s.replace(/^0+([0-9A-F]+)$/i, \"$1\");\n        if (fPad) s = Str.pad(s, cch, true);\n        return s;\n    }\n\n    /**\n     * trim(s)\n     *\n     * @param {string} s\n     * @return {string}\n     */\n    static trim(s)\n    {\n        if (String.prototype.trim) {\n            return s.trim();\n        }\n        return s.replace(/^\\s+|\\s+$/g, \"\");\n    }\n\n    /**\n     * toASCIICode(b)\n     *\n     * @param {number} b\n     * @return {string}\n     */\n    static toASCIICode(b)\n    {\n        var s;\n        if (b != Str.ASCII.CR && b != Str.ASCII.LF) {\n            s = Str.ASCIICodeMap[b];\n        }\n        if (s) {\n            s = '<' + s + '>';\n        } else {\n            s = String.fromCharCode(b);\n        }\n        return s;\n    }\n}\n\n/*\n * Map special characters to their HTML escape sequences.\n */\nStr.HTMLEscapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n};\n\n/*\n * Map \"unprintable\" ASCII codes to mnemonics, to more clearly see what's being printed.\n */\nStr.ASCIICodeMap = {\n    0x00:   \"NUL\",\n    0x01:   \"SOH\",      // (CTRL_A) Start of Heading\n    0x02:   \"STX\",      // (CTRL_B) Start of Text\n    0x03:   \"ETX\",      // (CTRL_C) End of Text\n    0x04:   \"EOT\",      // (CTRL_D) End of Transmission\n    0x05:   \"ENQ\",      // (CTRL_E) Enquiry\n    0x06:   \"ACK\",      // (CTRL_F) Acknowledge\n    0x07:   \"BEL\",      // (CTRL_G) Bell\n    0x08:   \"BS\",       // (CTRL_H) Backspace\n    0x09:   \"TAB\",      // (CTRL_I) Horizontal Tab (aka HT)\n    0x0A:   \"LF\",       // (CTRL_J) Line Feed (New Line)\n    0x0B:   \"VT\",       // (CTRL_K) Vertical Tab\n    0x0C:   \"FF\",       // (CTRL_L) Form Feed (New Page)\n    0x0D:   \"CR\",       // (CTRL_M) Carriage Return\n    0x0E:   \"SO\",       // (CTRL_N) Shift Out\n    0x0F:   \"SI\",       // (CTRL_O) Shift In\n    0x10:   \"DLE\",      // (CTRL_P) Data Link Escape\n    0x11:   \"XON\",      // (CTRL_Q) Device Control 1 (aka DC1)\n    0x12:   \"DC2\",      // (CTRL_R) Device Control 2\n    0x13:   \"XOFF\",     // (CTRL_S) Device Control 3 (aka DC3)\n    0x14:   \"DC4\",      // (CTRL_T) Device Control 4\n    0x15:   \"NAK\",      // (CTRL_U) Negative Acknowledge\n    0x16:   \"SYN\",      // (CTRL_V) Synchronous Idle\n    0x17:   \"ETB\",      // (CTRL_W) End of Transmission Block\n    0x18:   \"CAN\",      // (CTRL_X) Cancel\n    0x19:   \"EM\",       // (CTRL_Y) End of Medium\n    0x1A:   \"SUB\",      // (CTRL_Z) Substitute\n    0x1B:   \"ESC\",      // Escape\n    0x1C:   \"FS\",       // File Separator\n    0x1D:   \"GS\",       // Group Separator\n    0x1E:   \"RS\",       // Record Separator\n    0x1F:   \"US\",       // Unit Separator\n    0x7F:   \"DEL\"\n};\n\n/*\n * Refer to: https://en.wikipedia.org/wiki/Code_page_437\n */\nStr.CP437ToUnicode = [\n    '\\u0000', '\\u263A', '\\u263B', '\\u2665', '\\u2666', '\\u2663', '\\u2660', '\\u2022',\n    '\\u25D8', '\\u25CB', '\\u25D9', '\\u2642', '\\u2640', '\\u266A', '\\u266B', '\\u263C',\n    '\\u25BA', '\\u25C4', '\\u2195', '\\u203C', '\\u00B6', '\\u00A7', '\\u25AC', '\\u21A8',\n    '\\u2191', '\\u2193', '\\u2192', '\\u2190', '\\u221F', '\\u2194', '\\u25B2', '\\u25BC',\n    '\\u0020', '\\u0021', '\\u0022', '\\u0023', '\\u0024', '\\u0025', '\\u0026', '\\u0027',\n    '\\u0028', '\\u0029', '\\u002A', '\\u002B', '\\u002C', '\\u002D', '\\u002E', '\\u002F',\n    '\\u0030', '\\u0031', '\\u0032', '\\u0033', '\\u0034', '\\u0035', '\\u0036', '\\u0037',\n    '\\u0038', '\\u0039', '\\u003A', '\\u003B', '\\u003C', '\\u003D', '\\u003E', '\\u003F',\n    '\\u0040', '\\u0041', '\\u0042', '\\u0043', '\\u0044', '\\u0045', '\\u0046', '\\u0047',\n    '\\u0048', '\\u0049', '\\u004A', '\\u004B', '\\u004C', '\\u004D', '\\u004E', '\\u004F',\n    '\\u0050', '\\u0051', '\\u0052', '\\u0053', '\\u0054', '\\u0055', '\\u0056', '\\u0057',\n    '\\u0058', '\\u0059', '\\u005A', '\\u005B', '\\u005C', '\\u005D', '\\u005E', '\\u005F',\n    '\\u0060', '\\u0061', '\\u0062', '\\u0063', '\\u0064', '\\u0065', '\\u0066', '\\u0067',\n    '\\u0068', '\\u0069', '\\u006A', '\\u006B', '\\u006C', '\\u006D', '\\u006E', '\\u006F',\n    '\\u0070', '\\u0071', '\\u0072', '\\u0073', '\\u0074', '\\u0075', '\\u0076', '\\u0077',\n    '\\u0078', '\\u0079', '\\u007A', '\\u007B', '\\u007C', '\\u007D', '\\u007E', '\\u2302',\n    '\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4', '\\u00E0', '\\u00E5', '\\u00E7',\n    '\\u00EA', '\\u00EB', '\\u00E8', '\\u00EF', '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5',\n    '\\u00C9', '\\u00E6', '\\u00C6', '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9',\n    '\\u00FF', '\\u00D6', '\\u00DC', '\\u00A2', '\\u00A3', '\\u00A5', '\\u20A7', '\\u0192',\n    '\\u00E1', '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1', '\\u00AA', '\\u00BA',\n    '\\u00BF', '\\u2310', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB', '\\u00BB',\n    '\\u2591', '\\u2592', '\\u2593', '\\u2502', '\\u2524', '\\u2561', '\\u2562', '\\u2556',\n    '\\u2555', '\\u2563', '\\u2551', '\\u2557', '\\u255D', '\\u255C', '\\u255B', '\\u2510',\n    '\\u2514', '\\u2534', '\\u252C', '\\u251C', '\\u2500', '\\u253C', '\\u255E', '\\u255F',\n    '\\u255A', '\\u2554', '\\u2569', '\\u2566', '\\u2560', '\\u2550', '\\u256C', '\\u2567',\n    '\\u2568', '\\u2564', '\\u2565', '\\u2559', '\\u2558', '\\u2552', '\\u2553', '\\u256B',\n    '\\u256A', '\\u2518', '\\u250C', '\\u2588', '\\u2584', '\\u258C', '\\u2590', '\\u2580',\n    '\\u03B1', '\\u00DF', '\\u0393', '\\u03C0', '\\u03A3', '\\u03C3', '\\u00B5', '\\u03C4',\n    '\\u03A6', '\\u0398', '\\u03A9', '\\u03B4', '\\u221E', '\\u03C6', '\\u03B5', '\\u2229',\n    '\\u2261', '\\u00B1', '\\u2265', '\\u2264', '\\u2320', '\\u2321', '\\u00F7', '\\u2248',\n    '\\u00B0', '\\u2219', '\\u00B7', '\\u221A', '\\u207F', '\\u00B2', '\\u25A0', '\\u00A0'\n];\n\n/*\n * TODO: Future home of a complete ASCII table.\n */\nStr.ASCII = {\n    LF:     0x0A,\n    CR:     0x0D\n};\n\nStr.TYPES = {\n    NULL:       0,\n    BYTE:       1,\n    WORD:       2,\n    DWORD:      3,\n    NUMBER:     4,\n    STRING:     5,\n    BOOLEAN:    6,\n    OBJECT:     7,\n    ARRAY:      8\n};\n\nStr.HexLowerCase = \"0123456789abcdef\";\nStr.HexUpperCase = \"0123456789ABCDEF\";\n\n\n\n/**\n * @copyright https://www.pcjs.org/modules/shared/lib/usrlib.js (C) Jeff Parsons 2012-2018\n */\n\n/**\n * @typedef {{\n *  mask:       number,\n *  shift:      number\n * }}\n */\nvar BitField;\n\n/**\n * @typedef {Object.<BitField>}\n */\nvar BitFields;\n\nclass Usr {\n    /**\n     * binarySearch(a, v, fnCompare)\n     *\n     * @param {Array} a is an array\n     * @param {number|string|Array|Object} v\n     * @param {function((number|string|Array|Object), (number|string|Array|Object))} [fnCompare]\n     * @return {number} the index of matching entry if non-negative, otherwise the index of the insertion point\n     */\n    static binarySearch(a, v, fnCompare)\n    {\n        var left = 0;\n        var right = a.length;\n        var found = 0;\n        if (fnCompare === undefined) {\n            fnCompare = function(a, b)\n            {\n                return a > b ? 1 : a < b ? -1 : 0;\n            };\n        }\n        while (left < right) {\n            var middle = (left + right) >> 1;\n            var compareResult;\n            compareResult = fnCompare(v, a[middle]);\n            if (compareResult > 0) {\n                left = middle + 1;\n            } else {\n                right = middle;\n                found = !compareResult;\n            }\n        }\n        return found ? left : ~left;\n    }\n\n    /**\n     * binaryInsert(a, v, fnCompare)\n     *\n     * If element v already exists in array a, the array is unchanged (we don't allow duplicates); otherwise, the\n     * element is inserted into the array at the appropriate index.\n     *\n     * @param {Array} a is an array\n     * @param {number|string|Array|Object} v is the value to insert\n     * @param {function((number|string|Array|Object), (number|string|Array|Object))} [fnCompare]\n     */\n    static binaryInsert(a, v, fnCompare)\n    {\n        var index = Usr.binarySearch(a, v, fnCompare);\n        if (index < 0) {\n            a.splice(-(index + 1), 0, v);\n        }\n    }\n\n    /**\n     * getTimestamp()\n     *\n     * @return {string} timestamp containing the current date and time (\"yyyy-mm-dd hh:mm:ss\")\n     */\n    static getTimestamp()\n    {\n        return Usr.formatDate(\"Y-m-d H:i:s\");\n    }\n\n    /**\n     * getMonthDays(nMonth, nYear)\n     *\n     * Note that if we're being called on behalf of the RTC, its year is always truncated to two digits (mod 100),\n     * so we have no idea what century the year 0 might refer to.  When using the normal leap-year formula, 0 fails\n     * the mod 100 test but passes the mod 400 test, so as far as the RTC is concerned, every century year is a leap\n     * year.  Since we're most likely dealing with the year 2000, that's fine, since 2000 was also a leap year.\n     *\n     * TODO: There IS a separate CMOS byte that's supposed to be set to CMOS_ADDR.CENTURY_DATE; it's always BCD,\n     * so theoretically it will contain values like 0x19 or 0x20 (for the 20th and 21st centuries, respectively), and\n     * we could add that as another parameter to this function, to improve the accuracy, but that would go beyond what\n     * a real RTC actually does.\n     *\n     * @param {number} nMonth (1-12)\n     * @param {number} nYear (normally a 4-digit year, but it may also be mod 100)\n     * @return {number} the maximum (1-based) day allowed for the specified month and year\n     */\n    static getMonthDays(nMonth, nYear)\n    {\n        var nDays = Usr.aMonthDays[nMonth - 1];\n        if (nDays == 28) {\n            if ((nYear % 4) === 0 && ((nYear % 100) || (nYear % 400) === 0)) {\n                nDays++;\n            }\n        }\n        return nDays;\n    }\n\n    /**\n     * formatDate(sFormat, date)\n     *\n     * @param {string} sFormat (eg, \"F j, Y\", \"Y-m-d H:i:s\")\n     * @param {Date} [date] (default is the current time)\n     * @return {string}\n     *\n     * Supported identifiers in sFormat include:\n     *\n     *      a:  lowercase ante meridiem and post meridiem (am or pm)\n     *      d:  day of the month, 2 digits with leading zeros (01,02,...,31)\n     *      D:  3-letter day of the week (\"Sun\",\"Mon\",...,\"Sat\")\n     *      F:  month (\"January\",\"February\",...,\"December\")\n     *      g:  hour in 12-hour format, without leading zeros (1,2,...,12)\n     *      h:  hour in 24-hour format, without leading zeros (0,1,...,23)\n     *      H:  hour in 24-hour format, with leading zeros (00,01,...,23)\n     *      i:  minutes, with leading zeros (00,01,...,59)\n     *      j:  day of the month, without leading zeros (1,2,...,31)\n     *      l:  day of the week (\"Sunday\",\"Monday\",...,\"Saturday\")\n     *      m:  month, with leading zeros (01,02,...,12)\n     *      M:  3-letter month (\"Jan\",\"Feb\",...,\"Dec\")\n     *      n:  month, without leading zeros (1,2,...,12)\n     *      s:  seconds, with leading zeros (00,01,...,59)\n     *      y:  2-digit year (eg, 14)\n     *      Y:  4-digit year (eg, 2014)\n     *\n     * For more inspiration, see: http://php.net/manual/en/function.date.php (of which we support ONLY a subset).\n     */\n    static formatDate(sFormat, date)\n    {\n        var sDate = \"\";\n        if (!date) date = new Date();\n        var iHour = date.getHours();\n        var iDay = date.getDate();\n        var iMonth = date.getMonth() + 1;\n        for (var i = 0; i < sFormat.length; i++) {\n            var ch;\n            switch ((ch = sFormat.charAt(i))) {\n            case 'a':\n                sDate += (iHour < 12 ? \"am\" : \"pm\");\n                break;\n            case 'd':\n                sDate += ('0' + iDay).slice(-2);\n                break;\n            case 'D':\n                sDate += Usr.asDays[date.getDay()].substr(0, 3);\n                break;\n            case 'F':\n                sDate += Usr.asMonths[iMonth - 1];\n                break;\n            case 'g':\n                sDate += (!iHour ? 12 : (iHour > 12 ? iHour - 12 : iHour));\n                break;\n            case 'h':\n                sDate += iHour;\n                break;\n            case 'H':\n                sDate += ('0' + iHour).slice(-2);\n                break;\n            case 'i':\n                sDate += ('0' + date.getMinutes()).slice(-2);\n                break;\n            case 'j':\n                sDate += iDay;\n                break;\n            case 'l':\n                sDate += Usr.asDays[date.getDay()];\n                break;\n            case 'm':\n                sDate += ('0' + iMonth).slice(-2);\n                break;\n            case 'M':\n                sDate += Usr.asMonths[iMonth - 1].substr(0, 3);\n                break;\n            case 'n':\n                sDate += iMonth;\n                break;\n            case 's':\n                sDate += ('0' + date.getSeconds()).slice(-2);\n                break;\n            case 'y':\n                sDate += (\"\" + date.getFullYear()).slice(-2);\n                break;\n            case 'Y':\n                sDate += date.getFullYear();\n                break;\n            default:\n                sDate += ch;\n                break;\n            }\n        }\n        return sDate;\n    }\n\n    /**\n     * defineBitFields(bfs)\n     *\n     * Prepares a bit field definition for use with getBitField() and setBitField(); eg:\n     *\n     *      var bfs = Usr.defineBitFields({num:20, count:8, btmod:1, type:3});\n     *\n     * The above defines a set of bit fields containing four fields: num (bits 0-19), count (bits 20-27), btmod (bit 28), and type (bits 29-31).\n     *\n     *      Usr.setBitField(bfs.num, n, 1);\n     *\n     * The above set bit field \"bfs.num\" in numeric variable \"n\" to the value 1.\n     *\n     * @param {Object} bfs\n     * @return {BitFields}\n     */\n    static defineBitFields(bfs)\n    {\n        var bit = 0;\n        for (var f in bfs) {\n            var width = bfs[f];\n            var mask = ((1 << width) - 1) << bit;\n            bfs[f] = {mask: mask, shift: bit};\n            bit += width;\n        }\n        return bfs;\n    }\n\n    /**\n     * initBitFields(bfs, ...)\n     *\n     * @param {BitFields} bfs\n     * @param {...number} var_args\n     * @return {number} a value containing all supplied bit fields\n     */\n    static initBitFields(bfs, var_args)\n    {\n        var v = 0, i = 1;\n        for (var f in bfs) {\n            if (i >= arguments.length) break;\n            v = Usr.setBitField(bfs[f], v, arguments[i++]);\n        }\n        return v;\n    }\n\n    /**\n     * getBitField(bf, v)\n     *\n     * @param {BitField} bf\n     * @param {number} v is a value containing bit fields\n     * @return {number} the value of the bit field in v defined by bf\n     */\n    static getBitField(bf, v)\n    {\n        return (v & bf.mask) >> bf.shift;\n    }\n\n    /**\n     * setBitField(bf, v, n)\n     *\n     * @param {BitField} bf\n     * @param {number} v is a value containing bit fields\n     * @param {number} n is a value to store in v in the bit field defined by bf\n     * @return {number} updated v\n     */\n    static setBitField(bf, v, n)\n    {\n        return (v & ~bf.mask) | ((n << bf.shift) & bf.mask);\n    }\n\n    /**\n     * indexOf(a, t, i)\n     *\n     * Use this instead of Array.prototype.indexOf() if you can't be sure the browser supports it.\n     *\n     * @param {Array} a\n     * @param {*} t\n     * @param {number} [i]\n     * @returns {number}\n     */\n    static indexOf(a, t, i)\n    {\n        if (Array.prototype.indexOf) {\n            return a.indexOf(t, i);\n        }\n        i = i || 0;\n        if (i < 0) i += a.length;\n        if (i < 0) i = 0;\n        for (var n = a.length; i < n; i++) {\n            if (i in a && a[i] === t) return i;\n        }\n        return -1;\n    }\n}\n\nUsr.asDays = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\nUsr.asMonths = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\nUsr.aMonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n/**\n * getTime()\n *\n * @return {number} the current time, in milliseconds\n */\nUsr.getTime = Date.now || function() { return +new Date(); };\n\n\n\n/**\n * @copyright https://www.pcjs.org/modules/shared/lib/weblib.js (C) Jeff Parsons 2012-2018\n */\n\n\n/*\n * According to http://www.w3schools.com/jsref/jsref_obj_global.asp, these are the *global* properties\n * and functions of JavaScript-in-the-Browser:\n *\n * Property             Description\n * ---\n * Infinity             A numeric value that represents positive/negative infinity\n * NaN                  \"Not-a-Number\" value\n * undefined            Indicates that a variable has not been assigned a value\n *\n * Function             Description\n * ---\n * decodeURI()          Decodes a URI\n * decodeURIComponent() Decodes a URI component\n * encodeURI()          Encodes a URI\n * encodeURIComponent() Encodes a URI component\n * escape()             Deprecated in version 1.5. Use encodeURI() or encodeURIComponent() instead\n * eval()               Evaluates a string and executes it as if it was script code\n * isFinite()           Determines whether a value is a finite, legal number\n * isNaN()              Determines whether a value is an illegal number\n * Number()             Converts an object's value to a number\n * parseFloat()         Parses a string and returns a floating point number\n * parseInt()           Parses a string and returns an integer\n * String()             Converts an object's value to a string\n * unescape()           Deprecated in version 1.5. Use decodeURI() or decodeURIComponent() instead\n *\n * And according to http://www.w3schools.com/jsref/obj_window.asp, these are the properties and functions\n * of the *window* object.\n *\n * Property             Description\n * ---\n * closed               Returns a Boolean value indicating whether a window has been closed or not\n * defaultStatus        Sets or returns the default text in the statusbar of a window\n * document             Returns the Document object for the window (See Document object)\n * frames               Returns an array of all the frames (including iframes) in the current window\n * history              Returns the History object for the window (See History object)\n * innerHeight          Returns the inner height of a window's content area\n * innerWidth           Returns the inner width of a window's content area\n * length               Returns the number of frames (including iframes) in a window\n * location             Returns the Location object for the window (See Location object)\n * name                 Sets or returns the name of a window\n * navigator            Returns the Navigator object for the window (See Navigator object)\n * opener               Returns a reference to the window that created the window\n * outerHeight          Returns the outer height of a window, including toolbars/scrollbars\n * outerWidth           Returns the outer width of a window, including toolbars/scrollbars\n * pageXOffset          Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window\n * pageYOffset          Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window\n * parent               Returns the parent window of the current window\n * screen               Returns the Screen object for the window (See Screen object)\n * screenLeft           Returns the x coordinate of the window relative to the screen\n * screenTop            Returns the y coordinate of the window relative to the screen\n * screenX              Returns the x coordinate of the window relative to the screen\n * screenY              Returns the y coordinate of the window relative to the screen\n * self                 Returns the current window\n * status               Sets or returns the text in the statusbar of a window\n * top                  Returns the topmost browser window\n *\n * Method               Description\n * ---\n * alert()              Displays an alert box with a message and an OK button\n * atob()               Decodes a base-64 encoded string\n * blur()               Removes focus from the current window\n * btoa()               Encodes a string in base-64\n * clearInterval()      Clears a timer set with setInterval()\n * clearTimeout()       Clears a timer set with setTimeout()\n * close()              Closes the current window\n * confirm()            Displays a dialog box with a message and an OK and a Cancel button\n * createPopup()        Creates a pop-up window\n * focus()              Sets focus to the current window\n * moveBy()             Moves a window relative to its current position\n * moveTo()             Moves a window to the specified position\n * open()               Opens a new browser window\n * print()              Prints the content of the current window\n * prompt()             Displays a dialog box that prompts the visitor for input\n * resizeBy()           Resizes the window by the specified pixels\n * resizeTo()           Resizes the window to the specified width and height\n * scroll()             This method has been replaced by the scrollTo() method.\n * scrollBy()           Scrolls the content by the specified number of pixels\n * scrollTo()           Scrolls the content to the specified coordinates\n * setInterval()        Calls a function or evaluates an expression at specified intervals (in milliseconds)\n * setTimeout()         Calls a function or evaluates an expression after a specified number of milliseconds\n * stop()               Stops the window from loading\n */\n\nclass Web {\n    /**\n     * log(s, type)\n     *\n     * For diagnostic output only.  DEBUG must be true (or \"--debug\" specified via the command-line)\n     * for Component.log() to display anything.\n     *\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     */\n    static log(s, type)\n    {\n        Component.log(s, type);\n    }\n\n    /**\n     * notice(s, fPrintOnly, id)\n     *\n     * @param {string} s is the message text\n     * @param {boolean} [fPrintOnly]\n     * @param {string} [id] is the caller's ID, if any\n     */\n    static notice(s, fPrintOnly, id)\n    {\n        Component.notice(s, fPrintOnly, id);\n    }\n\n    /**\n     * alertUser(sMessage)\n     * \n     * NOTE: Legacy function for older modules (eg, DiskDump); see Component.alertUser().\n     *\n     * @param {string} sMessage\n     */\n    static alertUser(sMessage)\n    {\n        if (window) {\n            window.alert(sMessage);\n        } else {\n            Web.log(sMessage);\n        }\n    }\n\n    /**\n     * getResource(sURL, type, fAsync, done, progress)\n     *\n     * Request the specified resource (sURL), and once the request is complete, notify done().\n     *\n     * If fAsync is true, a done() callback should ALWAYS be supplied; otherwise, you'll have no\n     * idea when the request is complete or what the response was.  done() is passed three parameters:\n     *\n     *      done(sURL, resource, nErrorCode)\n     *\n     * If nErrorCode is zero, resource should contain the requested data; otherwise, an error occurred.\n     *\n     * If type is set to a string, that string can be used to control the response format;\n     * by default, the response format is plain text, but you can specify \"arraybuffer\" to request arbitrary\n     * binary data, in which case the returned resource will be a ArrayBuffer rather than a string.\n     *\n     * @param {string} sURL\n     * @param {string|Object|null} [type] (object for POST request, otherwise type of GET request)\n     * @param {boolean} [fAsync] is true for an asynchronous request; false otherwise (MUST be set for IE)\n     * @param {function(string,string,number)} [done]\n     * @param {function(number)} [progress]\n     * @return {Array|null} Array containing [resource, nErrorCode], or null if no response available (yet)\n     */\n    static getResource(sURL, type = \"text\", fAsync = false, done, progress)\n    {\n        var nErrorCode = 0, resource = null, response = null;\n\n        if (typeof resources == 'object' && (resource = resources[sURL])) {\n            if (done) done(sURL, resource, nErrorCode);\n            return [resource, nErrorCode];\n        }\n        else if (fAsync && typeof resources == 'function') {\n            resources(sURL, function(resource, nErrorCode)\n            {\n                if (done) done(sURL, resource, nErrorCode);\n            });\n            return response;\n        }\n\n        if (!DEBUG && !NODE) {\n            /*\n             * TODO: Perhaps it's time for our code in netlib.js to finally add support for HTTPS; for now\n             * though, it's just as well that the NODE environment assumes all resources are available locally.\n             */\n            sURL = sURL.replace(/^\\/(pcjs-disks|private-disks)\\//, \"https://jeffpar.github.io/$1/\");\n        }\n        else {\n            /*\n             * The larger resources we put on archive.pcjs.org should also be available locally.\n             *\n             * NOTE: \"http://archive.pcjs.org\" is now \"https://s3-us-west-2.amazonaws.com/archive.pcjs.org\"\n             */\n            sURL = sURL.replace(/^(http:\\/\\/archive\\.pcjs\\.org|https:\\/\\/s3-us-west-2\\.amazonaws\\.com\\/archive\\.pcjs\\.org)(\\/.*)\\/([^\\/]*)$/, \"$2/archive/$3\");\n            sURL = sURL.replace(/^https:\\/\\/jeffpar\\.github\\.io\\/(pcjs-disks|private-disks)\\/(.*)$/, \"/$1/$2\");\n        }\n\n\n        var request = (window.XMLHttpRequest? new window.XMLHttpRequest() : new window.ActiveXObject(\"Microsoft.XMLHTTP\"));\n        var fArrayBuffer = false, fXHR2 = (typeof request.responseType === 'string');\n        \n        var callback = function() {\n            if (request.readyState !== 4) {\n                if (progress) progress(1);\n                return null;\n            }\n            /*\n             * The following line was recommended for WebKit, as a work-around to prevent the handler firing multiple\n             * times when debugging.  Unfortunately, that's not the only XMLHttpRequest problem that occurs when\n             * debugging, so I think the WebKit problem is deeper than that.  When we have multiple XMLHttpRequests\n             * pending, any debugging activity means most of them simply get dropped on floor, so what may actually be\n             * happening are mis-notifications rather than redundant notifications.\n             *\n             *      request.onreadystatechange = undefined;\n             */\n            /*\n             * If the request failed due to, say, a CORS policy denial; eg:\n             * \n             *      Failed to load http://www.allbootdisks.com/downloads/Disks/Windows_95_Boot_Disk_Download48/Diskette%20Images/Windows95a.img:\n             *      Redirect from 'http://www.allbootdisks.com/downloads/Disks/Windows_95_Boot_Disk_Download48/Diskette%20Images/Windows95a.img' to\n             *      'http://www.allbootdisks.com/' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n             *      Origin 'http://pcjs:8088' is therefore not allowed access.\n             *      \n             * and our request type was \"arraybuffer\", attempting to access responseText may trigger an exception; eg:\n             * \n             *      Uncaught DOMException: Failed to read the 'responseText' property from 'XMLHttpRequest': The value is only accessible if the object's\n             *      'responseType' is '' or 'text' (was 'arraybuffer').\n             * \n             * We could tiptoe around these potential landmines, but the safest thing to do is wrap this code with try/catch.\n             */\n            try {\n                resource = fArrayBuffer? request.response : request.responseText;\n            } catch(err) {\n                if (MAXDEBUG) Web.log(\"xmlHTTPRequest(\" + sURL + \") exception: \" + err.message);\n            }\n            /*\n             * The normal \"success\" case is a non-null resource and an HTTP status code of 200, but when loading files from the\n             * local file system (ie, when using the \"file:\" protocol), we have to be a bit more flexible.\n             */\n            if (resource != null && (request.status == 200 || !request.status && resource.length && Web.getHostProtocol() == \"file:\")) {\n                if (MAXDEBUG) Web.log(\"xmlHTTPRequest(\" + sURL + \"): returned \" + resource.length + \" bytes\");\n            }\n            else {\n                nErrorCode = request.status || -1;\n                Web.log(\"xmlHTTPRequest(\" + sURL + \"): error code \" + nErrorCode);\n            }\n            if (progress) progress(2);\n            if (done) done(sURL, resource, nErrorCode);\n            return [resource, nErrorCode];\n        };\n        \n        if (fAsync) {\n            request.onreadystatechange = callback;\n        }\n\n        if (progress) progress(0);\n\n        if (type && typeof type == \"object\") {\n            var sPost = \"\";\n            for (var p in type) {\n                if (!type.hasOwnProperty(p)) continue;\n                if (sPost) sPost += \"&\";\n                sPost += p + '=' + encodeURIComponent(type[p]);\n            }\n            sPost = sPost.replace(/%20/g, '+');\n            if (MAXDEBUG) Web.log(\"Web.getResource(POST \" + sURL + \"): \" + sPost.length + \" bytes\");\n            request.open(\"POST\", sURL, fAsync);\n            request.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n            request.send(sPost);\n        } else {\n            if (MAXDEBUG) Web.log(\"Web.getResource(GET \" + sURL + \")\");\n            request.open(\"GET\", sURL, fAsync);\n            if (type == \"arraybuffer\") {\n                if (fXHR2) {\n                    fArrayBuffer = true;\n                    request.responseType = type;\n                } else {\n                    request.overrideMimeType(\"text/plain; charset=x-user-defined\");\n                }\n            }\n            request.send();\n        }\n\n        if (!fAsync) {\n            request.readyState = 4;     // this may already be set for synchronous requests, but I don't want to take any chances \n            response = callback();\n        }\n        return response;\n    }\n\n    /**\n     * parseMemoryResource(sURL, sData)\n     *\n     * This converts a variety of JSON-style data streams into an Object with the following properties:\n     *\n     *      aBytes\n     *      aSymbols\n     *      addrLoad\n     *      addrExec\n     *\n     * If the source data contains a 'bytes' array, it's passed through to 'aBytes'; alternatively, if\n     * it contains a 'words' array, the values are converted from 16-bit to 8-bit and stored in 'aBytes',\n     * and if it contains a 'longs' array, the values are converted from 32-bit longs into bytes and\n     * stored in 'aBytes'.\n     *\n     * Alternatively, if the source data contains a 'data' array, we simply pass that through to the output\n     * object as:\n     *\n     *      aData\n     *\n     * @param {string} sURL\n     * @param {string} sData\n     * @return {Object|null} (resource)\n     */\n    static parseMemoryResource(sURL, sData)\n    {\n        var i;\n        var resource = {\n            aBytes: null,\n            aSymbols: null,\n            addrLoad: null,\n            addrExec: null\n        };\n\n        if (sData.charAt(0) == \"[\" || sData.charAt(0) == \"{\") {\n            try {\n                var a, ib, data;\n\n                if (sData.substr(0, 1) == \"<\") {    // if the \"data\" begins with a \"<\"...\n                    /*\n                     * Early server configs reported an error (via the nErrorCode parameter) if a tape URL was invalid,\n                     * but more recent server configs now display a somewhat friendlier HTML error page.  The downside,\n                     * however, is that the original error has been buried, and we've received \"data\" that isn't actually\n                     * tape data.  So if the data we've received appears to be \"HTML-like\", we treat it as an error message.\n                     */\n                    throw new Error(sData);\n                }\n\n                /*\n                 * TODO: IE9 is rather unfriendly and restrictive with regard to how much data it's willing to\n                 * eval().  In particular, the 10Mb disk image we use for the Windows 1.01 demo config fails in\n                 * IE9 with an \"Out of memory\" exception.  One work-around would be to chop the data into chunks\n                 * (perhaps one track per chunk, using regular expressions) and then manually re-assemble it.\n                 *\n                 * However, it turns out that using JSON.parse(sDiskData) instead of eval(\"(\" + sDiskData + \")\")\n                 * is a much easier fix. The only drawback is that we must first quote any unquoted property names\n                 * and remove any comments, because while eval() was cool with them, JSON.parse() is more particular;\n                 * the following RegExp replacements take care of those requirements.\n                 *\n                 * The use of hex values is something else that eval() was OK with, but JSON.parse() is not, and\n                 * while I've stopped using hex values in DumpAPI responses (at least when \"format=json\" is specified),\n                 * I can't guarantee they won't show up in \"legacy\" images, and there's no simple RegExp replacement\n                 * for transforming hex values into decimal values, so I cop out and fall back to eval() if I detect\n                 * any hex prefixes (\"0x\") in the sequence.  Ditto for error messages, which appear like so:\n                 *\n                 *      [\"unrecognized disk path: test.img\"]\n                 */\n                if (sData.indexOf(\"0x\") < 0 && sData.indexOf(\"0o\") < 0 && sData.substr(0, 2) != '[\"') {\n                    data = JSON.parse(sData.replace(/([a-z]+):/gm, '\"$1\":').replace(/\\/\\/[^\\n]*/gm, \"\"));\n                } else {\n                    data = eval(\"(\" + sData + \")\");\n                }\n\n                resource.addrLoad = data['load'];\n                resource.addrExec = data['exec'];\n\n                if (a = data['bytes']) {\n                    resource.aBytes = a;\n                }\n                else if (a = data['words']) {\n                    /*\n                     * Convert all words into bytes\n                     */\n                    resource.aBytes = new Array(a.length * 2);\n                    for (i = 0, ib = 0; i < a.length; i++) {\n                        resource.aBytes[ib++] = a[i] & 0xff;\n                        resource.aBytes[ib++] = (a[i] >> 8) & 0xff;\n\n                    }\n                }\n                else if (a = data['longs']) {\n                    /*\n                     * Convert all dwords (longs) into bytes\n                     */\n                    resource.aBytes = new Array(a.length * 4);\n                    for (i = 0, ib = 0; i < a.length; i++) {\n                        resource.aBytes[ib++] = a[i] & 0xff;\n                        resource.aBytes[ib++] = (a[i] >> 8) & 0xff;\n                        resource.aBytes[ib++] = (a[i] >> 16) & 0xff;\n                        resource.aBytes[ib++] = (a[i] >> 24) & 0xff;\n                    }\n                }\n                else if (a = data['data']) {\n                    resource.aData = a;\n                }\n                else {\n                    resource.aBytes = data;\n                }\n\n                if (resource.aBytes) {\n                    if (!resource.aBytes.length) {\n                        Component.error(\"Empty resource: \" + sURL);\n                        resource = null;\n                    }\n                    else if (resource.aBytes.length == 1) {\n                        Component.error(resource.aBytes[0]);\n                        resource = null;\n                    }\n                }\n                resource.aSymbols = data['symbols'];\n\n            } catch (e) {\n                Component.error(\"Resource data error (\" + sURL + \"): \" + e.message);\n                resource = null;\n            }\n        }\n        else {\n            /*\n             * Parse the data manually; we assume it's a series of hex byte-values separated by whitespace.\n             */\n            var ab = [];\n            var sHexData = sData.replace(/\\n/gm, \" \").replace(/ +$/, \"\");\n            var asHexData = sHexData.split(\" \");\n            for (i = 0; i < asHexData.length; i++) {\n                var n = parseInt(asHexData[i], 16);\n                if (isNaN(n)) {\n                    Component.error(\"Resource data error (\" + sURL + \"): invalid hex byte (\" + asHexData[i] + \")\");\n                    break;\n                }\n                ab.push(n & 0xff);\n            }\n            if (i == asHexData.length) resource.aBytes = ab;\n        }\n        return resource;\n    }\n\n    /**\n     * sendReport(sApp, sVer, sURL, sUser, sType, sReport, sHostName)\n     *\n     * Send a report (eg, bug report) to the server.\n     *\n     * @param {string} sApp (eg, \"PCjs\")\n     * @param {string} sVer (eg, \"1.02\")\n     * @param {string} sURL (eg, \"/devices/pc/machine/5150/mda/64kb/machine.xml\")\n     * @param {string} sUser (ie, the user key, if any)\n     * @param {string} sType (eg, \"bug\"); one of ReportAPI.TYPE.*\n     * @param {string} sReport (eg, unparsed state data)\n     * @param {string} [sHostName] (default is http://SITEHOST)\n     */\n    static sendReport(sApp, sVer, sURL, sUser, sType, sReport, sHostName)\n    {\n        var dataPost = {};\n        dataPost[ReportAPI.QUERY.APP] = sApp;\n        dataPost[ReportAPI.QUERY.VER] = sVer;\n        dataPost[ReportAPI.QUERY.URL] = sURL;\n        dataPost[ReportAPI.QUERY.USER] = sUser;\n        dataPost[ReportAPI.QUERY.TYPE] = sType;\n        dataPost[ReportAPI.QUERY.DATA] = sReport;\n        var sReportURL = (sHostName? sHostName : \"http://\" + SITEHOST) + ReportAPI.ENDPOINT;\n        Web.getResource(sReportURL, dataPost, true);\n    }\n\n    /**\n     * getHost()\n     *\n     * @return {string}\n     */\n    static getHost()\n    {\n        return (\"http://\" + (window? window.location.host : SITEHOST));\n    }\n\n    /**\n     * getHostURL()\n     *\n     * @return {string|null}\n     */\n    static getHostURL()\n    {\n        return (window? window.location.href : null);\n    }\n\n    /**\n     * getHostProtocol()\n     *\n     * @return {string}\n     */\n    static getHostProtocol()\n    {\n        return (window? window.location.protocol : \"file:\");\n    }\n\n    /**\n     * getUserAgent()\n     *\n     * @return {string}\n     */\n    static getUserAgent()\n    {\n        return (window? window.navigator.userAgent : \"\");\n    }\n\n    /**\n     * hasLocalStorage\n     *\n     * true if localStorage support exists, is enabled, and works; false otherwise\n     *\n     * @return {boolean}\n     */\n    static hasLocalStorage()\n    {\n        if (Web.fLocalStorage == null) {\n            var f = false;\n            if (window) {\n                try {\n                    window.localStorage.setItem(Web.sLocalStorageTest, Web.sLocalStorageTest);\n                    f = (window.localStorage.getItem(Web.sLocalStorageTest) == Web.sLocalStorageTest);\n                    window.localStorage.removeItem(Web.sLocalStorageTest);\n                } catch (e) {\n                    Web.logLocalStorageError(e);\n                    f = false;\n                }\n            }\n            Web.fLocalStorage = f;\n        }\n        return Web.fLocalStorage;\n    }\n\n    /**\n     * logLocalStorageError(e)\n     *\n     * @param {Error} e is an exception\n     */\n    static logLocalStorageError(e)\n    {\n        Web.log(e.message, \"localStorage error\");\n    }\n\n    /**\n     * getLocalStorageItem(sKey)\n     *\n     * Returns the requested key value, or null if the key does not exist, or undefined if localStorage is not available\n     *\n     * @param {string} sKey\n     * @return {string|null|undefined} sValue\n     */\n    static getLocalStorageItem(sKey)\n    {\n        var sValue;\n        if (window) {\n            try {\n                sValue = window.localStorage.getItem(sKey);\n            } catch (e) {\n                Web.logLocalStorageError(e);\n            }\n        }\n        return sValue;\n    }\n\n    /**\n     * setLocalStorageItem(sKey, sValue)\n     *\n     * @param {string} sKey\n     * @param {string} sValue\n     * @return {boolean} true if localStorage is available, false if not\n     */\n    static setLocalStorageItem(sKey, sValue)\n    {\n        try {\n            window.localStorage.setItem(sKey, sValue);\n            return true;\n        } catch (e) {\n            Web.logLocalStorageError(e);\n        }\n        return false;\n    }\n\n    /**\n     * removeLocalStorageItem(sKey)\n     *\n     * @param {string} sKey\n     */\n    static removeLocalStorageItem(sKey)\n    {\n        try {\n            window.localStorage.removeItem(sKey);\n        } catch (e) {\n            Web.logLocalStorageError(e);\n        }\n    }\n\n    /**\n     * getLocalStorageKeys()\n     *\n     * @return {Array}\n     */\n    static getLocalStorageKeys()\n    {\n        var a = [];\n        try {\n            for (var i = 0, c = window.localStorage.length; i < c; i++) {\n                a.push(window.localStorage.key(i));\n            }\n        } catch (e) {\n            Web.logLocalStorageError(e);\n        }\n        return a;\n    }\n\n    /**\n     * reloadPage()\n     */\n    static reloadPage()\n    {\n        if (window) window.location.reload();\n    }\n\n    /**\n     * isUserAgent(s)\n     *\n     * Check the browser's user-agent string for the given substring; \"iOS\" and \"MSIE\" are special values you can\n     * use that will match any iOS or MSIE browser, respectively (even IE11, in the case of \"MSIE\").\n     *\n     * 2013-11-06: In a questionable move, MSFT changed the user-agent reported by IE11 on Windows 8.1, eliminating\n     * the \"MSIE\" string (which MSDN calls a \"version token\"; see http://msdn.microsoft.com/library/ms537503.aspx);\n     * they say \"public websites should rely on feature detection, rather than browser detection, in order to design\n     * their sites for browsers that don't support the features used by the website.\" So, in IE11, we get a user-agent\n     * that tries to fool apps into thinking the browser is more like WebKit or Gecko:\n     *\n     *      Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\n     *\n     * That's a nice idea, but in the meantime, they hosed the XSL transform code in embed.js, which contained\n     * some very critical browser-specific code; turning on IE's \"Compatibility Mode\" didn't help either, because\n     * that's a sledgehammer solution which restores the old user-agent string but also disables other features like\n     * HTML5 canvas support. As an interim solution, I'm treating any \"MSIE\" check as a check for either \"MSIE\" or\n     * \"Trident\".\n     *\n     * UPDATE: I've since found ways to make the code in embed.js more browser-agnostic, so for now, there's isn't\n     * any code that cares about \"MSIE\", but I've left the change in place, because I wouldn't be surprised if I'll\n     * need more IE-specific code in the future, perhaps for things like copy/paste functionality, or mouse capture.\n     *\n     * @param {string} s is a substring to search for in the user-agent; as noted above, \"iOS\" and \"MSIE\" are special values\n     * @return {boolean} is true if the string was found, false if not\n     */\n    static isUserAgent(s)\n    {\n        if (window) {\n            var userAgent = Web.getUserAgent();\n            /*\n             * Here's one case where we have to be careful with Component, because when isUserAgent() is called by\n             * the init code below, component.js hasn't been loaded yet.  The simple solution for now is to remove the call.\n             *\n             *      Web.log(\"agent: \" + userAgent);\n             *\n             * And yes, it would be pointless to use the conditional (?) operator below, if not for the Google Closure\n             * Compiler (v20130823) failing to detect the entire expression as a boolean.\n             */\n            return s == \"iOS\" && !!userAgent.match(/(iPod|iPhone|iPad)/) && !!userAgent.match(/AppleWebKit/) || s == \"MSIE\" && !!userAgent.match(/(MSIE|Trident)/) || (userAgent.indexOf(s) >= 0);\n        }\n        return false;\n    }\n\n    /**\n     * isMobile(sDevice)\n     *\n     * Checks the URL for a \"mobile\" parameter, and failing that, checks the browser's user-agent string for the\n     * substring \"Mobi\", as per Mozilla recommendation:\n     *\n     *      https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent\n     *\n     * @param {string} [sDevice] (eg, \"iPad\" to check for iPad, or \"!iPad\" to specifically exclude it) \n     * @return {boolean} is true if the browser appears to be a mobile (ie, non-desktop) web browser, false if not\n     */\n    static isMobile(sDevice)\n    {\n        var sMobile = Web.getURLParm(\"mobile\");\n        if (sMobile) return sMobile == \"true\";\n        if (Web.isUserAgent(\"Mobi\")) {\n            if (!sDevice) return true;\n            var fInvert = sDevice[0] == '!';\n            if (fInvert) sDevice = sDevice.substr(1);\n            return Web.isUserAgent(sDevice) != fInvert;\n        }\n        return false;\n    }\n\n    /**\n     * findProperty(obj, sProp, sSuffix)\n     *\n     * If both sProp and sSuffix are set, then any browser-specific prefixes are inserted between sProp and sSuffix,\n     * and if a match is found, it is returned without sProp.\n     *\n     * For example, if findProperty(document, 'on', 'fullscreenchange') discovers that 'onwebkitfullscreenchange' exists,\n     * it will return 'webkitfullscreenchange', in preparation for an addEventListener() call.\n     *\n     * More commonly, sSuffix is not used, so whatever property is found is returned as-is.\n     *\n     * @param {Object|null|undefined} obj\n     * @param {string} sProp\n     * @param {string} [sSuffix]\n     * @return {string|null}\n     */\n    static findProperty(obj, sProp, sSuffix)\n    {\n        if (obj) {\n            for (var i = 0; i < Web.asBrowserPrefixes.length; i++) {\n                var sName = Web.asBrowserPrefixes[i];\n                if (sSuffix) {\n                    sName += sSuffix;\n                    var sEvent = sProp + sName;\n                    if (sEvent in obj) return sName;\n                } else {\n                    if (!sName) {\n                        sName = sProp[0];\n                    } else {\n                        sName += sProp[0].toUpperCase();\n                    }\n                    sName += sProp.substr(1);\n                    if (sName in obj) return sName;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * getURLParm(sParm)\n     *\n     * First looks for sParm exactly as specified, then looks for the lower-case version.\n     *\n     * @param {string} sParm\n     * @return {string|undefined}\n     */\n    static getURLParm(sParm)\n    {\n        if (!Web.parmsURL) {\n            Web.parmsURL = Web.parseURLParms();\n        }\n        return Web.parmsURL[sParm] || Web.parmsURL[sParm.toLowerCase()];\n    }\n\n    /**\n     * parseURLParms(sParms)\n     *\n     * @param {string} [sParms] containing the parameter portion of a URL (ie, after the '?')\n     * @return {Object} containing properties for each parameter found\n     */\n    static parseURLParms(sParms)\n    {\n        var aParms = {};\n        if (window) {       // an alternative to \"if (typeof module === 'undefined')\" if require(\"defines\") was used\n            if (!sParms) {\n                /*\n                 * Note that window.location.href returns the entire URL, whereas window.location.search\n                 * returns only the parameters, if any (starting with the '?', which we skip over with a substr() call).\n                 */\n                sParms = window.location.search.substr(1);\n            }\n            var match;\n            var pl = /\\+/g; // RegExp for replacing addition symbol with a space\n            var search = /([^&=]+)=?([^&]*)/g;\n            var decode = function(s)\n            {\n                return decodeURIComponent(s.replace(pl, \" \"));\n            };\n\n            while ((match = search.exec(sParms))) {\n                aParms[decode(match[1])] = decode(match[2]);\n            }\n        }\n        return aParms;\n    }\n\n    /**\n     * downloadFile(sData, sType, fBase64, sFileName)\n     *\n     * @param {string} sData\n     * @param {string} sType\n     * @param {boolean} [fBase64]\n     * @param {string} [sFileName]\n     */\n    static downloadFile(sData, sType, fBase64, sFileName)\n    {\n        var link = null, sAlert;\n        var sURI = \"data:application/\" + sType + (fBase64? \";base64\" : \"\") + \",\";\n\n        if (!Web.isUserAgent(\"Firefox\")) {\n            sURI += (fBase64? sData : encodeURI(sData));\n        } else {\n            sURI += (fBase64? sData : encodeURIComponent(sData));\n        }\n        if (sFileName) {\n            link = document.createElement('a');\n            if (typeof link.download != 'string') link = null;\n        }\n        if (link) {\n            link.href = sURI;\n            link.download = sFileName;\n            document.body.appendChild(link);    // Firefox allegedly requires the link to be in the body\n            link.click();\n            document.body.removeChild(link);\n            sAlert = 'Check your Downloads folder for ' + sFileName + '.';\n            if (Web.isUserAgent(\"Chrome\")) {\n                sAlert += '\\n\\nIn Chrome, after clicking OK, you may ALSO have to select the \"Window\" menu, choose \"Downloads\", and then locate this download and select \"Keep\".';\n                sAlert += '\\n\\nThis is part of Chrome\\'s \"Security By Jumping Through Extra Hoops\" technology, which is much easier for Google to implement than actually checking for something malicious.';\n                sAlert += '\\n\\nAnd for the record, there is nothing malicious on the PCjs website.';\n            }\n        } else {\n            window.open(sURI);\n            sAlert = 'Check your browser for a new window/tab containing the requested data' + (sFileName? (' (' + sFileName + ')') : '') + '.';\n        }\n        return sAlert;\n    }\n\n    /**\n     * onCountRepeat(n, fnRepeat, fnComplete, msDelay)\n     *\n     * Call fnRepeat() n times with an msDelay millisecond delay between calls,\n     * then call fnComplete() when n has been exhausted OR fnRepeat() returns false.\n     *\n     * @param {number} n\n     * @param {function()} fnRepeat\n     * @param {function()} fnComplete\n     * @param {number} [msDelay]\n     */\n    static onCountRepeat(n, fnRepeat, fnComplete, msDelay)\n    {\n        var fnTimeout = function doCountRepeat()\n        {\n            n -= 1;\n            if (n >= 0) {\n                if (!fnRepeat()) n = 0;\n            }\n            if (n > 0) {\n                setTimeout(fnTimeout, msDelay || 0);\n                return;\n            }\n            fnComplete();\n        };\n        fnTimeout();\n    }\n\n    /**\n     * onClickRepeat(e, msDelay, msRepeat, fn)\n     *\n     * Repeatedly call fn() with an initial msDelay, and an msRepeat delay thereafter,\n     * as long as HTML control Object e has an active \"down\" event and fn() returns true.\n     *\n     * @param {Object} e\n     * @param {number} msDelay\n     * @param {number} msRepeat\n     * @param {function(boolean)} fn is passed false on the first call, true on all repeated calls\n     */\n    static onClickRepeat(e, msDelay, msRepeat, fn)\n    {\n        var ms = 0, timer = null, fIgnoreMouseEvents = false;\n\n        var fnRepeat = function doClickRepeat()\n        {\n            if (fn(ms === msRepeat)) {\n                timer = setTimeout(fnRepeat, ms);\n                ms = msRepeat;\n            }\n        };\n        e.onmousedown = function()\n        {\n            // Web.log(\"onMouseDown()\");\n            if (!fIgnoreMouseEvents) {\n                if (!timer) {\n                    ms = msDelay;\n                    fnRepeat();\n                }\n            }\n        };\n        e.ontouchstart = function()\n        {\n            // Web.log(\"onTouchStart()\");\n            if (!timer) {\n                ms = msDelay;\n                fnRepeat();\n            }\n        };\n        e.onmouseup = e.onmouseout = function()\n        {\n            // Web.log(\"onMouseUp()/onMouseOut()\");\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n        e.ontouchend = e.ontouchcancel = function()\n        {\n            // Web.log(\"onTouchEnd()/onTouchCancel()\");\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            /*\n             * Devices that generate ontouch* events ALSO generate onmouse* events,\n             * and generally do so immediately after all the touch events are complete,\n             * so unless we want double the action, we need to ignore mouse events.\n             */\n            fIgnoreMouseEvents = true;\n        };\n    }\n\n    /**\n     * onPageEvent(sName, fn)\n     *\n     * For 'onload', 'onunload', and 'onpageshow' events, most callers should NOT use this function, but\n     * instead use Web.onInit(), Web.onShow(), and Web.onExit(), respectively.\n     *\n     * The only components that should still use onPageEvent() are THIS component (see the bottom of this file)\n     * and components that need to capture other events (eg, the 'onresize' event in the Video component).\n     *\n     * This function creates a chain of callbacks, allowing multiple JavaScript modules to define handlers\n     * for the same event, which wouldn't be possible if everyone modified window['onload'], window['onunload'],\n     * etc, themselves.  However, that's less of a concern now, because assuming everyone else is now using\n     * onInit(), onExit(), etc, then there really IS only one component setting the window callback: this one.\n     *\n     * NOTE: It's risky to refer to obscure event handlers with \"dot\" names, because the Closure Compiler may\n     * erroneously replace them (eg, window.onpageshow is a good example).\n     *\n     * @param {string} sFunc\n     * @param {function()} fn\n     */\n    static onPageEvent(sFunc, fn)\n    {\n        if (window) {\n            var fnPrev = window[sFunc];\n            if (typeof fnPrev !== 'function') {\n                window[sFunc] = fn;\n            } else {\n                /*\n                 * TODO: Determine whether there's any value in receiving/sending the Event object that the\n                 * browser provides when it generates the original event.\n                 */\n                window[sFunc] = function onWindowEvent()\n                {\n                    if (fnPrev) fnPrev();\n                    fn();\n                };\n            }\n        }\n    };\n\n    /**\n     * onInit(fn)\n     *\n     * Use this instead of setting window.onload.  Allows multiple JavaScript modules to define their own 'onload' event handler.\n     *\n     * @param {function()} fn\n     */\n    static onInit(fn)\n    {\n        Web.aPageEventHandlers['init'].push(fn);\n    };\n\n    /**\n     * onShow(fn)\n     *\n     * @param {function()} fn\n     *\n     * Use this instead of setting window.onpageshow.  Allows multiple JavaScript modules to define their own 'onpageshow' event handler.\n     */\n    static onShow(fn)\n    {\n        Web.aPageEventHandlers['show'].push(fn);\n    };\n\n    /**\n     * onExit(fn)\n     *\n     * @param {function()} fn\n     *\n     * Use this instead of setting window.onunload.  Allows multiple JavaScript modules to define their own 'onunload' event handler.\n     */\n    static onExit(fn)\n    {\n        Web.aPageEventHandlers['exit'].push(fn);\n    };\n\n    /**\n     * doPageEvent(afn)\n     *\n     * @param {Array.<function()>} afn\n     */\n    static doPageEvent(afn)\n    {\n        if (Web.fPageEventsEnabled) {\n            try {\n                for (var i = 0; i < afn.length; i++) {\n                    afn[i]();\n                }\n            } catch (e) {\n                Web.notice(\"An unexpected error occurred: \" + e.message + \"\\n\\nIf it happens again, please send this information to support@pcjs.org. Thanks.\");\n            }\n        }\n    };\n\n    /**\n     * enablePageEvents(fEnable)\n     *\n     * @param {boolean} fEnable is true to enable page events, false to disable (they're enabled by default)\n     */\n    static enablePageEvents(fEnable)\n    {\n        if (!Web.fPageEventsEnabled && fEnable) {\n            Web.fPageEventsEnabled = true;\n            if (Web.fPageLoaded) Web.sendPageEvent('init');\n            if (Web.fPageShowed) Web.sendPageEvent('show');\n            return;\n        }\n        Web.fPageEventsEnabled = fEnable;\n    }\n\n    /**\n     * sendPageEvent(sEvent)\n     *\n     * This allows us to manually trigger page events.\n     *\n     * @param {string} sEvent (one of 'init', 'show' or 'exit')\n     */\n    static sendPageEvent(sEvent)\n    {\n        if (Web.aPageEventHandlers[sEvent]) {\n            Web.doPageEvent(Web.aPageEventHandlers[sEvent]);\n        }\n    }\n}\n\nWeb.parmsURL = null;            // initialized on first call to parseURLParms()\n\nWeb.aPageEventHandlers = {\n    'init': [],                 // list of window 'onload' handlers\n    'show': [],                 // list of window 'onpageshow' handlers\n    'exit': []                  // list of window 'onunload' handlers (although we prefer to use 'onbeforeunload' if possible)\n};\n\nWeb.asBrowserPrefixes = ['', 'moz', 'ms', 'webkit'];\n\nWeb.fPageLoaded = false;        // set once the page's first 'onload' event has occurred\nWeb.fPageShowed = false;        // set once the page's first 'onpageshow' event has occurred\nWeb.fPageEventsEnabled = true;  // default is true, set to false (or true) by enablePageEvents()\n\n/**\n * fLocalStorage\n *\n * true if localStorage support exists, is enabled, and works; \"falsey\" otherwise\n *\n * @type {boolean|null}\n */\nWeb.fLocalStorage = null;\n\n/**\n * TODO: Is there any way to get the Closure Compiler to stop inlining this string?  This isn't cutting it.\n *\n * @const {string}\n */\nWeb.sLocalStorageTest = \"PCjs.localStorage\";\n\nWeb.onPageEvent('onload', function onPageLoad() {\n    Web.fPageLoaded = true;\n    Web.doPageEvent(Web.aPageEventHandlers['init']);\n});\n\nWeb.onPageEvent('onpageshow', function onPageShow() {\n    Web.fPageShowed = true;\n    Web.doPageEvent(Web.aPageEventHandlers['show']);\n});\n\nWeb.onPageEvent(Web.isUserAgent(\"iOS\")? 'onpagehide' : (Web.isUserAgent(\"Opera\")? 'onunload' : 'onbeforeunload'), function onPageUnload() {\n    Web.doPageEvent(Web.aPageEventHandlers['exit']);\n});\n\n\n\n/**\n * @copyright https://www.pcjs.org/modules/shared/lib/component.js (C) Jeff Parsons 2012-2018\n */\n\n/*\n * All PCjs components now use JSDoc types, primarily so that Google's Closure Compiler will compile\n * everything with zero warnings when ADVANCED_OPTIMIZATIONS are enabled.  For more information about\n * the JSDoc types supported by the Closure Compiler:\n *\n *      https://developers.google.com/closure/compiler/docs/js-for-compiler#types\n *\n * I also attempted to validate this code with JSLint, but it complained too much; eg, it didn't like\n * \"while (true)\", a tried and \"true\" programming convention for decades, and it wanted me to replace\n * all \"++\" and \"--\" operators with \"+= 1\" and \"-= 1\", use \"(s || '')\" instead of \"(s? s : '')\", etc.\n *\n * I prefer sticking with traditional C-style idioms, in part because they are more portable.  That\n * does NOT mean I'm trying to write \"portable JavaScript,\" but some of this code was ported from C code\n * I'd written long ago, so portability is good, and I'm not going to throw that away if there's no need.\n *\n * UPDATE: I've since switched from JSLint to JSHint, which seems to have more reasonable defaults.\n * And for new code, I have adopted some popular JavaScript idioms, like \"(s || '')\", although the need\n * for those kinds of expressions will be reduced as I also start adopting some ES6 features, like\n * default parameters.\n */\n\n\n\n/**\n * Since the Closure Compiler treats ES6 classes as @struct rather than @dict by default,\n * it deters us from defining named properties on our components; eg:\n *\n *      this['exports'] = {...}\n *\n * results in an error:\n *\n *      Cannot do '[]' access on a struct\n *\n * So, in order to define 'exports', we must override the @struct assumption by annotating\n * the class as @unrestricted (or @dict).  Note that this must be done both here and in the\n * subclass (eg, SerialPort), because otherwise the Compiler won't allow us to *reference*\n * the named property either.\n *\n * TODO: Consider marking ALL our classes unrestricted, because otherwise it forces us to\n * define every single property the class uses in its constructor, which results in a fair\n * bit of redundant initialization, since many properties aren't (and don't need to be) fully\n * initialized until the appropriate init(), reset(), restore(), etc. function is called.\n *\n * The upside, however, may be that since the structure of the class is completely defined by\n * the constructor, JavaScript engines may be able to optimize and run more efficiently.\n *\n * @unrestricted\n */\nclass Component {\n    /**\n     * Component(type, parms, bitsMessage)\n     *\n     * A Component object requires:\n     *\n     *      type: a user-defined type name (eg, \"CPU\")\n     *\n     * and accepts any or all of the following (parms) properties:\n     *\n     *      id: component ID (default is \"\")\n     *      name: component name (default is \"\"; if blank, toString() will use the type name only)\n     *      comment: component comment string (default is undefined)\n     *\n     * Component subclasses will usually have additional (parms) properties.\n     *\n     * @param {string} type\n     * @param {Object} [parms]\n     * @param {number} [bitsMessage] selects message(s) that the component wants to enable (default is 0)\n     */\n    constructor(type, parms, bitsMessage)\n    {\n        this.type = type;\n\n        if (!parms) parms = {'id': \"\", 'name': \"\"};\n\n        this.id = parms['id'] || \"\";\n        this.name = parms['name'];\n        this.comment = parms['comment'];\n        this.parms = parms;\n\n        /*\n         * The following Component properties need to be accessible by other machines and/or command scripts;\n         * well, OK, or we could have exported some new functions to walk the contents of these properties, as we\n         * did with findMachineComponent(), but this works just as well.\n         *\n         * Also, while the double-assignment looks silly (ie, using both dot and bracket property notation), it\n         * resolves a complaint from the Closure Compiler, because if we use ONLY bracket notation here, then the\n         * Compiler wants us to change all the other references to bracket notation as well.\n         */\n        this.exports = this['exports'] = {};\n        this.bindings = this['bindings'] = {};\n\n        var i = this.id.indexOf('.');\n        if (i < 0) {\n            this.idComponent = this.id;\n        } else {\n            this.idMachine = this.id.substr(0, i);\n            this.idComponent = this.id.substr(i + 1);\n        }\n\n        /*\n         * Gather all the various component flags (booleans) into a single \"flags\" object, and encourage\n         * subclasses to do the same, to reduce the property clutter we have to wade through while debugging.\n         */\n        this.flags = {\n            ready:      false,\n            busy:       false,\n            busyCancel: false,\n            initDone:   false,\n            powered:    false,\n            unloading:  false,\n            error:      false\n        };\n\n        this.fnReady = null;\n        this.clearError();\n        this.bitsMessage = bitsMessage || 0;\n\n        this.cmp = null;\n        this.bus = null;\n        this.cpu = null;\n        this.dbg = null;\n\n        /*\n         * TODO: Consider adding another parameter to the Component() constructor that allows components to tell\n         * us if they support single or multiple instances per machine.  For example, there can be multiple SerialPort\n         * components per machine, but only one CPU component (some machines also support an FPU, but that component\n         * is considered separate from the CPU).\n         *\n         * It's not critical, but it would help catch machine configuration errors; for example, a machine that mistakenly\n         * includes two CPU components may, aside from wasting memory, end up with odd side-effects, like unresponsive\n         * CPU controls.\n         */\n        Component.add(this);\n    }\n\n    /**\n     * Component.add(component)\n     *\n     * @param {Component} component\n     */\n    static add(component)\n    {\n        /*\n         * This just generates a lot of useless noise, handy in the early days, not so much these days....\n         *\n         *      if (DEBUG) Component.log(\"Component.add(\" + component.type + \",\" + component.id + \")\");\n         */\n        Component.components.push(component);\n    }\n\n    /**\n     * Component.addMachine(idMachine)\n     *\n     * @param {string} idMachine\n     */\n    static addMachine(idMachine)\n    {\n        Component.machines[idMachine] = {};\n    }\n\n    /**\n     * Component.addMachineResource(idMachine, sName, data)\n     *\n     * @param {string} idMachine\n     * @param {string|null} sName (name of the resource)\n     * @param {*} data\n     */\n    static addMachineResource(idMachine, sName, data)\n    {\n        /*\n         * I used to assert(Component.machines[idMachine]), but when we're running as a Node app, embed.js is not used,\n         * so addMachine() is never called, so resources do not need to be recorded.\n         */\n        if (Component.machines[idMachine] && sName) {\n            Component.machines[idMachine][sName] = data;\n        }\n    }\n\n    /**\n     * Component.getMachineResources(idMachine)\n     *\n     * @param {string} idMachine\n     * @return {Object|undefined}\n     */\n    static getMachineResources(idMachine)\n    {\n        return Component.machines[idMachine];\n    }\n\n    /**\n     * Component.getTime()\n     *\n     * @return {number} the current time, in milliseconds\n     */\n    static getTime()\n    {\n        return Date.now() || +new Date();\n    }\n\n    /**\n     * Component.log(s, type)\n     *\n     * For diagnostic output only.\n     *\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     */\n    static log(s, type)\n    {\n        if (!COMPILED) {\n            if (s) {\n                var sElapsed = \"\", sMsg = (type? (type + \": \") : \"\") + s;\n                if (typeof Usr != \"undefined\") {\n                    if (Component.msStart === undefined) {\n                        Component.msStart = Component.getTime();\n                    }\n                    sElapsed = (Component.getTime() - Component.msStart) + \"ms: \";\n                }\n                sMsg = sMsg.replace(/\\r/g, '\\\\r').replace(/\\n/g, ' ');\n                if (window && window.console) console.log(sElapsed + sMsg);\n            }\n        }\n    }\n\n    /**\n     * Component.assert(f, s)\n     *\n     * Verifies conditions that must be true (for DEBUG builds only).\n     *\n     * The Closure Compiler should automatically remove all references to Component.assert() in non-DEBUG builds.\n     * TODO: Add a task to the build process that \"asserts\" there are no instances of \"assertion failure\" in RELEASE builds.\n     *\n     * @param {boolean} f is the expression we are asserting to be true\n     * @param {string} [s] is description of the assertion on failure\n     */\n    static assert(f, s)\n    {\n        if (DEBUG) {\n            if (!f) {\n                if (!s) s = \"assertion failure\";\n                Component.log(s);\n                throw new Error(s);\n            }\n        }\n    }\n\n    /**\n     * Component.print(s)\n     *\n     * Components that inherit from this class should use this.print(), rather than Component.print(), because\n     * if a Control Panel is loaded, it will override only the instance method, not the class method (overriding the\n     * class method would improperly affect any other machines loaded on the same page).\n     *\n     * @this {Component}\n     * @param {string} s\n     */\n    static print(s)\n    {\n        if (!COMPILED) {\n            var i = s.lastIndexOf('\\n');\n            if (i >= 0) {\n                Component.println(s.substr(0, i));\n                s = s.substr(i + 1);\n            }\n            Component.printBuffer += s;\n        }\n    }\n\n    /**\n     * Component.println(s, type, id)\n     *\n     * Components that inherit from this class should use this.println(), rather than Component.println(), because\n     * if a Control Panel is loaded, it will override only the instance method, not the class method (overriding the\n     * class method would improperly affect any other machines loaded on the same page).\n     *\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     * @param {string} [id] is the caller's ID, if any\n     */\n    static println(s, type, id)\n    {\n        if (!COMPILED) {\n            s = Component.printBuffer + (s || \"\");\n            Component.log((id? (id + \": \") : \"\") + (s? (\"\\\"\" + s + \"\\\"\") : \"\"), type);\n            Component.printBuffer = \"\";\n        }\n    }\n\n    /**\n     * Component.notice(s, fPrintOnly, id)\n     *\n     * notice() is like println() but implies a need for user notification, so we alert() as well.\n     *\n     * @param {string} s is the message text\n     * @param {boolean} [fPrintOnly]\n     * @param {string} [id] is the caller's ID, if any\n     * @return {boolean}\n     */\n    static notice(s, fPrintOnly, id)\n    {\n        if (!COMPILED) {\n            Component.println(s, Component.PRINT.NOTICE, id);\n        }\n        if (!fPrintOnly) Component.alertUser((id? (id + \": \") : \"\") + s);\n        return true;\n    }\n\n    /**\n     * Component.warning(s)\n     *\n     * @param {string} s describes the warning\n     */\n    static warning(s)\n    {\n        if (!COMPILED) {\n            Component.println(s, Component.PRINT.WARNING);\n        }\n        Component.alertUser(s);\n    }\n\n    /**\n     * Component.error(s)\n     *\n     * @param {string} s describes the error; an alert() is displayed as well\n     */\n    static error(s)\n    {\n        if (!COMPILED) {\n            Component.println(s, Component.PRINT.ERROR);\n        }\n        Component.alertUser(s);\n    }\n\n    /**\n     * Component.alertUser(sMessage)\n     *\n     * @param {string} sMessage\n     */\n    static alertUser(sMessage)\n    {\n        if (window) {\n            window.alert(sMessage);\n        } else {\n            Component.log(sMessage);\n        }\n    }\n\n    /**\n     * Component.confirmUser(sPrompt)\n     *\n     * @param {string} sPrompt\n     * @returns {boolean} true if the user clicked OK, false if Cancel/Close\n     */\n    static confirmUser(sPrompt)\n    {\n        var fResponse = false;\n        if (window) {\n            fResponse = window.confirm(sPrompt);\n        }\n        return fResponse;\n    }\n\n    /**\n     * Component.promptUser()\n     *\n     * @param {string} sPrompt\n     * @param {string} [sDefault]\n     * @returns {string|null}\n     */\n    static promptUser(sPrompt, sDefault)\n    {\n        var sResponse = null;\n        if (window) {\n            sResponse = window.prompt(sPrompt, sDefault === undefined? \"\" : sDefault);\n        }\n        return sResponse;\n    }\n\n    /**\n     * Component.appendControl(control, sText)\n     *\n     * @param {Object} control\n     * @param {string} sText\n     */\n    static appendControl(control, sText)\n    {\n        control.value += sText;\n        /*\n         * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.\n         */\n        if (COMPILED) {\n            sText = control.value;\n            if (sText.length > 8192) control.value = sText.substr(sText.length - 4096);\n        }\n        control.scrollTop = control.scrollHeight;\n    }\n\n    /**\n     * Component.replaceControl(control, sSearch, sReplace)\n     *\n     * @param {Object} control\n     * @param {string} sSearch\n     * @param {string} sReplace\n     */\n    static replaceControl(control, sSearch, sReplace)\n    {\n        var sText = control.value;\n        var i = sText.lastIndexOf(sSearch);\n        if (i < 0) {\n            sText += sSearch + '\\n';\n        } else {\n            sText = sText.substr(0, i) + sReplace + sText.substr(i + sSearch.length);\n        }\n        /*\n         * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.\n         */\n        if (COMPILED && sText.length > 8192) sText = sText.substr(sText.length - 4096);\n        control.value = sText;\n        control.scrollTop = control.scrollHeight;\n    }\n\n    /**\n     * Component.bindExternalControl(component, sBinding, sType)\n     *\n     * @param {Component} component\n     * @param {string} sBinding\n     * @param {string} [sType] is the external component type (default is \"Panel\")\n     */\n    static bindExternalControl(component, sBinding, sType = \"Panel\")\n    {\n        if (sBinding) {\n            var target = Component.getComponentByType(sType, component.id);\n            if (target) {\n                var control = target.bindings[sBinding];\n                if (control) {\n                    component.setBinding(\"\", sBinding, control);\n                }\n            }\n        }\n    }\n\n    /**\n     * Component.bindComponentControls(component, element, sAppClass)\n     *\n     * @param {Component} component\n     * @param {HTMLElement} element from the DOM\n     * @param {string} sAppClass\n     */\n    static bindComponentControls(component, element, sAppClass)\n    {\n        var aeControls = Component.getElementsByClass(element.parentNode, sAppClass + \"-control\");\n\n        for (var iControl = 0; iControl < aeControls.length; iControl++) {\n\n            var aeChildNodes = aeControls[iControl].childNodes;\n\n            for (var iNode = 0; iNode < aeChildNodes.length; iNode++) {\n                var control = aeChildNodes[iNode];\n                if (control.nodeType !== 1 /* document.ELEMENT_NODE */) {\n                    continue;\n                }\n                var sClass = control.getAttribute(\"class\");\n                if (!sClass) continue;\n                var aClasses = sClass.split(\" \");\n                for (var iClass = 0; iClass < aClasses.length; iClass++) {\n                    var parms;\n                    sClass = aClasses[iClass];\n                    switch (sClass) {\n                        case sAppClass + \"-binding\":\n                            parms = Component.getComponentParms(/** @type {HTMLElement} */(control));\n                            if (parms && parms['binding'] !== undefined) {\n                                component.setBinding(parms['type'], parms['binding'], /** @type {HTMLElement} */(control), parms['value']);\n                            } else if (!parms || parms['type'] != \"description\") {\n                                Component.log(\"Component '\" + component.toString() + \"' missing binding\" + (parms? \" for \" + parms['type'] : \"\"), \"warning\");\n                            }\n                            iClass = aClasses.length;\n                            break;\n                        default:\n                            // if (DEBUG) Component.log(\"Component.bindComponentControls(\" + component.toString() + \"): unrecognized control class \\\"\" + sClass + \"\\\"\", \"warning\");\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Component.getComponents(idRelated)\n     *\n     * We could store components as properties, using the component's ID, and change\n     * this linear lookup into a property lookup, but some components may have no ID.\n     *\n     * @param {string} [idRelated] of related component\n     * @return {Array} of components\n     */\n    static getComponents(idRelated)\n    {\n        var i;\n        var aComponents = [];\n        /*\n         * getComponentByID(id, idRelated)\n         *\n         * If idRelated is provided, we check it for a machine prefix, and use any\n         * existing prefix to constrain matches to IDs with the same prefix, in order to\n         * avoid matching components belonging to other machines.\n         */\n        if (idRelated) {\n            if ((i = idRelated.indexOf('.')) > 0)\n                idRelated = idRelated.substr(0, i + 1);\n            else\n                idRelated = \"\";\n        }\n        for (i = 0; i < Component.components.length; i++) {\n            var component = Component.components[i];\n            if (!idRelated || !component.id.indexOf(idRelated)) {\n                aComponents.push(component);\n            }\n        }\n        return aComponents;\n    }\n\n    /**\n     * Component.getComponentByID(id, idRelated)\n     *\n     * We could store components as properties, using the component's ID, and change\n     * this linear lookup into a property lookup, but some components may have no ID.\n     *\n     * @param {string} id of the desired component\n     * @param {string} [idRelated] of related component\n     * @return {Component|null}\n     */\n    static getComponentByID(id, idRelated)\n    {\n        if (id !== undefined) {\n            var i;\n            /*\n             * If idRelated is provided, we check it for a machine prefix, and use any\n             * existing prefix to constrain matches to IDs with the same prefix, in order to\n             * avoid matching components belonging to other machines.\n             */\n            if (idRelated && (i = idRelated.indexOf('.')) > 0) {\n                id = idRelated.substr(0, i + 1) + id;\n            }\n            for (i = 0; i < Component.components.length; i++) {\n                if (Component.components[i].id === id) {\n                    return Component.components[i];\n                }\n            }\n            if (Component.components.length) {\n                Component.log(\"Component ID '\" + id + \"' not found\", \"warning\");\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Component.getComponentByType(sType, idRelated, componentPrev)\n     *\n     * @param {string} sType of the desired component\n     * @param {string} [idRelated] of related component\n     * @param {Component|null} [componentPrev] of previously returned component, if any\n     * @return {Component|null}\n     */\n    static getComponentByType(sType, idRelated, componentPrev)\n    {\n        if (sType !== undefined) {\n            var i;\n            /*\n             * If idRelated is provided, we check it for a machine prefix, and use any\n             * existing prefix to constrain matches to IDs with the same prefix, in order to\n             * avoid matching components belonging to other machines.\n             */\n            if (idRelated) {\n                if ((i = idRelated.indexOf('.')) > 0) {\n                    idRelated = idRelated.substr(0, i + 1);\n                } else {\n                    idRelated = \"\";\n                }\n            }\n            for (i = 0; i < Component.components.length; i++) {\n                if (componentPrev) {\n                    if (componentPrev == Component.components[i]) componentPrev = null;\n                    continue;\n                }\n                if (sType == Component.components[i].type && (!idRelated || !Component.components[i].id.indexOf(idRelated))) {\n                    return Component.components[i];\n                }\n            }\n            Component.log(\"Component type '\" + sType + \"' not found\", \"warning\");\n        }\n        return null;\n    }\n\n    /**\n     * Component.getComponentParms(element)\n     *\n     * @param {HTMLElement} element from the DOM\n     */\n    static getComponentParms(element)\n    {\n        var parms = null;\n        var sParms = element.getAttribute(\"data-value\");\n        if (sParms) {\n            try {\n                parms = eval('(' + sParms + ')');   // jshint ignore:line\n                /*\n                 * We can no longer invoke removeAttribute() because some components (eg, Panel) need\n                 * to run their initXXX() code more than once, to avoid initialization-order dependencies.\n                 *\n                 *      if (!DEBUG) {\n                 *          element.removeAttribute(\"data-value\");\n                 *      }\n                 */\n            } catch(e) {\n                Component.error(e.message + \" (\" + sParms + \")\");\n            }\n        }\n        return parms;\n    }\n\n    /**\n     * Component.getElementsByClass(element, sClass, sObjClass)\n     *\n     * This is a cross-browser helper function, since not all browser's support getElementsByClassName()\n     *\n     * TODO: This should probably be moved into weblib.js at some point, along with the control binding functions above,\n     * to keep all the browser-related code together.\n     *\n     * @param {HTMLDocument|HTMLElement|Node} element from the DOM\n     * @param {string} sClass\n     * @param {string} [sObjClass]\n     * @return {Array|NodeList}\n     */\n    static getElementsByClass(element, sClass, sObjClass)\n    {\n        if (sObjClass) sClass += '-' + sObjClass + \"-object\";\n        /*\n         * Use the browser's built-in getElementsByClassName() if it appears to be available\n         * (for example, it's not available in IE8, but it should be available in IE9 and up)\n         */\n        if (element.getElementsByClassName) {\n            return element.getElementsByClassName(sClass);\n        }\n        var i, j, ae = [];\n        var aeAll = element.getElementsByTagName(\"*\");\n        var re = new RegExp('(^| )' + sClass + '( |$)');\n        for (i = 0, j = aeAll.length; i < j; i++) {\n            if (re.test(aeAll[i].className)) {\n                ae.push(aeAll[i]);\n            }\n        }\n        if (!ae.length) {\n            Component.log('No elements of class \"' + sClass + '\" found');\n        }\n        return ae;\n    }\n\n    /**\n     * Component.getScriptCommands(sScript)\n     *\n     * This is a simple parser that breaks sScript into an array of commands, where each command\n     * is an array of tokens, where tokens are sequences of characters separated by any of: tab, space,\n     * carriage-return (CR), line-feed (LF), semicolon, single-quote, or double-quote; if a quote is\n     * used, all characters up to the next matching quote become part of the token, allowing any of the\n     * other separators to be part of the token.  CR, LF and semicolon also serve to terminate a command,\n     * with semicolon being preferred, because it's 1) more visible, and 2) essential when the entire\n     * script is a multi-line string where all CR/LF were replaced by spaces (which is what Jekyll does,\n     * and since we can't change Jekyll, it's what our own MarkDown Front Matter parser does as well;\n     * see convertMD() in markout.js, where the aCommandDefs array is built).\n     *\n     * Backslash sequences like \\n, \\r, and \\\\ have already been converted to LF, CR and backslash\n     * characters, since the entire script string is injected into a JavaScript function call, so any\n     * backslash sequence that JavaScript supports is automatically converted:\n     *\n     *      \\0  \\'  \\\"  \\\\  \\n  \\r  \\v  \\t  \\b  \\f  \\uXXXX \\xXX\n     *                      ^J  ^M  ^K  ^I  ^H  ^L\n     *\n     * To support any other non-printable 8-bit character, such as ESC, you should use \\xXX, where XX\n     * is the ASCII code in hex.  For ESC, that would be \\x1B.\n     *\n     * @param {string} sScript\n     * @return {Array}\n     */\n    static getScriptCommands(sScript)\n    {\n        var cch = sScript.length;\n        var aCommands = [], aTokens = [], sToken = \"\", chQuote = null;\n        for (var i = 0; i < cch; i++) {\n            var ch = sScript[i];\n            if (ch == '\"' || ch == \"'\") {\n                if (chQuote && ch != chQuote) {\n                    sToken += ch;\n                    continue;\n                }\n                if (!chQuote) {\n                    chQuote = ch;\n                } else {\n                    chQuote = null;\n                }\n                if (sToken) {\n                    aTokens.push(sToken);\n                    sToken = \"\";\n                }\n                continue;\n            }\n            if (!chQuote) {\n                if (ch == '\\r' || ch == '\\n') {\n                    ch = ';';\n                }\n                if (ch == ' ' || ch == '\\t' || ch == ';') {\n                    if (sToken) {\n                        aTokens.push(sToken);\n                        sToken = \"\";\n                    }\n                    if (ch == ';' && aTokens.length) {\n                        aCommands.push(aTokens);\n                        aTokens = [];\n                    }\n                    continue;\n                }\n            }\n            sToken += ch;\n        }\n        if (sToken) {\n            aTokens.push(sToken);\n        }\n        if (aTokens.length) {\n            aCommands.push(aTokens);\n        }\n        return aCommands;\n    }\n\n    /**\n     * Component.processScript(idMachine, sScript)\n     *\n     * @param {string} idMachine\n     * @param {string} [sScript]\n     * @return {boolean}\n     */\n    static processScript(idMachine, sScript)\n    {\n        var fSuccess = false;\n        idMachine += \".machine\";\n        if (!sScript) {\n            delete Component.commands[idMachine];\n            fSuccess = true;\n        }\n        else if (typeof sScript == \"string\" && !Component.commands[idMachine]) {\n            fSuccess = true;\n            Component.commands[idMachine] = Component.getScriptCommands(sScript);\n            if (!Component.processCommands(idMachine)) {\n                fSuccess = false;\n            }\n        }\n        return fSuccess;\n    }\n\n    /**\n     * Component.processCommands(idMachine)\n     *\n     * @param {string} idMachine\n     * @return {boolean}\n     */\n    static processCommands(idMachine)\n    {\n        var fSuccess = true;\n        var aCommands = Component.commands[idMachine];\n\n     // var dbg = Component.getComponentByType(\"Debugger\", idMachine);\n\n        while (aCommands && aCommands.length) {\n\n            var aTokens = aCommands.splice(0, 1)[0];\n            var sCommand = aTokens[0];\n\n            /*\n             * It's possible to route this output to the Debugger window with dbg.println()\n             * instead, but it's a bit too confusing mingling script output in a window that\n             * already mingles Debugger and machine output.\n             */\n            Component.println(aTokens.join(' '), Component.PRINT.SCRIPT);\n\n            var fnCallReady = null;\n            if (Component.asyncCommands.indexOf(sCommand) >= 0) {\n                fnCallReady = function processNextCommand() {\n                    return function() {\n                        Component.processCommands(idMachine);\n                    }\n                }();\n            }\n\n            var fnCommand = Component.globalCommands[sCommand];\n            if (fnCommand) {\n                if (!fnCallReady) {\n                    fSuccess = fnCommand(aTokens[1], aTokens[2], aTokens[3]);\n                } else {\n                    if (!fnCommand(fnCallReady, aTokens[1], aTokens[2], aTokens[3])) break;\n                }\n            }\n            else {\n                fSuccess = false;\n                var component = Component.getComponentByType(aTokens[1], idMachine);\n                if (component) {\n                    fnCommand = Component.componentCommands[sCommand];\n                    if (fnCommand) {\n                        fSuccess = fnCommand(component, aTokens[2], aTokens[3]);\n                    }\n                    else {\n                        var exports = component['exports'];\n                        if (exports) {\n                            fnCommand = exports[sCommand];\n                            if (fnCommand) {\n                                fSuccess = true;\n                                if (!fnCallReady) {\n                                    fSuccess = fnCommand.call(component, aTokens[2], aTokens[3]);\n                                } else {\n                                    if (!fnCommand.call(component, fnCallReady, aTokens[2], aTokens[3])) break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!fSuccess) {\n                Component.alertUser(\"Script error: '\" + sCommand + \"' command \" + (fnCommand? \" failed\" : \" not recognized\"));\n                break;\n            }\n        }\n\n        if (aCommands && !aCommands.length) {\n            delete Component.commands[idMachine];\n        }\n\n        return fSuccess;\n    }\n\n    /**\n     * Component.scriptAlert(sMessage)\n     *\n     * @param {string} sMessage\n     * @return {boolean}\n     */\n    static scriptAlert(sMessage)\n    {\n        Component.alertUser(sMessage);\n        return true;\n    }\n\n    /**\n     * Component.scriptSelect(component, sBinding, sValue)\n     *\n     * @param {Component} component\n     * @param {string} sBinding\n     * @param {string} sValue\n     * @return {boolean}\n     */\n    static scriptSelect(component, sBinding, sValue)\n    {\n        var fSuccess = false;\n        var aBindings = component['bindings'];\n        var control = aBindings[sBinding];\n        if (control) {\n            for (var i = 0; i < control.options.length; i++) {\n                if (control.options[i].textContent == sValue) {\n                    if (control.selectedIndex != i) {\n                        control.selectedIndex = i;\n                    }\n                    fSuccess = true;\n                    break;\n                }\n            }\n        }\n        return fSuccess;\n    }\n\n    /**\n     * Component.scriptSleep(fnCallback, sDelay)\n     *\n     * @param {function()} fnCallback\n     * @param {string} sDelay (in milliseconds)\n     * @return {boolean}\n     */\n    static scriptSleep(fnCallback, sDelay)\n    {\n        setTimeout(fnCallback, +sDelay);\n        return false;\n    }\n\n    /**\n     * toString()\n     *\n     * @this {Component}\n     * @return {string}\n     */\n    toString()\n    {\n        return (this.name? this.name : (this.id || this.type));\n    }\n\n    /**\n     * getMachineNum()\n     *\n     * @this {Component}\n     * @return {number} unique machine number\n     */\n    getMachineNum()\n    {\n        var nMachine = 1;\n        if (this.idMachine) {\n            var aDigits = this.idMachine.match(/\\d+/);\n            if (aDigits !== null)\n                nMachine = parseInt(aDigits[0], 10);\n        }\n        return nMachine;\n    }\n\n    /**\n     * setBinding(sHTMLType, sBinding, control, sValue)\n     *\n     * Component's setBinding() method is intended to be overridden by subclasses.\n     *\n     * @this {Component}\n     * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\", \"canvas\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, 'print')\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        switch (sBinding) {\n        case 'clear':\n            if (!this.bindings[sBinding]) {\n                this.bindings[sBinding] = control;\n                control.onclick = (function(component) {\n                    return function clearControl() {\n                        if (component.bindings['print']) {\n                            component.bindings['print'].value = \"\";\n                        }\n                    };\n                }(this));\n            }\n            return true;\n        case 'print':\n            if (!this.bindings[sBinding]) {\n                var controlTextArea = /** @type {HTMLTextAreaElement} */(control);\n                this.bindings[sBinding] = controlTextArea;\n                /**\n                 * Override this.notice() with a replacement function that eliminates the Component.alertUser() call.\n                 *\n                 * @this {Component}\n                 * @param {string} s\n                 * @return {boolean}\n                 */\n                this.notice = function noticeControl(s /*, fPrintOnly, id*/) {\n                    this.println(s, this.type);\n                    return true;\n                };\n                /*\n                 * This was added for Firefox (Safari will clear the <textarea> on a page reload, but Firefox does not).\n                 */\n                controlTextArea.value = \"\";\n                this.print = function(control) {\n                    return function printControl(s) {\n                        Component.appendControl(control, s);\n                    };\n                }(controlTextArea);\n                this.println = function(component, control) {\n                    return function printlnControl(s, type, id) {\n                        if (!s) s = \"\";\n                        if (type != Component.PRINT.PROGRESS || s.slice(-3) != \"...\") {\n                            if (type) s = type + \": \" + s;\n                            Component.appendControl(control, s + '\\n');\n                        } else {\n                            Component.replaceControl(control, s, s + '.');\n                        }\n                        if (!COMPILED && window && window.console) Component.println(s, type, id);\n                    };\n                }(this, controlTextArea);\n            }\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    /**\n     * log(s, type)\n     *\n     * For diagnostic output only.\n     *\n     * WARNING: Even though this function's body is completely wrapped in DEBUG, that won't prevent the Closure Compiler\n     * from including it, so all calls must still be prefixed with \"if (DEBUG) ....\".  For this reason, the class method,\n     * Component.log(), is preferred, because the compiler IS smart enough to remove those calls.\n     *\n     * @this {Component}\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     */\n    log(s, type)\n    {\n        if (!COMPILED) {\n            Component.log(s, type || this.id || this.type);\n        }\n    }\n\n    /**\n     * assert(f, s)\n     *\n     * Verifies conditions that must be true (for DEBUG builds only).\n     *\n     * WARNING: Make sure you preface all calls to this.assert() with \"if (DEBUG)\", because unlike Component.assert(),\n     * the Closure Compiler can't be sure that this instance method hasn't been overridden, so it refuses to treat it as\n     * dead code in non-DEBUG builds.\n     *\n     * TODO: Add a task to the build process that \"asserts\" there are no instances of \"assertion failure\" in RELEASE builds.\n     *\n     * @this {Component}\n     * @param {boolean|number} f is the expression asserted to be true\n     * @param {string} [s] is a description of the assertion to be displayed or logged on failure\n     */\n    assert(f, s)\n    {\n        if (DEBUG) {\n            if (!f) {\n                s = \"assertion failure in \" + (this.id || this.type) + (s? \": \" + s : \"\");\n                if (DEBUGGER && this.dbg) {\n                    this.dbg.stopCPU();\n                    /*\n                     * Why do we throw an Error only to immediately catch and ignore it?  Simply to give\n                     * any IDE the opportunity to inspect the application's state.  Even when the IDE has\n                     * control, you should still be able to invoke Debugger commands from the IDE's REPL,\n                     * using the global function that the Debugger constructor defines; eg:\n                     *\n                     *      pcx86('r')\n                     *      pcx86('dw 0:0')\n                     *      pcx86('h')\n                     *      ...\n                     *\n                     * If you have no desire to stop on assertions, consider this a no-op.  However, another\n                     * potential benefit of creating an Error object is that, for browsers like Chrome, we get\n                     * a stack trace, too.\n                     */\n                    try {\n                        throw new Error(s);\n                    } catch(e) {\n                        this.println(e.stack || e.message);\n                    }\n                    return;\n                }\n                this.log(s);\n                throw new Error(s);\n            }\n        }\n    }\n\n    /**\n     * print(s)\n     *\n     * Components using this.print() should wait until after their constructor has run to display any messages, because\n     * if a Control Panel has been loaded, its override will not take effect until its own constructor has run.\n     *\n     * @this {Component}\n     * @param {string} s\n     */\n    print(s)\n    {\n        Component.print(s);\n    }\n\n    /**\n     * println(s, type, id)\n     *\n     * Components using this.println() should wait until after their constructor has run to display any messages, because\n     * if a Control Panel has been loaded, its override will not take effect until its own constructor has run.\n     *\n     * @this {Component}\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     * @param {string} [id] is the caller's ID, if any\n     */\n    println(s, type, id)\n    {\n        Component.println(s, type, id || this.id);\n    }\n\n    /**\n     * status(s)\n     *\n     * status() is like println() but it also includes information about the component (ie, the component type),\n     * which is why there is no corresponding Component.status() function.\n     *\n     * @this {Component}\n     * @param {string} s is the message text\n     */\n    status(s)\n    {\n        this.println(this.type + \": \" + s);\n    }\n\n    /**\n     * notice(s, fPrintOnly, id)\n     *\n     * notice() is like println() but implies a need for user notification, so we alert() as well; however, if this.println()\n     * is overridden, this.notice will be replaced with a similar override, on the assumption that the override is taking care\n     * of alerting the user.\n     *\n     * @this {Component}\n     * @param {string} s is the message text\n     * @param {boolean} [fPrintOnly]\n     * @param {string} [id] is the caller's ID, if any\n     * @return {boolean}\n     */\n    notice(s, fPrintOnly, id)\n    {\n        if (!fPrintOnly) {\n            /*\n             * See if the associated computer, if any, is \"unloading\"....\n             */\n            var computer = Component.getComponentByType(\"Computer\", this.id);\n            if (computer && computer.flags.unloading) {\n                console.log(\"ignoring notice during unload: \" + s);\n                return false;\n            }\n        }\n        Component.notice(s, fPrintOnly, id || this.type);\n        return true;\n    }\n\n    /**\n     * setError(s)\n     *\n     * Set a fatal error condition\n     *\n     * @this {Component}\n     * @param {string} s describes a fatal error condition\n     */\n    setError(s)\n    {\n        this.flags.error = true;\n        this.notice(s);         // TODO: Any cases where we should still prefix this string with \"Fatal error: \"?\n    }\n\n    /**\n     * clearError()\n     *\n     * Clear any fatal error condition\n     *\n     * @this {Component}\n     */\n    clearError() {\n        this.flags.error = false;\n    }\n\n    /**\n     * isError()\n     *\n     * Report any fatal error condition\n     *\n     * @this {Component}\n     * @return {boolean} true if a fatal error condition exists, false if not\n     */\n    isError()\n    {\n        if (this.flags.error) {\n            this.println(this.toString() + \" error\");\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * isReady(fnReady)\n     *\n     * Return the \"ready\" state of the component; if the component is not ready, it will queue the optional\n     * notification function, otherwise it will immediately call the notification function, if any, without queuing it.\n     *\n     * NOTE: Since only the Computer component actually cares about the \"readiness\" of other components, the so-called\n     * \"queue\" of notification functions supports exactly one function.  This keeps things nice and simple.\n     *\n     * @this {Component}\n     * @param {function()} [fnReady]\n     * @return {boolean} true if the component is in a \"ready\" state, false if not\n     */\n    isReady(fnReady)\n    {\n        if (fnReady) {\n            if (this.flags.ready) {\n                fnReady();\n            } else {\n                if (MAXDEBUG) this.log(\"NOT ready\");\n                this.fnReady = fnReady;\n            }\n        }\n        return this.flags.ready;\n    }\n\n    /**\n     * setReady(fReady)\n     *\n     * Set the \"ready\" state of the component to true, and call any queued notification functions.\n     *\n     * @this {Component}\n     * @param {boolean} [fReady] is assumed to indicate \"ready\" unless EXPLICITLY set to false\n     */\n    setReady(fReady)\n    {\n        if (!this.flags.error) {\n            this.flags.ready = (fReady !== false);\n            if (this.flags.ready) {\n                if (MAXDEBUG /* || this.name */) this.log(\"ready\");\n                var fnReady = this.fnReady;\n                this.fnReady = null;\n                if (fnReady) fnReady();\n            }\n        }\n    }\n\n    /**\n     * isBusy(fCancel)\n     *\n     * Return the \"busy\" state of the component\n     *\n     * @this {Component}\n     * @param {boolean} [fCancel] is set to true to cancel a \"busy\" state\n     * @return {boolean} true if \"busy\", false if not\n     */\n    isBusy(fCancel)\n    {\n        if (this.flags.busy) {\n            if (fCancel) {\n                this.flags.busyCancel = true;\n            } else if (fCancel === undefined) {\n                this.println(this.toString() + \" busy\");\n            }\n        }\n        return this.flags.busy;\n    }\n\n    /**\n     * setBusy(fBusy)\n     *\n     * Update the current busy state; if a busyCancel request is pending, it will be honored now.\n     *\n     * @this {Component}\n     * @param {boolean} fBusy\n     * @return {boolean}\n     */\n    setBusy(fBusy)\n    {\n        if (this.flags.busyCancel) {\n            this.flags.busy = false;\n            this.flags.busyCancel = false;\n            return false;\n        }\n        if (this.flags.error) {\n            this.println(this.toString() + \" error\");\n            return false;\n        }\n        this.flags.busy = fBusy;\n        return this.flags.busy;\n    }\n\n    /**\n     * powerUp(fSave)\n     *\n     * @this {Component}\n     * @param {Object|null} data\n     * @param {boolean} [fRepower] is true if this is \"repower\" notification\n     * @return {boolean} true if successful, false if failure\n     */\n    powerUp(data, fRepower)\n    {\n        this.flags.powered = true;\n        return true;\n    }\n\n    /**\n     * powerDown(fSave, fShutdown)\n     *\n     * @this {Component}\n     * @param {boolean} fSave\n     * @param {boolean} [fShutdown]\n     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure\n     */\n    powerDown(fSave, fShutdown)\n    {\n        if (fShutdown) this.flags.powered = false;\n        return true;\n    }\n\n    /**\n     * messageEnabled(bitsMessage)\n     *\n     * If bitsMessage is not specified, the component's MESSAGE category is used.\n     *\n     * @this {Component}\n     * @param {number} [bitsMessage] is zero or more MESSAGE_* category flag(s)\n     * @return {boolean} true if all specified message enabled, false if not\n     */\n    messageEnabled(bitsMessage = 0)\n    {\n        if (DEBUGGER && this.dbg) {\n            if (this !== this.dbg) {\n                bitsMessage = bitsMessage || this.bitsMessage;\n            }\n            var bitsEnabled = this.dbg.bitsMessage & bitsMessage;\n            /*\n             * This next \"bit\" of logic is for PCx86 and any other machine where we've expanded the set of\n             * messages by reusing bits in the low nibbles in combination with different bits in the high nibble.\n             * If the input bits adhere to that format, then the mask we just produced must adhere to it as well,\n             * and if it doesn't, zero the mask, ensuring that the test will return false.\n             */\n            if ((bitsMessage & 0xf0000000) && (bitsMessage & 0x0fffffff)) {\n                if (!(bitsEnabled & 0xf0000000) || !(bitsEnabled & 0x0fffffff)) bitsEnabled = 0;\n            }\n            if (bitsMessage && bitsEnabled === bitsMessage) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * printf(format, ...args)\n     *\n     * @this {Component}\n     * @param {string} format\n     * @param {...} args\n     */\n    printf(format, ...args)\n    {\n        if (DEBUGGER && this.dbg) {\n            if (this.messageEnabled()) {\n                let s = Str.sprintf(format, ...args);\n                /*\n                 * Since dbg.message() calls println(), we strip any ending linefeed.\n                 * \n                 * We could bypass the Debugger and go straight to this.print(), but we would lose\n                 * the benefits of debugger messages (eg, automatic buffering, halting, yielding, etc).\n                 */\n                if (s.slice(-1) == '\\n') s = s.slice(0, -1);\n                this.dbg.message(s);\n            }\n        }\n    }\n\n    /**\n     * printMessage(sMessage, bitsMessage, fAddress)\n     *\n     * If bitsMessage is not specified, the component's MESSAGE category is used.\n     * If bitsMessage is true, the message is displayed regardless.\n     *\n     * @this {Component}\n     * @param {string} sMessage is any caller-defined message string\n     * @param {number|boolean} [bitsMessage] is zero or more MESSAGE_* category flag(s)\n     * @param {boolean} [fAddress] is true to display the current address\n     */\n    printMessage(sMessage, bitsMessage, fAddress)\n    {\n        if (DEBUGGER && this.dbg) {\n            if (bitsMessage === true || this.messageEnabled(bitsMessage | 0)) {\n                this.dbg.message(sMessage, fAddress);\n            }\n        }\n    }\n\n    /**\n     * printMessageIO(port, bOut, addrFrom, name, bIn, bitsMessage)\n     *\n     * If bitsMessage is not specified, the component's MESSAGE category is used.\n     * If bitsMessage is true, the message is displayed as long as MESSAGE.PORT is enabled.\n     *\n     * @this {Component}\n     * @param {number} port\n     * @param {number|null|*} bOut if an output operation\n     * @param {number|null|*} [addrFrom]\n     * @param {string|null|*} [name] of the port, if any\n     * @param {number|null|*} [bIn] is the input value, if known, on an input operation\n     * @param {number|boolean} [bitsMessage] is zero or more MESSAGE_* category flag(s)\n     */\n    printMessageIO(port, bOut, addrFrom, name, bIn, bitsMessage)\n    {\n        if (DEBUGGER && this.dbg) {\n            if (bitsMessage === true) {\n                bitsMessage = 0;\n            } else if (bitsMessage == null) {\n                bitsMessage = this.bitsMessage;\n            }\n            this.dbg.messageIO(this, port, bOut, addrFrom, name, bIn, bitsMessage);\n        }\n    }\n}\n\n/*\n * Types recognized and supported by selected functions (eg, Computer.getMachineParm())\n */\nComponent.TYPE = {\n    NUMBER:     \"number\",\n    OBJECT:     \"object\",\n    STRING:     \"string\"\n};\n\n/*\n * These are the standard PRINT values you can pass as an optional argument to println(); in reality,\n * you can pass anything you want, because they are simply prepended to the message, although PROGRESS\n * messages may also be merged with earlier similar messages to keep the output buffer under control.\n */\nComponent.PRINT = {\n    ERROR:      \"error\",\n    NOTICE:     \"notice\",\n    PROGRESS:   \"progress\",\n    SCRIPT:     \"script\",\n    WARNING:    \"warning\"\n};\n\n/*\n * Every component created on the current page is recorded in this array (see Component.add()),\n * enabling any component to locate another component by ID (see Component.getComponentByID())\n * or by type (see Component.getComponentByType()).\n *\n * Every machine on the page are now recorded as well, by their machine ID.  We then record the\n * various resources used by that machine.\n *\n * Includes a fallback for non-browser-based environments (ie, Node).  TODO: This will need to be\n * tailored to Node, probably using the global object instead of the window object, if we ever want\n * to support multi-machine configs in that environment.\n */\nif (window) {\n    if (!window['PCjs']) window['PCjs'] = {};\n    if (!window['PCjs']['Machines']) window['PCjs']['Machines'] = {};\n    if (!window['PCjs']['Components']) window['PCjs']['Components'] = [];\n    if (!window['PCjs']['Commands']) window['PCjs']['Commands'] = {};\n}\nComponent.machines = window? window['PCjs']['Machines'] : {};\nComponent.components = window? window['PCjs']['Components'] : [];\nComponent.commands = window? window['PCjs']['Commands'] : {};\n\nComponent.asyncCommands = [\n    'hold', 'sleep', 'wait'\n];\nComponent.globalCommands = {\n    'alert': Component.scriptAlert,\n    'sleep': Component.scriptSleep\n};\nComponent.componentCommands = {\n    'select':   Component.scriptSelect\n};\nComponent.printBuffer = \"\";\n\n/*\n * The following polyfills provide ES5 functionality that's missing in older browsers (eg, IE8),\n * allowing PCjs apps to run without slamming into exceptions; however, due to the lack of HTML5 canvas\n * support in those browsers, all you're likely to see are \"soft\" errors (eg, \"Missing <canvas> support\").\n *\n * Perhaps we can implement a text-only faux video display for a fun retro-browser experience someday.\n *\n * TODO: Come up with a better place to put these polyfills.  We will likely have more if we decide to\n * make the leap from ES5 to ES6 features.\n */\n\n/*\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\n */\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(obj, start) {\n        for (var i = (start || 0), j = this.length; i < j; i++) {\n            if (this[i] === obj) { return i; }\n        }\n        return -1;\n    }\n}\n\n/*\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\n */\nif (!Array.isArray) {\n    Array.isArray = function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}\n\n/*\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n */\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function(obj) {\n        if (typeof this != \"function\") {\n            // Closest thing possible to the ECMAScript 5 internal IsCallable function\n            throw new TypeError(\"Function.prototype.bind: non-callable object\");\n        }\n        var args = Array.prototype.slice.call(arguments, 1);\n        var fToBind = this;\n        var fnNOP = /** @constructor */ (function() {});\n        var fnBound = function() {\n            return fToBind.apply(this instanceof fnNOP && obj? this : obj, args.concat(/** @type {Array} */(Array.prototype.slice.call(arguments))));\n        };\n        fnNOP.prototype = this.prototype;\n        fnBound.prototype = new fnNOP();\n        return fnBound;\n    };\n}\n\n\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/defines.js (C) Jeff Parsons 2012-2018\n */\n\n/**\n * @define {string}\n */\nvar APPCLASS = \"c1pjs\";         // this @define is the default application class (eg, \"pcx86\", \"c1pjs\")\n\n/**\n * @define {string}\n */\nvar APPNAME = \"C1Pjs\";          // this @define is the default application name (eg, \"PCx86\", \"C1Pjs\")\n\n/**\n * @define {boolean}\n *\n * WARNING: DEBUGGER needs to accurately reflect whether or not the Debugger component is (or will be) loaded.\n * In the compiled case, we rely on the Closure Compiler to override DEBUGGER as appropriate.  When it's *false*,\n * nearly all of debugger.js will be conditionally removed by the compiler, reducing it to little more than a\n * \"type skeleton\", which also solves some type-related warnings we would otherwise have if we tried to remove\n * debugger.js from the compilation process altogether.\n *\n * However, when we're in \"development mode\" and running uncompiled code in debugger-less configurations,\n * I would like to skip loading debugger.js altogether.  When doing that, we must ALSO arrange for an additional file\n * (nodebugger.js) to be loaded immediately after this file, which *explicitly* overrides DEBUGGER with *false*.\n */\nvar DEBUGGER = true;            // this @define is overridden by the Closure Compiler to remove Debugger-related support\n\n/*\n * Combine all the shared globals and machine-specific globals into one machine-specific global object,\n * which all machine components should start using; eg: \"if (C1PJS.DEBUG) ...\" instead of \"if (DEBUG) ...\".\n */\nvar C1PJS = {\n    APPCLASS:    APPCLASS,\n    APPNAME:     APPNAME,\n    APPVERSION:  APPVERSION,    // shared\n    COMPILED:    COMPILED,      // shared\n    CSSCLASS:    CSSCLASS,      // shared\n    DEBUG:       DEBUG,         // shared\n    DEBUGGER:    DEBUGGER,\n    MAXDEBUG:    MAXDEBUG,      // shared\n    PRIVATE:     PRIVATE,       // shared\n    SITEHOST:    SITEHOST,      // shared\n    XMLVERSION:  XMLVERSION     // shared\n};\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/panel.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PPanel extends Component {\n    /**\n     * C1PPanel(parmsPanel)\n     *\n     * The Panel component has no required (parmsPanel) properties.\n     *\n     * @this {C1PPanel}\n     * @param {Object} parmsPanel\n     */\n    constructor(parmsPanel)\n    {\n        super(\"C1PPanel\", parmsPanel);\n\n        this.flags.powered = false;\n    }\n\n    /**\n     * The Panel doesn't have any bindings of its own; it passes along all binding requests to\n     * the Computer, CPU, Keyboard and Debugger components. The order shouldn't matter, since any\n     * component that doesn't recognize the specified binding should simply ignore it.\n     *\n     * @this {C1PPanel}\n     * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\", \"canvas\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"reset\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        if (this.cmp && this.cmp.setBinding(sHTMLType, sBinding, control, sValue)) return true;\n        if (this.cpu && this.cpu.setBinding(sHTMLType, sBinding, control, sValue)) return true;\n        if (this.kbd && this.kbd.setBinding(sHTMLType, sBinding, control, sValue)) return true;\n        if (DEBUGGER && this.dbg && this.dbg.setBinding(sHTMLType, sBinding, control, sValue)) return true;\n        return super.setBinding(sHTMLType, sBinding, control, sValue);\n    }\n\n    /**\n     * @this {C1PPanel}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            this.cmp = cmp;\n            this.cpu = cmp.getComponentByType(\"cpu\");\n            this.kbd = cmp.getComponentByType(\"keyboard\");\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n            C1PPanel.init();\n        }\n    }\n\n    /**\n     * C1PPanel.init()\n     *\n     * This function operates on every HTML element of class \"panel\", extracting the\n     * JSON-encoded parameters for the C1PPanel constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PPanel component, and then binding\n     * any associated HTML controls to the new component.\n     *\n     * NOTE: Unlike most other component init() functions, this one is designed to be\n     * called multiple times: once at load time, so that we can binding our print()\n     * function to the panel's output control ASAP, and again when the C1PComputer component\n     * is verifying that all components are ready and invoking their setPower() functions.\n     *\n     * Our setPower() method gives us a second opportunity to notify any components that\n     * that might care (eg, C1PCPU, C1PKeyboard, and C1PDebugger) that we have some controls\n     * they might want to use.\n     */\n    static init()\n    {\n        var fReady = false;\n        var aePanels = Component.getElementsByClass(document, C1PJS.APPCLASS, \"panel\");\n        for (var iPanel=0; iPanel < aePanels.length; iPanel++) {\n            var ePanel = aePanels[iPanel];\n            var parmsPanel = Component.getComponentParms(ePanel);\n            var panel = Component.getComponentByID(parmsPanel['id']);\n            if (!panel) {\n                fReady = true;\n                panel = new C1PPanel(parmsPanel);\n            }\n            Component.bindComponentControls(panel, ePanel, C1PJS.APPCLASS);\n            if (fReady) panel.setReady();\n        }\n    }\n}\n\n/*\n * Initialize every Panel module on the page.\n */\nWeb.onInit(C1PPanel.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/cpu.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PCPU extends Component {\n    /**\n     * C1PCPU(parmsCPU)\n     *\n     * The C1PCPU object has one component-specific initialization property:\n     *\n     *      autoStart: true to automatically start, false to not, or null (default)\n     *      to make the autoStart decision based on whether or not a Debugger is\n     *      installed (if there's no Debugger AND no \"Run\" button, then auto-start,\n     *      otherwise don't)\n     *\n     * It is hard-coded to simulate a 6502 microprocessor, but it also contains\n     * hooks into other components for communication with the outside world (eg,\n     * Panel and Debugger components). This is a logical simulation, not a physical\n     * simulation, and performance is important, so we take lots of liberties; any\n     * idiosyncrasies of actual 6502 hardware may not be simulated here, unless it\n     * affects the accuracy of the simulation when running actual 6502 software.\n     *\n     * @this {C1PCPU}\n     * @param {Object} parmsCPU\n     */\n    constructor(parmsCPU)\n    {\n        super(\"C1PCPU\", parmsCPU);\n\n        this.clearRegs();\n        this.flags.powered = false;\n        this.flags.running = false;\n        this.fAutoStart = parmsCPU[\"autoStart\"];\n\n        /*\n         * speed is a number from 0 to 2, where 0 means run as close to 1Mhz as possible,\n         * 1 means run at the fastest safe speed, and 2 means run at maximum speed.\n         *\n         * It's updated via the setSpeed() function, which the Debugger's \"option\" command\n         * uses to adjust the virtual speed (eg, \"o slow\", \"o fast\").  There may also\n         * be a button present to control the speed as well (using the \"setSpeed\" binding).\n         */\n        this.SPEED_SLOW = 0;        // see this.mhzSlow\n        this.SPEED_FAST = 1;        // see this.mhzFast\n        this.SPEED_MAX  = 2;\n        this.speed = this.SPEED_SLOW;\n        this.nCyclesPerSecond = 1000000;\n\n        /*\n         * Additional values that control the overall speed of the simulated hardware,\n         * and the frequency at which various updates should occur.  There are no UI\n         * mechanisms for tweaking these values (yet).\n         *\n         * NOTE: Use of the term \"second\" below refers to a virtual CPU second, consisting of\n         * 1 million simulated cycles.  The values below are used to divide those 1 million\n         * cycles into intervals of \"work\", and as long we are limiting the simulation to 1Mhz\n         * per ACTUAL second, then 1 virtual second == 1 real second.\n         *\n         * However, if the setSpeed() function is used to lift the 1Mhz limit, then 1 virtual\n         * second may become much shorter, which is why you may briefly notice the video and/or\n         * status (control panel) updates occurring more frequently. To compensate, calcCycles()\n         * will automatically scale these values if a recent speed recalculation reveals that\n         * we're running significantly faster than 1Mhz.\n         */\n        this.nYieldsPerSecond = 30;\n        this.nVideoUpdatesPerSecond = 30;\n        this.nStatusUpdatesPerSecond = 5;\n        this.mhzSlow = 1;\n        this.mhzFast = 8;\n        this.aSpeeds = [\"Slow\", \"Fast\", \"Max\"];\n        this.aSpeedDescs = [\"(\" + this.mhzSlow + \"Mhz)\", \"(up to \" + this.mhzFast + \"Mhz)\", \"(unlimited)\"];\n\n        /*\n         * Lists of notification handlers: aReadNotify and aWriteNotify are lists (ie, Arrays)\n         * of 4-element sub-arrays that, in turn, contain:\n         *\n         *      [0]: starting address of memory range to monitor\n         *      [1]: ending address of memory range to monitor (inclusive)\n         *      [2]: registered component\n         *      [3]: registered function to call for every read/write from/to memory in that range\n         *\n         * The virtual Serial Port and virtual Keyboard components use these handlers to trap\n         * references to their respective memory-based \"ports\".  Also, the ROM component uses it\n         * to \"repair\" any writes to its address range, since memory is one big array, and arrays\n         * don't support \"write-only\" regions.\n         *\n         * NOTE: the Video component does NOT use notification handlers, because video memory\n         * is written (and occasionally read) far too frequently for that to be efficient.  We\n         * just let the CPU pound on it like any other chunk of memory, and then make periodic\n         * calls directly to the Video component to refresh all portions of the video buffer\n         * that have changed since the last refresh. See displayVideo() for more details.\n         *\n         * WARNING: Write notifications currently do not catch STACK writes (ie, BRK, JSR, PHA and\n         * PHP instructions), because I simply haven't added the necessary code.  Besides, JSR is\n         * one of the most-executed instructions, so I'd rather not slow it down. Note that this\n         * STACK write limitation affects both the CPU's write-notification handlers AND the Debugger's\n         * write breakpoints.\n         */\n        this.aReadNotify = [];\n        this.aWriteNotify = [];\n\n        /*\n         * To speed up the processing of read and write notification handlers, we keep track of\n         * lower and upper address bounds for each set.  These variables maintain those bounds.\n         * They are initialized to values outside the accessible range of addresses.\n         */\n        this.addrReadLower = 0x10000;\n        this.addrReadUpper = 0x0;\n        this.addrWriteLower = 0x10000;\n        this.addrWriteUpper = 0x0;\n\n        /*\n         * Processor status register (P) flag masks\n         */\n        this.BIT_PN = 0x80;     // N = sign\n        this.BIT_PV = 0x40;     // V = overflow\n        this.BIT_PB = 0x10;     // B = break\n        this.BIT_PD = 0x08;     // D = decimal\n        this.BIT_PI = 0x04;     // I = interrupt\n        this.BIT_PZ = 0x02;     // Z = zero\n        this.BIT_PC = 0x01;     // C = carry\n\n     // this.VECTOR_NMI     = 0xfffa;\n        this.VECTOR_RESET   = 0xfffc;\n     // this.VECTOR_IRQ     = 0xfffe;\n\n        /*\n         * Popular opcodes\n         */\n        this.OP_JSR         = 0x20;\n\n        /*\n         * opSim operation codes\n         */\n        this.OP_SIM         = 0x02;\n        this.SIMOP_HLT      = 0x00;\n        this.SIMOP_MSG      = 0x01;\n\n        /*\n         * This 256-entry array of opcode functions is at the heart of the CPU engine: step(n).\n         *\n         * It might be worth trying a switch() statement instead, to see how the performance compares,\n         * but I suspect that will vary quite a bit across JavaScript engines; for now, I'm putting my\n         * money on array lookup.\n         */\n        this.aOpcodeFuncs = [\n            this.opBRK,         // 0x00\n            this.opORAindx,     // 0x01\n            this.opSim,         // 0x02\n            this.opUndefined,   // 0x03\n            this.opUndefined,   // 0x04\n            this.opORAzp,       // 0x05\n            this.opASLzp,       // 0x06\n            this.opUndefined,   // 0x07\n            this.opPHP,         // 0x08\n            this.opORAimm,      // 0x09\n            this.opASLacc,      // 0x0a\n            this.opUndefined,   // 0x0b\n            this.opUndefined,   // 0x0c\n            this.opORAabs,      // 0x0d\n            this.opASLabs,      // 0x0e\n            this.opUndefined,   // 0x0f\n            this.opBPL,         // 0x10\n            this.opORAindy,     // 0x11\n            this.opUndefined,   // 0x12\n            this.opUndefined,   // 0x13\n            this.opUndefined,   // 0x14\n            this.opORAzpx,      // 0x15\n            this.opASLzpx,      // 0x16\n            this.opUndefined,   // 0x17\n            this.opCLC,         // 0x18\n            this.opORAabsy,     // 0x19\n            this.opUndefined,   // 0x1a\n            this.opUndefined,   // 0x1b\n            this.opUndefined,   // 0x1c\n            this.opORAabsx,     // 0x1d\n            this.opASLabsx,     // 0x1e\n            this.opUndefined,   // 0x1f\n            this.opJSRabs,      // 0x20\n            this.opANDindx,     // 0x21\n            this.opUndefined,   // 0x22\n            this.opUndefined,   // 0x23\n            this.opBITzp,       // 0x24\n            this.opANDzp,       // 0x25\n            this.opROLzp,       // 0x26\n            this.opUndefined,   // 0x27\n            this.opPLP,         // 0x28\n            this.opANDimm,      // 0x29\n            this.opROLacc,      // 0x2a\n            this.opUndefined,   // 0x2b\n            this.opBITabs,      // 0x2c\n            this.opANDabs,      // 0x2d\n            this.opROLabs,      // 0x2e\n            this.opUndefined,   // 0x2f\n            this.opBMI,         // 0x30\n            this.opANDindy,     // 0x31\n            this.opUndefined,   // 0x32\n            this.opUndefined,   // 0x33\n            this.opUndefined,   // 0x34\n            this.opANDzpx,      // 0x35\n            this.opROLzpx,      // 0x36\n            this.opUndefined,   // 0x37\n            this.opSEC,         // 0x38\n            this.opANDabsy,     // 0x39\n            this.opUndefined,   // 0x3a\n            this.opUndefined,   // 0x3b\n            this.opUndefined,   // 0x3c\n            this.opANDabsx,     // 0x3d\n            this.opROLabsx,     // 0x3e\n            this.opUndefined,   // 0x3f\n            this.opRTI,         // 0x40\n            this.opEORindx,     // 0x41\n            this.opUndefined,   // 0x42\n            this.opUndefined,   // 0x43\n            this.opUndefined,   // 0x44\n            this.opEORzp,       // 0x45\n            this.opLSRzp,       // 0x46\n            this.opUndefined,   // 0x47\n            this.opPHA,         // 0x48\n            this.opEORimm,      // 0x49\n            this.opLSRacc,      // 0x4a\n            this.opUndefined,   // 0x4b\n            this.opJMPimm16,    // 0x4c\n            this.opEORabs,      // 0x4d\n            this.opLSRabs,      // 0x4e\n            this.opUndefined,   // 0x4f\n            this.opBVC,         // 0x50\n            this.opEORindy,     // 0x51\n            this.opUndefined,   // 0x52\n            this.opUndefined,   // 0x53\n            this.opUndefined,   // 0x54\n            this.opEORzpx,      // 0x55\n            this.opLSRzpx,      // 0x56\n            this.opUndefined,   // 0x57\n            this.opCLI,         // 0x58\n            this.opEORabsy,     // 0x59\n            this.opUndefined,   // 0x5a\n            this.opUndefined,   // 0x5b\n            this.opUndefined,   // 0x5c\n            this.opEORabsx,     // 0x5d\n            this.opLSRabsx,     // 0x5e\n            this.opUndefined,   // 0x5f\n            this.opRTS,         // 0x60\n            this.opADCindx,     // 0x61\n            this.opUndefined,   // 0x62\n            this.opUndefined,   // 0x63\n            this.opUndefined,   // 0x64\n            this.opADCzp,       // 0x65\n            this.opRORzp,       // 0x66\n            this.opUndefined,   // 0x67\n            this.opPLA,         // 0x68\n            this.opADCimm,      // 0x69\n            this.opRORacc,      // 0x6a\n            this.opUndefined,   // 0x6b\n            this.opJMPabs16,    // 0x6c\n            this.opADCabs,      // 0x6d\n            this.opRORabs,      // 0x6e\n            this.opUndefined,   // 0x6f\n            this.opBVS,         // 0x70\n            this.opADCindy,     // 0x71\n            this.opUndefined,   // 0x72\n            this.opUndefined,   // 0x73\n            this.opUndefined,   // 0x74\n            this.opADCzpx,      // 0x75\n            this.opRORzpx,      // 0x76\n            this.opUndefined,   // 0x77\n            this.opSEI,         // 0x78\n            this.opADCabsy,     // 0x79\n            this.opUndefined,   // 0x7a\n            this.opUndefined,   // 0x7b\n            this.opUndefined,   // 0x7c\n            this.opADCabsx,     // 0x7d\n            this.opRORabsx,     // 0x7e\n            this.opUndefined,   // 0x7f\n            this.opUndefined,   // 0x80\n            this.opSTAindx,     // 0x81\n            this.opUndefined,   // 0x82\n            this.opUndefined,   // 0x83\n            this.opSTYzp,       // 0x84\n            this.opSTAzp,       // 0x85\n            this.opSTXzp,       // 0x86\n            this.opUndefined,   // 0x87\n            this.opDEY,         // 0x88\n            this.opUndefined,   // 0x89\n            this.opTXA,         // 0x8a\n            this.opUndefined,   // 0x8b\n            this.opSTYabs,      // 0x8c\n            this.opSTAabs,      // 0x8d\n            this.opSTXabs,      // 0x8e\n            this.opUndefined,   // 0x8f\n            this.opBCC,         // 0x90\n            this.opSTAindy,     // 0x91\n            this.opUndefined,   // 0x92\n            this.opUndefined,   // 0x93\n            this.opSTYzpx,      // 0x94\n            this.opSTAzpx,      // 0x95\n            this.opSTXzpy,      // 0x96\n            this.opUndefined,   // 0x97\n            this.opTYA,         // 0x98\n            this.opSTAabsy,     // 0x99\n            this.opTXS,         // 0x9a\n            this.opUndefined,   // 0x9b\n            this.opUndefined,   // 0x9c\n            this.opSTAabsx,     // 0x9d\n            this.opUndefined,   // 0x9e\n            this.opUndefined,   // 0x9f\n            this.opLDYimm,      // 0xa0\n            this.opLDAindx,     // 0xa1\n            this.opLDXimm,      // 0xa2\n            this.opUndefined,   // 0xa3\n            this.opLDYzp,       // 0xa4\n            this.opLDAzp,       // 0xa5\n            this.opLDXzp,       // 0xa6\n            this.opUndefined,   // 0xa7\n            this.opTAY,         // 0xa8\n            this.opLDAimm,      // 0xa9\n            this.opTAX,         // 0xaa\n            this.opUndefined,   // 0xab\n            this.opLDYabs,      // 0xac\n            this.opLDAabs,      // 0xad\n            this.opLDXabs,      // 0xae\n            this.opUndefined,   // 0xaf\n            this.opBCS,         // 0xb0\n            this.opLDAindy,     // 0xb1\n            this.opUndefined,   // 0xb2\n            this.opUndefined,   // 0xb3\n            this.opLDYzpx,      // 0xb4\n            this.opLDAzpx,      // 0xb5\n            this.opLDXzpy,      // 0xb6\n            this.opUndefined,   // 0xb7\n            this.opCLV,         // 0xb8\n            this.opLDAabsy,     // 0xb9\n            this.opTSX,         // 0xba\n            this.opUndefined,   // 0xbb\n            this.opLDYabsx,     // 0xbc\n            this.opLDAabsx,     // 0xbd\n            this.opLDXabsy,     // 0xbe\n            this.opUndefined,   // 0xbf\n            this.opCPYimm,      // 0xc0\n            this.opCMPindx,     // 0xc1\n            this.opUndefined,   // 0xc2\n            this.opUndefined,   // 0xc3\n            this.opCPYzp,       // 0xc4\n            this.opCMPzp,       // 0xc5\n            this.opDECzp,       // 0xc6\n            this.opUndefined,   // 0xc7\n            this.opINY,         // 0xc8\n            this.opCMPimm,      // 0xc9\n            this.opDEX,         // 0xca\n            this.opUndefined,   // 0xcb\n            this.opCPYabs,      // 0xcc\n            this.opCMPabs,      // 0xcd\n            this.opDECabs,      // 0xce\n            this.opUndefined,   // 0xcf\n            this.opBNE,         // 0xd0\n            this.opCMPindy,     // 0xd1\n            this.opUndefined,   // 0xd2\n            this.opUndefined,   // 0xd3\n            this.opUndefined,   // 0xd4\n            this.opCMPzpx,      // 0xd5\n            this.opDECzpx,      // 0xd6\n            this.opUndefined,   // 0xd7\n            this.opCLD,         // 0xd8\n            this.opCMPabsy,     // 0xd9\n            this.opUndefined,   // 0xda\n            this.opUndefined,   // 0xdb\n            this.opUndefined,   // 0xdc\n            this.opCMPabsx,     // 0xdd\n            this.opDECabsx,     // 0xde\n            this.opUndefined,   // 0xdf\n            this.opCPXimm,      // 0xe0\n            this.opSBCindx,     // 0xe1\n            this.opUndefined,   // 0xe2\n            this.opUndefined,   // 0xe3\n            this.opCPXzp,       // 0xe4\n            this.opSBCzp,       // 0xe5\n            this.opINCzp,       // 0xe6\n            this.opUndefined,   // 0xe7\n            this.opINX,         // 0xe8\n            this.opSBCimm,      // 0xe9\n            this.opNOP,         // 0xea\n            this.opUndefined,   // 0xeb\n            this.opCPXabs,      // 0xec\n            this.opSBCabs,      // 0xed\n            this.opINCabs,      // 0xee\n            this.opUndefined,   // 0xef\n            this.opBEQ,         // 0xf0\n            this.opSBCindy,     // 0xf1\n            this.opUndefined,   // 0xf2\n            this.opUndefined,   // 0xf3\n            this.opUndefined,   // 0xf4\n            this.opSBCzpx,      // 0xf5\n            this.opINCzpx,      // 0xf6\n            this.opUndefined,   // 0xf7\n            this.opSED,         // 0xf8\n            this.opSBCabsy,     // 0xf9\n            this.opUndefined,   // 0xfa\n            this.opUndefined,   // 0xfb\n            this.opUndefined,   // 0xfc\n            this.opSBCabsx,     // 0xfd\n            this.opINCabsx,     // 0xfe\n            this.opUndefined    // 0xff\n        ];\n        /*\n         * This is a 256-byte array of cycle counts, indexed by opcode.\n         * Obviously, true cycle counts are a bit more complicated, but this\n         * gets us most of the way to an authentic-feeling simulation.\n         *\n         * NOTE: BCD functions now account for an extra cycle, and branches\n         * now account for an extra cycle whenever the branch is taken.\n         * However, branches still don't add an extra cycle whenever the branch\n         * crosses a page boundary.\n         *\n         * The other gaping hole in our cycle-counting is accounting for all\n         * page-boundary penalties.  Ideally, that's just a matter of checking\n         * MODE_ABSX, MODE_ABSY, and MODE_INDY instructions for EA straddling\n         * a page boundary--but is it more complicated than that? What if the\n         * criteria is not the final EA, but whether the pre-indexing and\n         * post-indexing EAs are in different pages? I also need to confirm\n         * whether any other situations merit checking (eg, when a 2 or 3-byte\n         * instruction straddles a page boundary).\n         */\n        this.aOpcodeCycles = [\n            7,6,0,0,0,3,5,0,3,2,2,0,0,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            3,6,0,0,3,3,5,0,4,2,2,0,4,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            6,6,0,0,0,3,5,0,3,2,2,0,3,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            6,6,0,0,0,3,5,0,4,2,2,0,5,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            0,6,0,0,3,3,3,0,2,0,2,0,4,4,4,0,\n            2,5,0,0,4,4,4,0,2,4,2,0,0,4,0,0,\n            2,6,2,0,3,3,3,0,2,2,2,0,4,4,4,0,\n            2,5,0,0,4,4,4,0,2,4,2,0,4,4,4,0,\n            2,6,0,0,3,3,5,0,2,2,2,0,4,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            2,6,0,0,3,3,5,0,2,2,2,0,4,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0\n        ];\n    }\n\n    /**\n     * reset(fPowerOn)\n     *\n     * Note that we follow the same model here as other selected reset() handlers; for example, Video.reset()\n     * accepts an fPowerOn parameter to govern what's initially displayed on the video screen.\n     *\n     * @this {C1PCPU}\n     * @param {boolean|undefined} fPowerOn is true for the initial reset, so that if the Debugger isn't\n     * loaded, we can elect to start running.  Under any other circumstances (such as whenever Computer.reset()\n     * is called), \"auto-run\" is not a good idea, and can actually introduce bugs (eg, multiple run() timers).\n     */\n    reset(fPowerOn)\n    {\n        if (this.flags.running) {\n            this.halt();\n        }\n        this.clearRegs();\n        this.regPC = this.getWord(this.VECTOR_RESET);\n        this.clearError();              // clear any fatal error/exception\n        /*\n         * If there's a Debugger, notify Debugger.reset(); otherwise, start running\n         */\n        if (DEBUGGER && this.dbg) {\n            this.dbg.reset();\n        }\n        else if (fPowerOn) {\n            if (this.fAutoStart === true || this.fAutoStart === null && (!DEBUGGER || !this.dbg) && this.bindings[\"run\"] === undefined) {\n                this.run();             // start running automatically on the initial power-up, assuming there's no Debugger\n            }\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"run\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        var fBound = false;\n        switch(sBinding) {\n            case \"run\":\n                this.bindings[sBinding] = control;\n                control.onclick = function(cpu) {\n                    return function() {\n                        if (!cpu.flags.running) {\n                            cpu.run();\n                        } else {\n                            cpu.halt();\n                        }\n                    };\n                }(this);\n                fBound = true;\n                break;\n            case \"A\": case \"X\": case \"Y\": case \"S\": case \"PC\":\n            case \"C\": case \"Z\": case \"I\": case \"D\": case \"B\": case \"V\": case \"N\":\n            case \"speed\":\n                this.bindings[sBinding] = control;\n                fBound = true;\n                break;\n            case \"setSpeed\":\n                this.bindings[sBinding] = control;\n                control.onclick = function(cpu) {\n                    return function() {\n                        var speed = (cpu.speed >= cpu.SPEED_MAX? cpu.SPEED_SLOW : cpu.speed+1);\n                        cpu.setSpeed(speed, true);\n                    };\n                }(this);\n                fBound = true;\n                break;\n            default:\n                break;\n        }\n        return fBound;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     */\n    setBuffer(abMemory, start, end)\n    {\n        this.abMem = abMemory;\n        this.offMem = start;\n        this.cbMem = end - start + 1;\n        this.offLimit = this.offMem + this.cbMem;\n        if (this.offMem) {\n            /*\n             * It's not that we couldn't support an address buffer that starts at a non-zero offset;\n             * we simply have lots of code (eg, all the opcode handlers) that assumes offMem is zero,\n             * and therefore that abMem can be indexed by any of the CPU registers without adding offMem.\n             * All that code would have to be changed (at a slight performance penalty) if we couldn't\n             * make this assumption.\n             */\n            Component.error(\"unsupported CPU address buffer offset (\" + this.offMem + \")\");\n            return;\n        }\n        this.setReady();\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.cmp = cmp;\n            /*\n             * Attach the Debugger, if any, to the CPU, so that the CPU can periodically\n             * notify it as needed (when the CPU starts, stops, and executes instructions)\n             */\n            if (DEBUGGER) {\n                this.dbg = cmp.getComponentByType(\"debugger\");\n                if (this.dbg)\n                    this.dbg.init();\n            }\n            /*\n             * Attach the Video device to the CPU, so that the CPU can periodically update\n             * the video display via displayVideo(), as cycles permit.\n             */\n            var video = cmp.getComponentByType(\"video\");\n            if (video) {\n                this.displayVideo = function(v) {\n                    return function() {\n                        v.updateScreen();\n                    };\n                }(video);\n                this.setFocus = function(v) {\n                    return function() {\n                        v.setFocus();\n                    };\n                }(video);\n            }\n            this.flags.powered = true;\n            this.reset(true);\n            this.update();\n        }\n    }\n\n    /**\n     * Add a memory read-notification handler to the CPU's list of such handlers.\n     *\n     * @this {C1PCPU}\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn is called with the EA and PC values at the time of the write\n     */\n    addReadNotify(start, end, component, fn)\n    {\n        if (this.findNotify(this.aReadNotify, start, end, component, fn) < 0) {\n            if (this.addrReadLower > start)\n                this.addrReadLower = start;\n            if (this.addrReadUpper < end)\n                this.addrReadUpper = end;\n            this.aReadNotify.push([start, end, component, fn]);\n            if (DEBUG) this.log(\"addReadNotify(\" + Str.toHexWord(start) + \",\" + Str.toHexWord(end) + \",\" + component.id + \"): new read range: \" + Str.toHexWord(this.addrReadLower) + \"-\" + Str.toHexWord(this.addrReadUpper));\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addrRead is the EA value at the time of the read\n     * @param {number} [addrFrom] is the PC value at the time of the read;\n     * this will be undefined for read notifications triggered by assorted Debugger commands,\n     * so all handlers should be prepared for that as well.\n     */\n    checkReadNotify(addrRead, addrFrom)\n    {\n        for (var i=0; i < this.aReadNotify.length; i++) {\n            if (addrRead >= this.aReadNotify[i][0] && addrRead <= this.aReadNotify[i][1]) {\n                this.aReadNotify[i][3].call(this.aReadNotify[i][2], addrRead, addrFrom);\n            }\n        }\n    }\n\n    /**\n     * Remove a memory read-notification handler from the CPU's list of such handlers.\n     *\n     * @this {C1PCPU}\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn of previously added handler\n     * @return {boolean} true if remove was successful, false if the handler was not found\n     */\n    removeReadNotify(start, end, component, fn)\n    {\n        var aBounds = this.removeNotify(this.aReadNotify, start, end, component, fn);\n        if (aBounds.length == 4) {\n            this.addrReadLower = aBounds[2];\n            this.addrReadUpper = aBounds[3];\n            if (DEBUG) this.log(\"removeReadNotify(\" + Str.toHexWord(start) + \",\" + Str.toHexWord(end) + \",\" + component.id + \"): new read range: \" + Str.toHexWord(this.addrReadLower) + \"-\" + Str.toHexWord(this.addrReadUpper));\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Add a memory write-notification handler to the CPU's list of such handlers.\n     *\n     * @this {C1PCPU}\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn is called with the EA and PC values at the time of the write\n     */\n    addWriteNotify(start, end, component, fn)\n    {\n        if (this.findNotify(this.aWriteNotify, start, end, component, fn) < 0) {\n            if (this.addrWriteLower > start)\n                this.addrWriteLower = start;\n            if (this.addrWriteUpper < end)\n                this.addrWriteUpper = end;\n            this.aWriteNotify.push([start, end, component, fn]);\n            if (DEBUG) this.log(\"addWriteNotify(\" + Str.toHexWord(start) + \",\" + Str.toHexWord(end) + \",\" + component.id + \"): new write range: \" + Str.toHexWord(this.addrWriteLower) + \"-\" + Str.toHexWord(this.addrWriteUpper));\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addrWrite is the EA value at the time of the write\n     * @param {number} [addrFrom] is the PC value at the time of the write;\n     * this will be undefined for write notifications triggered by assorted Debugger commands,\n     * so all handlers should be prepared for that as well.\n     */\n    checkWriteNotify(addrWrite, addrFrom)\n    {\n        for (var i=0; i < this.aWriteNotify.length; i++) {\n            if (addrWrite >= this.aWriteNotify[i][0] && addrWrite <= this.aWriteNotify[i][1]) {\n                this.aWriteNotify[i][3].call(this.aWriteNotify[i][2], addrWrite, addrFrom);\n            }\n        }\n    }\n\n    /**\n     * Remove a memory write-notification handler from the CPU's list of such handlers.\n     *\n     * @this {C1PCPU}\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn of previously added handler\n     * @return {boolean} true if remove was successful, false if the handler was not found\n     */\n    removeWriteNotify(start, end, component, fn)\n    {\n        var aBounds = this.removeNotify(this.aWriteNotify, start, end, component, fn);\n        if (aBounds.length == 4) {\n            this.addrWriteLower = aBounds[2];\n            this.addrWriteUpper = aBounds[3];\n            if (DEBUG) this.log(\"removeWriteNotify(\" + Str.toHexWord(start) + \",\" + Str.toHexWord(end) + \",\" + component.id + \"): new write range: \" + Str.toHexWord(this.addrWriteLower) + \"-\" + Str.toHexWord(this.addrWriteUpper));\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find a memory notification handler from the given array of handlers\n     *\n     * @this {C1PCPU}\n     * @param {Array} aNotify array of handlers\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn of previously added handler\n     * @return {number} index of the matching handler, or -1 if not found\n     */\n    findNotify(aNotify, start, end, component, fn)\n    {\n        for (var i=0; i < aNotify.length; i++) {\n            if (aNotify[i][0] == start && aNotify[i][1] == end && aNotify[i][2] == component && aNotify[i][3] == fn) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Remove a memory notification handler from the given array of handlers\n     *\n     * @this {C1PCPU}\n     * @param {Array} aNotify array of handlers\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn of previously added handler\n     * @return {Array} bounds of previous handler ([0] and [1]) and new lower and upper address bounds ([2] and [3])\n     */\n    removeNotify(aNotify, start, end, component, fn)\n    {\n        var aBounds = [];\n        var i = this.findNotify(aNotify, start, end, component, fn);\n        if (i >= 0) {\n            aBounds.push(aNotify[i][0]);\n            aBounds.push(aNotify[i][1]);\n            aNotify.splice(i, 1);\n            var addrLower = 0x10000, addrUpper = 0x0;\n            for (i=0; i < aNotify.length; i++) {\n                if (addrLower > aNotify[i][0])\n                    addrLower = aNotify[i][0];\n                if (addrUpper < aNotify[i][1])\n                    addrUpper = aNotify[i][1];\n            }\n            aBounds.push(addrLower);\n            aBounds.push(addrUpper);\n        }\n        return aBounds;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} [speed] is one of: 0 (slow), 1 (fast) or 2 (maximum)\n     * @param {boolean} [fOnClick] is true if called from a click handler that might have stolen focus\n     * @desc Whenever the speed is changed, the running cycle count and corresponding start time must be reset,\n     * so that the next effective speed calculation obtains sensible results.  In fact, when run() initially calls\n     * setSpeed() with no parameters, that's all this function does (it doesn't change the current speed setting).\n     */\n    setSpeed(speed, fOnClick)\n    {\n        if (speed !== undefined) {\n            this.speed = speed;\n            if (this.bindings[\"setSpeed\"])\n                this.bindings[\"setSpeed\"].innerHTML = this.aSpeeds[speed >= 2? 0 : speed+1];\n            this.println(\"running at \" + this.aSpeeds[speed].toLowerCase() + \" speed \" + this.aSpeedDescs[speed]);\n            if (fOnClick) this.setFocus();\n        }\n        this.nRunCycles = 0;\n        this.msRunStart = Usr.getTime();\n        this.calcCycles();\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} nCycles\n     * @param {number} msElapsed\n     */\n    calcSpeed(nCycles, msElapsed)\n    {\n        if (msElapsed) {\n            this.mhz = Math.round(nCycles / ( msElapsed * 100)) / 10;\n            if (msElapsed >= 86400000)\n                this.setSpeed();        // reset all our counters once per day so that we never have to worry about overflow\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    displayVideo()\n    {\n        // Nothing to do until setPower() installs a replacement function\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    setFocus()\n    {\n        // Nothing to do until setPower() installs a replacement function\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {string} sReg\n     * @param {number} vReg\n     * @param {number} [len]\n     */\n    displayReg(sReg, vReg, len)\n    {\n        if (this.bindings[sReg] !== undefined) {\n            if (len === undefined) len = 1;\n            var s = \"0000\" + vReg.toString(16);\n            this.bindings[sReg].innerHTML = s.slice(s.length-len).toUpperCase();\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    displayStatus()\n    {\n        this.displayReg(\"A\", this.regA, 2);\n        this.displayReg(\"X\", this.regX, 2);\n        this.displayReg(\"Y\", this.regY, 2);\n        var regP = this.getRegP();\n        this.displayReg(\"C\", (regP & this.BIT_PC)? 1 : 0);\n        this.displayReg(\"Z\", (regP & this.BIT_PZ)? 1 : 0);\n        this.displayReg(\"I\", (regP & this.BIT_PI)? 1 : 0);\n        this.displayReg(\"D\", (regP & this.BIT_PD)? 1 : 0);\n        this.displayReg(\"B\", (regP & this.BIT_PB)? 1 : 0);\n        this.displayReg(\"V\", (regP & this.BIT_PV)? 1 : 0);\n        this.displayReg(\"N\", (regP & this.BIT_PN)? 1 : 0);\n        this.displayReg(\"S\", this.regS, 4);\n        this.displayReg(\"PC\", this.regPC, 4);\n        if (this.bindings[\"speed\"] && this.mhz) {\n            this.bindings[\"speed\"].innerHTML = this.mhz.toFixed(1) + \"Mhz\";\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @return {boolean}\n     */\n    isRunning()\n    {\n        return this.flags.running;\n    }\n\n    /**\n     * Calculate the number of cycles to process for each \"burst\" of CPU activity.  The size of a burst\n     * is driven by the following values:\n     *\n     *      nYieldsPerSecond (eg, 30)\n     *      nVideoUpdatesPerSecond (eg, 30)\n     *      nStatusUpdatesPerSecond (eg, 5)\n     *\n     * The largest of the above values forces the size of the burst to its smallest value.  Let's say that\n     * largest value is 30.  Assuming nCyclesPerSecond is 1,000,000, that results in bursts of 33,333 cycles.\n     *\n     * At the end of each burst, we subtract burst cycles from yield, video, and status cycle \"threshold\"\n     * counters. Whenever the \"next yield\" cycle counter goes to (or below) zero, we compare elapsed time\n     * to the time we expected the virtual hardware to take (eg, 1000ms/50 or 20ms), and if we still have time\n     * remaining, we sleep the remaining time (or 0ms if there's no remaining time), and then restart run().\n     *\n     * Similarly, whenever the \"next video update\" cycle counter goes to (or below) zero, we call displayVideo(),\n     * and whenever the \"next status update\" cycle counter goes to (or below) zero, we call displayStatus().\n     *\n     * @this {C1PCPU}\n     * @param {boolean} [fRecalc] is true if the caller wants to recalculate thresholds based on the\n     * most recent mhz calculation (see calcSpeed)\n     */\n    calcCycles(fRecalc)\n    {\n        /*\n         * Calculate the most cycles we're allowed to execute in a single \"burst\"\n         */\n        var nMostUpdatesPerSecond = this.nYieldsPerSecond;\n        if (nMostUpdatesPerSecond < this.nVideoUpdatesPerSecond) nMostUpdatesPerSecond = this.nVideoUpdatesPerSecond;\n        if (nMostUpdatesPerSecond < this.nStatusUpdatesPerSecond) nMostUpdatesPerSecond = this.nStatusUpdatesPerSecond;\n\n        /*\n         * Calculate \"per\" values for the yield, video update, and status update cycle counters\n         */\n        var vMultiplier = 1;\n        if (fRecalc && this.speed > this.SPEED_SLOW && this.mhz) vMultiplier = this.mhz;\n        if (vMultiplier > this.mhzFast && this.speed < this.SPEED_MAX) vMultiplier = this.mhzFast;\n\n        this.msPerYield = Math.round(1000/this.nYieldsPerSecond);\n        this.nCyclesPerBurst = Math.floor(this.nCyclesPerSecond / nMostUpdatesPerSecond * vMultiplier);\n        this.nCyclesPerYield = Math.floor(this.nCyclesPerSecond / this.nYieldsPerSecond * vMultiplier);\n        this.nCyclesPerVideoUpdate = Math.floor(this.nCyclesPerSecond / this.nVideoUpdatesPerSecond * vMultiplier);\n        this.nCyclesPerStatusUpdate = Math.floor(this.nCyclesPerSecond / this.nStatusUpdatesPerSecond * vMultiplier);\n\n        /*\n         * And initialize \"next\" yield, video update, and status update cycle \"threshold\" counters to those \"per\" values\n         */\n        if (!fRecalc) {\n            this.nCyclesNextYield = this.nCyclesPerYield;\n            this.nCyclesNextVideoUpdate = this.nCyclesPerVideoUpdate;\n            this.nCyclesNextStatusUpdate = this.nCyclesPerStatusUpdate;\n        }\n        this.nRecalcCycles = 0;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    calcStartTime()\n    {\n        if (this.nRecalcCycles >= this.nCyclesPerSecond) {\n            this.calcCycles(true);\n        }\n        this.nCyclesThisRun = 0;\n        this.msStartThisRun = Usr.getTime();\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @return {number}\n     */\n    calcRemainingTime()\n    {\n        var msCurrent = Usr.getTime();\n        var msYield = this.msPerYield;\n\n        if (this.nCyclesThisRun) {\n            /*\n             * Normally, we would assume we executed a full quota of work over msPerYield, but since the CPU\n             * now has the option of calling yieldCPU(), that might not be true.  If nCyclesThisRun is correct, then\n             * the ratio of nCyclesThisRun/nCyclesPerYield should represent the percentage of work we performed,\n             * and so applying that percentage to msPerYield should give us a better estimate of work vs. time.\n             */\n            msYield = Math.round(msYield * this.nCyclesThisRun / this.nCyclesPerYield);\n            // if (msYield < this.msPerYield) this.println(\"scaling msPerYield (\" + this.msPerYield + \") to msYield (\" + msYield + \")\");\n        }\n\n        var msElapsedThisRun = msCurrent - this.msStartThisRun;\n        var msRemainsThisRun = msYield - msElapsedThisRun;\n\n        /*\n         * We could pass only \"this run\" results to calcSpeed():\n         *\n         *      nCycles = this.nCyclesThisRun;\n         *      msElapsed = msElapsedThisRun;\n         *\n         * but it seems preferable to use longer time periods and hopefully get a more accurate speed.\n         *\n         * Also, if msRemainsThisRun >= 0 && this.speed == this.SPEED_SLOW, we could pass these results instead:\n         *\n         *      nCycles = this.nCyclesThisRun;\n         *      msElapsed = this.msPerYield;\n         *\n         * to insure that we display a smooth, constant 1Mhz.  But the displayed speed seems pretty steady as-is.\n         */\n        var nCycles = this.nRunCycles;\n        var msElapsed = msCurrent - this.msRunStart;\n\n        if (DEBUG && msRemainsThisRun < 0 && this.speed == this.SPEED_FAST) {\n            this.println(\"warning: updates @\" + msElapsedThisRun + \"ms (prefer \" + Math.round(msYield) + \"ms)\");\n        }\n\n        this.calcSpeed(nCycles, msElapsed);\n\n        if (msRemainsThisRun < 0) {\n            /*\n             * This is an easy case: it's taking more than 1 second to simulate 1Mhz,\n             * so all we can do is yield for as little time as possible (ie, 0ms) and hope the\n             * simulation is at least usable.\n             */\n            msRemainsThisRun = 0;\n        }\n        else {\n            if (this.speed == this.SPEED_FAST) {\n                /*\n                 * This case requires us to artificially limit the CPU speed.  calcSpeed()\n                 * already cranks up the number of cycles we process per burst, in proportion\n                 * to the effective mhz, so there isn't much to do here except sleep for\n                 * whatever time is in msRemainsThisRun.\n                 *\n                 * The artificial limit was chosen largely because it's not currently possible\n                 * for the keyboard component to inject keys fast enough to avoid duplicate\n                 * keystrokes at higher speeds. Perhaps with future improvements to the keyboard\n                 * component, this limit can be lifted.\n                 */\n                if (this.mhz <= this.mhzFast)\n                    msRemainsThisRun = 0;\n            }\n            else\n            if (this.speed == this.SPEED_MAX) {\n                /*\n                 * This is also an easy case: yield for as little time as possible (ie, 0ms), to execute\n                 * the maximum number of cycles per second.\n                 */\n                msRemainsThisRun = 0;\n            }\n        }\n\n        /*\n         * Last but not least, update nRecalcCycles, so that when run() starts up again and calls calcStartTime(),\n         * it'll be ready to decide if calcCycles() should be called again.\n         */\n        this.nRecalcCycles += this.nCyclesThisRun;\n\n        return msRemainsThisRun;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    run()\n    {\n        if (!this.setBusy(true)) {\n            this.update();\n            if (this.cmp) this.cmp.stop(this.msRunStart, this.nRunCycles);\n            return;\n        }\n        if (!this.flags.running) {\n            /*\n             *  setSpeed() without a speed parameter leaves the selected speed in place, but also resets the\n             *  cycle counter and timestamp for the current series of run() calls, calculates the maximum number\n             *  of cycles for each burst based on the last known effective CPU speed, and resets the nRecalcCycles\n             *  threshold counter.\n             */\n            this.setSpeed();\n            if (this.cmp) this.cmp.start();\n            this.flags.running = true;\n            if (this.bindings[\"run\"]) this.bindings[\"run\"].innerHTML = \"Halt\";\n            this.setFocus();\n        }\n        /*\n         *  calcStartTime() initializes the cycle counter and timestamp for this run() invocation, and optionally\n         *  recalculates the the maximum number of cycles for each burst if the nRecalcCycles threshold has been reached.\n         */\n        this.calcStartTime();\n        try {\n            do {\n                /*\n                 * NOTE: nCyclesPerBurst is how many cycles we WANT to run each iteration of step(), but that just\n                 * initializes nBurstCycles, which (after subtracting any remaining nStepCycles) is how many cycles\n                 * we ACTUALLY ran.\n                 */\n                this.step(this.nCyclesPerBurst);\n                /*\n                 * nCyclesThisRun is increased by nBurstCycles, plus any additional cycles step() processed after\n                 * its cycle count had reached zero (and conversely, minus any cycles that it still had yet to process);\n                 * ditto for nRunCycles, which is the cycle count since the CPU first started running.\n                 */\n                var nCycles = this.nBurstCycles - this.nStepCycles;\n                this.nRunCycles += nCycles;\n                this.nCyclesThisRun += nCycles;\n                /*\n                 * These step() cycle variables must be zeroed now, so that getCycles() always returns a valid cycle count.\n                 */\n                this.nBurstCycles = this.nStepCycles = 0;\n\n                this.nCyclesNextVideoUpdate -= this.nCyclesPerBurst;\n                if (this.nCyclesNextVideoUpdate <= 0) {\n                    this.nCyclesNextVideoUpdate += this.nCyclesPerVideoUpdate;\n                    this.displayVideo();\n                }\n\n                this.nCyclesNextStatusUpdate -= this.nCyclesPerBurst;\n                if (this.nCyclesNextStatusUpdate <= 0) {\n                    this.nCyclesNextStatusUpdate += this.nCyclesPerStatusUpdate;\n                    this.displayStatus();\n                }\n\n                this.nCyclesNextYield -= this.nCyclesPerBurst;\n                if (this.nCyclesNextYield <= 0) {\n                    this.nCyclesNextYield += this.nCyclesPerYield;\n                    break;\n                }\n            } while (this.flags.running);\n        }\n        catch (e) {\n            this.halt();\n            this.update();\n            this.setBusy(false);\n            this.setError(e.stack || e.message);\n            return;\n        }\n        setTimeout(function(cpu) { return function() {cpu.run();}; }(this), this.calcRemainingTime());\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} nMinCycles (0 implies a single-step, and therefore breakpoints should be ignored)\n     * @return {boolean|undefined} undefined indicates that the last instruction was not executed (eg,\n     * we hit an execution breakpoint), false implies a post-execution condition was triggered (eg, a write\n     * breakpoint), and true indicates successful completion of all requested cycles.\n     */\n    step(nMinCycles)\n    {\n        /*\n         * The Debugger uses fCompleted to determine if the instruction completed (true) or was interrupted\n         * by a breakpoint or some other exceptional condition (false). NOTE: this does NOT include thrown\n         * exceptions, which step() expects the caller to catch using its own exception handler.\n         *\n         * The CPU relies on the use of halt() rather than fCompleted, because the CPU never single-steps\n         * (ie, nMinCycles is always some large number), whereas the Debugger does.  And conversely, when the\n         * Debugger is single-stepping (even when performing multiple single-steps), fRunning is never set,\n         * so halt() would have no effect as far as the Debugger is concerned.\n         */\n        var fCompleted = true;\n\n        /*\n         * fDebugCheck is true if we need to \"check\" every instruction with the Debugger.  The Debugger will\n         * call cpu.step(n) with n == 0 if it's executing only ONE instruction (ie, the user just clicked the\n         * \"Step\" button, or they've issued a \"t\" or \"t1\" command).  Otherwise, it will call with n == 1\n         * (ie, the user is holding the \"Step\" button, or they've issued a \"t#\" command where # > 1).\n         *\n         * In the first case, we want to ignore (ie, \"step over\") any breakpoints; otherwise, the Debugger has\n         * no easy way of moving past a breakpoint (other than clearing it, of course).  In the second case,\n         * we want to honor any breakpoints, which in turn will set fCompleted to false and signal the Debugger\n         * to stop.\n         *\n         * Note that as a practical matter, both 0 and 1 are otherwise treated the same when it comes to the\n         * minimum number of cycles to run: one and only one instruction will execute, since every instruction\n         * consumes at least 1 cycle.\n         */\n        this.regEA = this.regEAWrite = -1;\n        var fDebugCheck = (DEBUGGER && nMinCycles && this.dbg && this.dbg.checksEnabled());\n\n        /*\n         * We move the minimum cycle count to nStepCycles (the number of cycles left to run), so that other\n         * methods have the ability to force that number to zero (eg, halt()), and thus we don't have to check\n         * some other criteria just to determine whether we should continue running or not.\n         */\n        this.nBurstCycles = this.nStepCycles = nMinCycles;\n        do {\n            var bOpCode = this.abMem[this.regPC];\n\n            if (fDebugCheck && !this.dbg.checkInstruction(this.regPC, bOpCode)) {\n                fCompleted = undefined;\n                this.halt();\n                break;\n            }\n\n            this.regPC++;\n            this.aOpcodeFuncs[bOpCode].call(this);\n\n            /*\n             * Assert that all register contents remain within their respective ranges.\n             */\n\n\n            /*\n             * WARNING: By making the following read-or-write test exclusive, we're not going to catch\n             * those situations where an instruction does BOTH. For example, JSR pushes the old PC\n             * (which, if we were tracking STACK writes, would set regEAWrite) and then fetches a new PC\n             * (which should set regEA).  However, that's a situation which, except for a peculiar\n             * combination of read and write breakpoints set by the Debugger, is one we simply don't care\n             * about.  Moreover, none of our opcode handlers currently set BOTH regEA and regEAWrite,\n             * so it would be completely pointless to check both conditions here.\n             *\n             * Since READS are FAR more common than WRITES, we check the common case first.  If the\n             * day comes that we implement opcode functions that set both regEA AND regEAWrite, then we'll\n             * want to remove the \"else\" below and stop making the read and write tests exclusive.\n             * If we don't, then some of those rare/unusual writes will either get missed or delayed.\n             *\n             * It's also worth mentioning here that not all instructions READ or WRITE (eg, INX, INY and\n             * others that are completely flag or register-bound).  It's a bit ironic that those instructions,\n             * which are typically the fastest, have to perform both the READ and WRITE tests below.  But\n             * on the plus side, both tests will fail, so they'll still get out of here faster than any of\n             * the other instructions.\n             */\n            if (this.regEA >= 0) {\n                /*\n                 * Serial emulation requires a read notification handler, and the keyboard may eventually\n                 * want one, too.\n                 */\n                if (this.regEA >= this.addrReadLower && this.regEA <= this.addrReadUpper) {\n                    this.checkReadNotify(this.regEA, this.regPC);\n                }\n                if (fDebugCheck && !this.dbg.checkMemoryRead(this.regEA)) {\n                    fCompleted = false;\n                    this.halt();\n                    break;\n                }\n                this.regEA = -1;\n            }\n            else if (this.regEAWrite >= 0) {\n                /*\n                 * We process the write notification handlers before the write breakpoint handlers,\n                 * because we don't want to leave any ROM (read-only memory) writes in place before we\n                 * (potentially) give up control.  Undoing every write to ROM address space is an essential\n                 * part of simulating the \"read-only\" behavior of ROM.\n                 *\n                 * Obviously, there are other write notification handlers as well (like the keyboard's),\n                 * which may sometimes do things we'd prefer to intercept first, but let's keep things simple.\n                 */\n                if (this.regEAWrite >= this.addrWriteLower && this.regEAWrite <= this.addrWriteUpper) {\n                    this.checkWriteNotify(this.regEAWrite, this.regPC);\n                }\n                if (fDebugCheck && !this.dbg.checkMemoryWrite(this.regEAWrite, this.abMem[this.regEAWrite])) {\n                    fCompleted = false;\n                    this.halt();\n                    break;\n                }\n                this.regEAWrite = -1;\n            }\n\n            this.nStepCycles -= this.aOpcodeCycles[bOpCode];\n\n        } while (this.nStepCycles > 0);\n\n        return fCompleted;\n    }\n\n    /**\n     * yieldCPU() is similar to halt() with regard to how it resets various cycle countdown values,\n     * but the CPU remains in a \"running\" state.\n     *\n     * @this {C1PCPU}\n     */\n    yieldCPU()\n    {\n        this.nCyclesNextYield = 0;          // this will break us out of run(), once we break out of step()\n        this.nBurstCycles -= this.nStepCycles;\n        this.nStepCycles = 0;               // this will break us out of step()\n    }\n\n    /**\n     * halt() is similar to yieldCPU(), but it doesn't need to zero nCyclesNextYield to break out of run();\n     * it simply needs to clear fRunning.\n     *\n     * @this {C1PCPU}\n     */\n    halt()\n    {\n        this.isBusy(true);\n        this.nBurstCycles -= this.nStepCycles;\n        this.nStepCycles = 0;\n        if (this.flags.running) {\n            this.flags.running = false;\n            if (this.bindings[\"run\"]) this.bindings[\"run\"].innerHTML = \"Run\";\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * This used to be performed at the end of every step(), but run() -- which relies upon step() -- needed to have\n     * more control over when these updates are performed.  However, for other callers of step(), such as the Debugger,\n     * the combination of step() + update() provides the old behavior.\n     */\n    update()\n    {\n        this.displayVideo();\n        this.displayStatus();\n    }\n\n    /**\n     * getCycles() returns the number of cycles executed so far.  Note that we can be called after\n     * a run() OR during a run(), perhaps from a handler triggered during the current run's step(),\n     * so nRunCycles must always be adjusted by number of cycles step() was asked to run (nBurstCycles),\n     * less the number of cycles it has yet to run (nStepCycles).\n     *\n     * nRunCycles is reset whenever the CPU is halted or the CPU speed is changed, so returning 0 when the\n     * CPU is stopped seems perfectly reasonable.  As a result, components that rely on getCycles() returning a\n     * steadily increasing number should also be prepared for a reset at any time (eg, the Keyboard's\n     * updateMemory() function).\n     *\n     * @this {C1PCPU}\n     * @return {number}\n     */\n    getCycles()\n    {\n        return (this.flags.running? this.nRunCycles + this.nBurstCycles - this.nStepCycles : 0);\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addr\n     * @return {number}\n     *\n     * Unlike the Debugger versions of these functions, these presume that addr is always valid,\n     * since it's internally generated, not user-supplied. Of course, we could still have internal\n     * bugs, so asserts are included, but they are present in DEBUG code only (automatically\n     * removed from RELEASE code).\n     *\n     * Moreover, it's unlikely we'll use this function much (unless performance becomes secondary\n     * to code size), since all the opCode functions should perform their own fetches, for obvious\n     * performance reasons.\n     */\n    getByte(addr)\n    {\n\n        var b = this.abMem[addr];\n\n        return b;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addr\n     * @return {number}\n     */\n    getWord(addr)\n    {\n\n        var w = this.abMem[addr] | (this.abMem[addr+1] << 8);\n\n        return w;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addr\n     * @param {number} b\n     */\n    setByte(addr, b)\n    {\n\n\n        this.abMem[addr] = b;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @return {number}\n     */\n    getRegP()\n    {\n        /*\n         *  // C = LAZY_C;\n         *  this.regP = ((this.regP & 0xfe) | ((((this.regRC & 0x0100)))? 0x01 : 0));\n         *  // Z = LAZY_Z;\n         *  this.regP = ((this.regP & 0xfd) | ((((this.regRZ & 0xff) == 0))? 0x02 : 0));\n         *  // V = LAZY_V;\n         *  this.regP = ((this.regP & 0xbf) | (((((((this.regRV & 0xff) ^ this.regRU) ^ (this.regRV >> 1)) & 0x80) != 0))? 0x40 : 0));\n         *  // N = LAZY_N;\n         *  this.regP = ((this.regP & 0x7f) | ((((this.regRN & 0x80)))? 0x80 : 0));\n         */\n        var regP = ((this.regRC & 0x0100)? 0x01 : 0x00);\n        regP |= (!(this.regRZ & 0xff)? 0x02 : 0x00);\n        regP |= (((((this.regRV & 0xff) ^ this.regRU) ^ (this.regRV >> 1)) & 0x80)? 0x40 : 0x00);\n        regP |= ((this.regRN & 0x80)? 0x80 : 0x00);\n        return (this.regP & 0x3C) | regP;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the C flag\n     */\n    clearC()\n    {\n        this.regRC = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the C flag\n     */\n    setC()\n    {\n        this.regRC = 0x100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the N bit\n     */\n    clearN()\n    {\n        this.regRN = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the N bit\n     */\n    setN()\n    {\n        this.regRN = 0x80;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the V bit\n     */\n    clearV()\n    {\n        this.regRV = 0x00; this.regRU = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the V bit\n     */\n    setV()\n    {\n        this.regRV = 0x00; this.regRU = 0x80;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the Z bit\n     */\n    clearZ()\n    {\n        this.regRZ = 0x01;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the Z bit\n     */\n    setZ()\n    {\n        this.regRZ = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the BCD bit and install the BCD opcode handlers\n     */\n    setBCD()\n    {\n        this.regP |= 0x08;\n        this.aOpcodeFuncs[0x61] = this.opADCindxBCD;\n        this.aOpcodeFuncs[0x65] = this.opADCzpBCD;\n        this.aOpcodeFuncs[0x69] = this.opADCimmBCD;\n        this.aOpcodeFuncs[0x6d] = this.opADCabsBCD;\n        this.aOpcodeFuncs[0x71] = this.opADCindyBCD;\n        this.aOpcodeFuncs[0x75] = this.opADCzpxBCD;\n        this.aOpcodeFuncs[0x79] = this.opADCabsyBCD;\n        this.aOpcodeFuncs[0x7d] = this.opADCabsxBCD;\n        this.aOpcodeFuncs[0xe1] = this.opSBCindxBCD;\n        this.aOpcodeFuncs[0xe5] = this.opSBCzpBCD;\n        this.aOpcodeFuncs[0xe9] = this.opSBCimmBCD;\n        this.aOpcodeFuncs[0xed] = this.opSBCabsBCD;\n        this.aOpcodeFuncs[0xf1] = this.opSBCindyBCD;\n        this.aOpcodeFuncs[0xf5] = this.opSBCzpxBCD;\n        this.aOpcodeFuncs[0xf9] = this.opSBCabsyBCD;\n        this.aOpcodeFuncs[0xfd] = this.opSBCabsxBCD;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the BCD bit and remove the BCD opcode handlers\n     */\n    clearBCD()\n    {\n        this.regP &= ~0x08;\n        this.aOpcodeFuncs[0x61] = this.opADCindx;\n        this.aOpcodeFuncs[0x65] = this.opADCzp;\n        this.aOpcodeFuncs[0x69] = this.opADCimm;\n        this.aOpcodeFuncs[0x6d] = this.opADCabs;\n        this.aOpcodeFuncs[0x71] = this.opADCindy;\n        this.aOpcodeFuncs[0x75] = this.opADCzpx;\n        this.aOpcodeFuncs[0x79] = this.opADCabsy;\n        this.aOpcodeFuncs[0x7d] = this.opADCabsx;\n        this.aOpcodeFuncs[0xe1] = this.opSBCindx;\n        this.aOpcodeFuncs[0xe5] = this.opSBCzp;\n        this.aOpcodeFuncs[0xe9] = this.opSBCimm;\n        this.aOpcodeFuncs[0xed] = this.opSBCabs;\n        this.aOpcodeFuncs[0xf1] = this.opSBCindy;\n        this.aOpcodeFuncs[0xf5] = this.opSBCzpx;\n        this.aOpcodeFuncs[0xf9] = this.opSBCabsy;\n        this.aOpcodeFuncs[0xfd] = this.opSBCabsx;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} reg\n     * @param {number} mem\n     * @return {number}\n     *\n     * Refer to http://www.6502.org/tutorials/decimal_mode.html for 6502-specific details.\n     * Refer to http://homepage.cs.uiowa.edu/~jones/bcd/bcd.html for optimization tips.\n     */\n    addBCD(reg, mem)\n    {\n        var carry = ((this.regRC & 0x0100)? 1 : 0);\n\n        /*\n         * First add the low nibbles.\n         */\n        var r = (reg & 0x0f) + (mem & 0x0f) + carry;\n\n        /*\n         * Adjust the result. NOTE: The extra AND'ing and ADD'ing isn't necessary if we want to\n         * assume that ONLY valid BCD digits will be added, but we probably shouldn't assume that.\n         * NOTE: We use an OR instead of an ADD at the end because it's logically equivalent and faster.\n         */\n        if (r >= 0x0A) r = ((r + 0x06) & 0x0f) | 0x10;\n\n        /*\n         * Now add the high nibbles.\n         */\n        r += (reg & 0xf0) + (mem & 0xf0);\n\n        /*\n         * Before we do the next adjust, it seems that N and V are dependent on this intermediate\n         * result (however, the meaning of N and V in BCD mode is not well documented).\n         */\n        this.regRU = reg ^ mem; this.regRV = r;\n        this.regRN = (r & 0xff);\n\n        /*\n         * Final adjustment.\n         */\n        if (r >= 0xA0) r += 0x60;\n        /*\n         * NOTE: If the intermediate result was 0x1A0 or more, then adding 0x60 would yield a result\n         * of 0x200 or more, but because the rest of the simulator tests regRC for 0x100, rather than\n         * comparing regRC for values >= 0x100, we'll miss the fact that there was a carry, unless we\n         * scale any value in the 0x200-0x2ff range down to 0x100-0x1ff.  We then assert that the\n         * resulting value is within the proper range.\n         */\n        if (r >= 0x200) r -= 0x100;\n\n\n        /*\n         * In BCD mode, the C flag reflects the decimal result, but the Z flag reflects binary addition.\n         */\n        this.regRC = r;\n        this.regRZ = ((reg + mem + carry) & 0xff);\n\n        /*\n         * Account for an extra cycle in BCD mode as well.\n         */\n        this.nStepCycles--;\n\n        return r & 0xff;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} reg\n     * @param {number} mem\n     * @return {number}\n     *\n     * Refer to http://www.6502.org/tutorials/decimal_mode.html for 6502-specific details.\n     * Refer to http://homepage.cs.uiowa.edu/~jones/bcd/bcd.html for optimization tips.\n     */\n    subBCD(reg, mem)\n    {\n        var notcarry = ((this.regRC & 0x0100)? 0 : 1);\n\n        /*\n         * First subtract the low nibbles.\n         */\n        var r = (reg & 0x0f) - (mem & 0x0f) - notcarry;\n\n        /*\n         * Adjust the result. NOTE: The extra AND'ing and SUB'ing isn't necessary if we want to\n         * assume that ONLY valid BCD digits will be added, but we probably shouldn't assume that.\n         */\n        if (r < 0x00) r = ((r - 0x06) & 0x0f) - 0x10;\n\n        /*\n         * Now subtract the high nibbles.\n         */\n        r += (reg & 0xf0) - (mem & 0xf0);\n\n        /*\n         * Final adjustment.\n         */\n        if (r < 0x00) r -= 0x60;\n\n        /*\n         * In BCD mode, the Z -- and C, N and V -- flags are all set as if binary subtraction was performed.\n         */\n        // RC = (A - ML - !LAZY_C); SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC = (reg - mem - notcarry)) & 0xff;\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = reg ^ mem; this.regRV = this.regRC;\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n\n        /*\n         * Account for an extra cycle in BCD mode as well.\n         */\n        this.nStepCycles--;\n\n        return r & 0xff;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    clearRegs()\n    {\n        this.regA = 0;\n        this.regX = 0;\n        this.regY = 0;\n        this.regS = 0x100;\n        this.regP = 0;\n        this.regRN = 0;\n        this.regRZ = 0;\n        this.regRU = 0;\n        this.regRV = 0;\n        this.regRC = 0;\n        this.regPC = 0;\n        this.regEA = -1;\n        this.regEAWrite = -1;\n        this.mhz = 0;\n        this.nRunCycles = this.nBurstCycles = this.nStepCycles = 0;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBRK()\n    {   // opcode 0x00\n        // PC++;\n        this.regPC++;\n        // STACK(S--) = PCH;\n        this.abMem[this.regS--] = (this.regPC >> 8);\n        this.regS |= 0x100;\n        // STACK(S--) = PCL;\n        this.abMem[this.regS--] = (this.regPC & 0xff);\n        this.regS |= 0x100;\n        // B = 1;\n        this.regP |= 0x10;\n        // C = LAZY_C; Z = LAZY_Z; V = LAZY_V; N = LAZY_N;\n        this.regP = this.getRegP();\n        // STACK(S--) = P;\n        this.abMem[this.regS--] = this.regP;\n        this.regS |= 0x100;\n        // B = 0;\n        this.regP &= 0xef;\n        // EA = 0xFFFE;\n        this.regEA = 0xFFFE;\n        // PC = M;\n        this.regPC = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAindx()\n    {   // opcode 0x01\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAzp()\n    {   // opcode 0x05\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLzp()\n    {   // opcode 0x06\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // RC = ML << 1;\n        this.regRC = this.abMem[this.regEAWrite] << 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opPHP()\n    {   // opcode 0x08\n        this.regP = this.getRegP();\n        // STACK(S--) = P;\n        this.abMem[this.regS--] = this.regP;\n        this.regS |= 0x100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAimm()\n    {   // opcode 0x09\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLacc()\n    {   // opcode 0x0a\n        // RC = A << 1;\n        this.regRC = this.regA << 1;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAabs()\n    {   // opcode 0x0d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLabs()\n    {   // opcode 0x0e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = ML << 1;\n        this.regRC = this.abMem[this.regEAWrite] << 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBPL()\n    {   // opcode 0x10\n        // PC = PC + (LAZY_N == 0? SBYTE(PC) : 0) + 1;\n        this.regPC += (!(this.regRN & 0x80)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAindy()\n    {   // opcode 0x11\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAzpx()\n    {   // opcode 0x15\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLzpx()\n    {   // opcode 0x16\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RC = ML << 1;\n        this.regRC = this.abMem[this.regEAWrite] << 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCLC()\n    {   // opcode 0x18\n        // SET_LAZY_C(0);\n        this.regRC = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAabsy()\n    {   // opcode 0x19\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA |= this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAabsx()\n    {   // opcode 0x1d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA |= this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLabsx()\n    {   // opcode 0x1e\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RC = ML << 1;\n        this.regRC = this.abMem[this.regEAWrite] << 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opJSRabs()\n    {   // opcode 0x20\n        // EA = PC; PC += 1;\n        this.regEA = this.regPC++;\n        // STACK(S--) = PCH;\n        this.abMem[this.regS--] = (this.regPC >> 8);\n        this.regS |= 0x100;\n        // STACK(S--) = PCL;\n        this.abMem[this.regS--] = (this.regPC & 0xff);\n        this.regS |= 0x100;\n        // PC = M;\n        this.regPC = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDindx()\n    {   // opcode 0x21\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBITzp()\n    {   // opcode 0x24\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // SET_LAZY_Z((A & ML) == 0);\n        this.regRZ = (this.regA & this.abMem[this.regEA]);\n        // SET_LAZY_N(ML7);\n        this.regRN = ((this.regRN & 0x7f) | (this.abMem[this.regEA] & 0x80));\n        // SET_LAZY_V(ML6);\n        this.regRV = 0; this.regRU = ((this.abMem[this.regEA] & 0x40)? 0x80 : 0x00);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDzp()\n    {   // opcode 0x25\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLzp()\n    {   // opcode 0x26\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | (((this.regRC & 0x0200))? 0x0001 : 0));\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opPLP()\n    {   // opcode 0x28\n        // P = STACK(++S);\n        this.regS = ((this.regS+1) & 0xff) | 0x100;\n        this.regP = this.abMem[this.regS];\n        // SET_LAZY_C(C);\n        this.regRC = ((this.regP & 0x01)? 0x0100 : 0);\n        // SET_LAZY_Z(Z);\n        this.regRZ = (!(this.regP & 0x02)? 0x01 : 0);\n        // SET_LAZY_N(N);\n        this.regRN = (this.regP & 0x80);\n        // SET_LAZY_V(V);\n        this.regRV = 0; this.regRU = ((this.regP & 0x40)? 0x80 : 0x00);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDimm()\n    {   // opcode 0x29\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLacc()\n    {   // opcode 0x2a\n        // RCL =  A;\n        this.regRC = ((this.regRC & 0xff00) | this.regA);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | ((this.regRC & 0x0200)? 0x0001 : 0));\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBITabs()\n    {   // opcode 0x2c\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // SET_LAZY_Z((A & ML) == 0);\n        this.regRZ = (this.regA & this.abMem[this.regEA]);\n        // SET_LAZY_N(ML7);\n        this.regRN = ((this.regRN & 0x7f) | (this.abMem[this.regEA] & 0x80));\n        // SET_LAZY_V(ML6);\n        this.regRV = 0; this.regRU = ((this.abMem[this.regEA] & 0x40)? 0x80 : 0x00);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDabs()\n    {   // opcode 0x2d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLabs()\n    {   // opcode 0x2e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | (((this.regRC & 0x0200))? 0x0001 : 0));\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBMI()\n    {   // opcode 0x30\n        // PC = PC + (LAZY_N != 0? SBYTE(PC) : 0) + 1;\n        this.regPC += ((this.regRN & 0x80)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDindy()\n    {   // opcode 0x31\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDzpx()\n    {   // opcode 0x35\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLzpx()\n    {   // opcode 0x36\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | (((this.regRC & 0x0200))? 0x0001 : 0));\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSEC()\n    {   // opcode 0x38\n        // SET_LAZY_C(1);\n        this.regRC = 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDabsy()\n    {   // opcode 0x39\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDabsx()\n    {   // opcode 0x3d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLabsx()\n    {   // opcode 0x3e\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | (((this.regRC & 0x0200))? 0x0001 : 0));\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRTI()\n    {   // opcode 0x40\n        // P = STACK(++S);\n        this.regS = ((this.regS+1) & 0xff) | 0x100;\n        this.regP = this.abMem[this.regS];\n        // SET_LAZY_C(C);\n        this.regRC = ((this.regP & 0x01)? 0x0100 : 0);\n        // SET_LAZY_Z(Z);\n        this.regRZ = (!(this.regP & 0x02)? 0x01 : 0);\n        // SET_LAZY_N(N);\n        this.regRN = (this.regP & 0x80);\n        // SET_LAZY_V(V);\n        this.regRV = 0; this.regRU = ((this.regP & 0x40)? 0x80 : 0x00);\n        // PCL = STACK(++S);\n        // PCH = STACK(++S);\n        this.regS = ((this.regS+2) & 0xff) | 0x100;\n        this.regPC = (this.abMem[(this.regS-1) | 0x100]) | (this.abMem[this.regS] << 8);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORindx()\n    {   // opcode 0x41\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORzp()\n    {   // opcode 0x45\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRzp()\n    {   // opcode 0x46\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // SET_LAZY_C(ML0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.abMem[this.regEAWrite] & 0x01)? 0x0100 : 0));\n        // ML = RCL = ML >> 1;\n        this.abMem[this.regEAWrite] = ((this.regRC = ((this.regRC & 0xff00) | (this.abMem[this.regEAWrite] >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opPHA()\n    {   // opcode 0x48\n        // STACK(S--) = A;\n        this.abMem[this.regS--] = this.regA;\n        this.regS |= 0x100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORimm()\n    {   // opcode 0x49\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRacc()\n    {   // opcode 0x4a\n        // SET_LAZY_C( A0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.regA & 0x01)? 0x0100 : 0));\n        // A = RCL =  A >> 1;\n        this.regA = ((this.regRC = ((this.regRC & 0xff00) | (this.regA >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opJMPimm16()\n    {   // opcode 0x4c\n        // EA = PC;\n        this.regEA = this.regPC;\n        // PC += 2;\n        // this.regPC += 2;\n        // PC = M;\n        this.regPC = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORabs()\n    {   // opcode 0x4d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRabs()\n    {   // opcode 0x4e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // SET_LAZY_C(ML0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.abMem[this.regEAWrite] & 0x01)? 0x0100 : 0));\n        // ML = RCL = ML >> 1;\n        this.abMem[this.regEAWrite] = ((this.regRC = ((this.regRC & 0xff00) | (this.abMem[this.regEAWrite] >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBVC()\n    {   // opcode 0x50\n        // PC = PC + (LAZY_V == 0? SBYTE(PC) : 0) + 1;\n        this.regPC += (!((((this.regRV & 0xff) ^ this.regRU) ^ (this.regRV >> 1)) & 0x80)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORindy()\n    {   // opcode 0x51\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = this.abMem[this.regPC++];\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORzpx()\n    {   // opcode 0x55\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRzpx()\n    {   // opcode 0x56\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // SET_LAZY_C(ML0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.abMem[this.regEAWrite] & 0x01)? 0x0100 : 0));\n        // ML = RCL = ML >> 1;\n        this.abMem[this.regEAWrite] = ((this.regRC = ((this.regRC & 0xff00) | (this.abMem[this.regEAWrite] >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCLI()\n    {   // opcode 0x58\n        // I = 0;\n        this.regP &= 0xfb;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORabsy()\n    {   // opcode 0x59\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORabsx()\n    {   // opcode 0x5d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = A ^ ML; SET_LAZY_NZ(A)\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRabsx()\n    {   // opcode 0x5e\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // SET_LAZY_C(ML0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.abMem[this.regEAWrite] & 0x01)? 0x0100 : 0));\n        // ML = RCL = ML >> 1;\n        this.abMem[this.regEAWrite] = ((this.regRC = ((this.regRC & 0xff00) | (this.abMem[this.regEAWrite] >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRTS()\n    {   // opcode 0x60\n        // PCL = STACK(++S);\n        // PCH = STACK(++S);\n        // PC++;\n        this.regS = ((this.regS+2) & 0xff) | 0x100;\n        this.regPC = (((this.abMem[(this.regS-1) | 0x100])) | ((this.abMem[this.regS]) << 8)) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCindx()\n    {   // opcode 0x61\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCindxBCD()\n    {   // opcode 0x61\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCzp()\n    {   // opcode 0x65\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCzpBCD()\n    {   // opcode 0x65\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORzp()\n    {   // opcode 0x66\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opPLA()\n    {   // opcode 0x68\n        // A = STACK(++S); SET_LAZY_NZ(A);\n        this.regS = ((this.regS+1) & 0xff) | 0x100;\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regS];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCimm()\n    {   // opcode 0x69\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCimmBCD()\n    {   // opcode 0x69\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORacc()\n    {   // opcode 0x6a\n        // RCL =  A;\n        this.regRC = ((this.regRC & 0xff00) | this.regA);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * NOTE from Wikipedia: \"The 6502's memory indirect jump instruction, JMP (<address>), is partially broken.\n     * If <address> is hex xxFF (i.e., any word ending in FF), the processor will not jump to the address stored in xxFF and xxFF+1 as expected,\n     * but rather the one defined by xxFF and xx00. This defect continued through the entire NMOS line, but was corrected in the CMOS derivatives.\"\n     */\n    opJMPabs16()\n    {   // opcode 0x6c\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // PC = M;\n        this.regPC = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabs()\n    {   // opcode 0x6d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = (A + ML + LAZY_C);\n        this.regRC =(this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsBCD()\n    {   // opcode 0x6d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORabs()\n    {   // opcode 0x6e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBVS()\n    {   // opcode 0x70\n        // PC = PC + (LAZY_V != 0? SBYTE(PC) : 0) + 1;\n        this.regPC += (((((this.regRV & 0xff) ^ this.regRU) ^ (this.regRV >> 1)) & 0x80)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCindy()\n    {   // opcode 0x71\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCindyBCD()\n    {   // opcode 0x71\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCzpx()\n    {   // opcode 0x75\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCzpxBCD()\n    {   // opcode 0x75\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORzpx()\n    {   // opcode 0x76\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSEI()\n    {   // opcode 0x78\n        // I = 1;\n        this.regP |= 0x04;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsy()\n    {   // opcode 0x79\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsyBCD()\n    {   // opcode 0x79\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsx()\n    {   // opcode 0x7d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsxBCD()\n    {   // opcode 0x7d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORabsx()\n    {   // opcode 0x7e\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAindx()\n    {   // opcode 0x81\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEAWrite = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEAWrite = (this.abMem[this.regEAWrite] | (this.abMem[this.regEAWrite+1] << 8));\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTYzp()\n    {   // opcode 0x84\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = Y;\n        this.abMem[this.regEAWrite] = this.regY;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAzp()\n    {   // opcode 0x85\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTXzp()\n    {   // opcode 0x86\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = X;\n        this.abMem[this.regEAWrite] = this.regX;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDEY()\n    {   // opcode 0x88\n        // Y = ((Y - 1) & 0xff);\n        this.regY = ((this.regY - 1) & 0xff);\n        // SET_LAZY_NZ(Y);\n        this.regRN = this.regRZ = (this.regY);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTXA()\n    {   // opcode 0x8a\n        // A = X; SET_LAZY_NZ(X);\n        this.regRN = this.regRZ = this.regA = this.regX;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTYabs()\n    {   // opcode 0x8c\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = Y;\n        this.abMem[this.regEAWrite] = this.regY;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAabs()\n    {   // opcode 0x8d\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTXabs()\n    {   // opcode 0x8e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = X;\n        this.abMem[this.regEAWrite] = this.regX;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBCC()\n    {   // opcode 0x90\n        // PC = PC + (LAZY_C == 0? SBYTE(PC) : 0) + 1;\n        this.regPC += (!(this.regRC & 0x0100)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAindy()\n    {   // opcode 0x91\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEAWrite = (this.abMem[this.regPC++]);\n        this.regEAWrite = (this.abMem[this.regEAWrite] | (this.abMem[this.regEAWrite+1] << 8)) + this.regY;\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTYzpx()\n    {   // opcode 0x94\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // ML = Y;\n        this.abMem[this.regEAWrite] = this.regY;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAzpx()\n    {   // opcode 0x95\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTXzpy()\n    {   // opcode 0x96\n        // EA = (BYTE(PC++)+Y) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regY) & 0xff;\n        // ML = X;\n        this.abMem[this.regEAWrite] = this.regX;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTYA()\n    {   // opcode 0x98\n        // A = Y; SET_LAZY_NZ(Y);\n        this.regRN = this.regRZ = this.regA = this.regY;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAabsy()\n    {   // opcode 0x99\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTXS()\n    {   // opcode 0x9a\n        // S = X;\n        this.regS = this.regX | 0x100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAabsx()\n    {   // opcode 0x9d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYimm()\n    {   // opcode 0xa0\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAindx()\n    {   // opcode 0xa1\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXimm()\n    {   // opcode 0xa2\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYzp()\n    {   // opcode 0xa4\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAzp()\n    {   // opcode 0xa5\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXzp()\n    {   // opcode 0xa6\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTAY()\n    {   // opcode 0xa8\n        // Y = A; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regY = this.regA;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAimm()\n    {   // opcode 0xa9\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTAX()\n    {   // opcode 0xaa\n        // X = A; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regX = this.regA;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYabs()\n    {   // opcode 0xac\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAabs()\n    {   // opcode 0xad\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXabs()\n    {   // opcode 0xae\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBCS()\n    {   // opcode 0xb0\n        // PC = PC + (LAZY_C != 0? SBYTE(PC) : 0) + 1;\n        this.regPC += ((this.regRC & 0x0100)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAindy()\n    {   // opcode 0xb1\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYzpx()\n    {   // opcode 0xb4\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAzpx()\n    {   // opcode 0xb5\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXzpy()\n    {   // opcode 0xb6\n        // EA = (BYTE(PC++)+Y) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regY) & 0xff;\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCLV()\n    {   // opcode 0xb8\n        // SET_LAZY_V(0);\n        this.regRV = 0; this.regRU = 0;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAabsy()\n    {   // opcode 0xb9\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTSX()\n    {   // opcode 0xba\n        // X = S; SET_LAZY_NZ(S);\n        this.regRN = this.regRZ = this.regX = this.regS & 0xff;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYabsx()\n    {   // opcode 0xbc\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAabsx()\n    {   // opcode 0xbd\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXabsy()\n    {   // opcode 0xbe\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPYimm()\n    {   // opcode 0xc0\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = Y - ML;\n        this.regRC = this.regY - this.abMem[this.regEA];\n        // SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = (this.regRC);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPindx()\n    {   // opcode 0xc1\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPYzp()\n    {   // opcode 0xc4\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = Y - ML;\n        this.regRC = this.regY - this.abMem[this.regEA];\n        // SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = (this.regRC);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPzp()\n    {   // opcode 0xc5\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDECzp()\n    {   // opcode 0xc6\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = ML - 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] - 1) & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINY()\n    {   // opcode 0xc8\n        // Y = ((Y + 1) & 0xff);\n        this.regY = ((this.regY + 1) & 0xff);\n        // SET_LAZY_NZ(Y);\n        this.regRN = this.regRZ = (this.regY);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPimm()\n    {   // opcode 0xc9\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDEX()\n    {   // opcode 0xca\n        // X = ((X - 1) & 0xff); SET_LAZY_NZ(X);\n        this.regRN = this.regRZ = this.regX = ((this.regX - 1) & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPYabs()\n    {   // opcode 0xcc\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = Y - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = this.regY - this.abMem[this.regEA];\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPabs()\n    {   // opcode 0xcd\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDECabs()\n    {   // opcode 0xce\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = ML - 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] - 1) & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBNE()\n    {   // opcode 0xd0\n        // PC = PC + (LAZY_Z == 0? SBYTE(PC) : 0) + 1;\n        this.regPC += ((this.regRZ & 0xff)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPindy()\n    {   // opcode 0xd1\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPzpx()\n    {   // opcode 0xd5\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDECzpx()\n    {   // opcode 0xd6\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // ML = ML - 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] - 1) & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCLD()\n    {   // opcode 0xd8\n        // D = 0;\n        this.clearBCD();\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPabsy()\n    {   // opcode 0xd9\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPabsx()\n    {   // opcode 0xdd\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDECabsx()\n    {   // opcode 0xde\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // ML = ML - 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] - 1) & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPXimm()\n    {   // opcode 0xe0\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = X - ML;\n        this.regRC = this.regX - this.abMem[this.regEA];\n        // SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = (this.regRC);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCindx()\n    {   // opcode 0xe1\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCindxBCD()\n    {   // opcode 0xe1\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPXzp()\n    {   // opcode 0xe4\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = X - ML;\n        this.regRC = this.regX - this.abMem[this.regEA];\n        // SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = (this.regRC);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCzp()\n    {   // opcode 0xe5\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCzpBCD()\n    {   // opcode 0xe5\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINCzp()\n    {   // opcode 0xe6\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = ML + 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] + 1) & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINX()\n    {   // opcode 0xe8\n        // X = ((X + 1) & 0xff);\n        this.regX = ((this.regX + 1) & 0xff);\n        // SET_LAZY_NZ(X);\n        this.regRN = this.regRZ = (this.regX);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCimm()\n    {   // opcode 0xe9\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCimmBCD()\n    {   // opcode 0xe9\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opNOP()\n    {   // opcode 0xea\n        //\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPXabs()\n    {   // opcode 0xec\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = X - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = this.regX - this.abMem[this.regEA];\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabs()\n    {   // opcode 0xed\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsBCD()\n    {   // opcode 0xed\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINCabs()\n    {   // opcode 0xee\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = ML + 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] + 1) & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBEQ()\n    {   // opcode 0xf0\n        // PC = PC + (LAZY_Z == 1? SBYTE(PC) : 0) + 1;\n        this.regPC += (!(this.regRZ & 0xff)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCindy()\n    {   // opcode 0xf1\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCindyBCD()\n    {   // opcode 0xf1\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCzpx()\n    {   // opcode 0xf5\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCzpxBCD()\n    {   // opcode 0xf5\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINCzpx()\n    {   // opcode 0xf6\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // ML = ML + 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] + 1) & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSED()\n    {   // opcode 0xf8\n        // D = 1;\n        this.setBCD();\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsy()\n    {   // opcode 0xf9\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsyBCD()\n    {   // opcode 0xf9\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsx()\n    {   // opcode 0xfd\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsxBCD()\n    {   // opcode 0xfd\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINCabsx()\n    {   // opcode 0xfe\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // ML = ML + 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] + 1) & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSim()\n    {\n        var addr;\n        var bSimOp = this.abMem[this.regPC++];\n        switch(bSimOp) {\n\n            case this.SIMOP_HLT:\n                this.println(\"HALT\");\n                this.halt();\n                break;\n\n            case this.SIMOP_MSG:\n                addr = this.regPC;                  // currently we're using \"inline\" strings\n                // addr = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n                var s = \"\";\n                while (addr < this.abMem.length) {\n                    var b = this.abMem[addr++];\n                    if (!b) break;\n                    s += String.fromCharCode(b);\n                }\n                this.regPC = addr;                  // update regPC as long as we're doing \"inline\" strings\n                /*\n                 * Before simply printing the string, what kinds of handy substitutions should we provide?\n                 *\n                 *      eg: %A for this.regA, %X for this.regX, etc\n                 */\n                s = s.replace(/%A/g, Str.toHex(this.regA, 2)).replace(/%X/g, Str.toHex(this.regX, 2)).replace(/%Y/g, Str.toHex(this.regY, 2));\n                this.println(s);\n                /*\n                 * To make printing \"smoother\", let's force a yield\n                 */\n                this.yieldCPU();\n                break;\n\n            default:\n                this.regPC -= 2;\n                this.println(\"undefined opSim: \" + Str.toHexByte(bSimOp) + \" at \" + Str.toHexWord(this.regPC));\n                this.halt();\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opUndefined()\n    {\n        var b = this.abMem[--this.regPC];\n        this.println(\"undefined opcode: \" + Str.toHexByte(b) + \" at \" + Str.toHexWord(this.regPC));\n        this.halt();\n    }\n\n    /**\n     * C1PCPU.init()\n     *\n     * This function operates on every HTML element of class \"cpu\", extracting the\n     * JSON-encoded parameters for the C1PCPU constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PCPU component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeCPUs = Component.getElementsByClass(document, C1PJS.APPCLASS, \"cpu\");\n        for (var iCPU=0; iCPU < aeCPUs.length; iCPU++) {\n            var eCPU = aeCPUs[iCPU];\n            var parmsCPU = Component.getComponentParms(eCPU);\n            var cpu = new C1PCPU(parmsCPU);\n            Component.bindComponentControls(cpu, eCPU, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Macro reference (from my original 1998 C source code, preserved in the comments below):\n *\n *      #define BYTE(a)  (abMem[(a) & 0xffff])\n *      #define WORD(a)  (*(word *)&BYTE(a))\n *      #define SBYTE(a) ((int)(char)BYTE(a))\n *      #define STACK(a) BYTE(((a) & 0xff)+0x100)\n *      #define M WORD(EA)\n *      #define ML BYTE(EA+0)\n *      #define MH BYTE(EA+1)\n *      #define A (aRegs[0].value)  // 8 bits\n *      #define X (aRegs[1].value)  // 8 bits\n *      #define Y (aRegs[2].value)  // 8 bits\n *      #define S (aRegs[3].value)  // 8 bits\n *      #define P (aRegs[4].value)  // 8 bits\n *      #define RN (aRegs[5].value) // 8 bits\n *      #define RZ (aRegs[6].value) // 8 bits\n *      #define RU (aRegs[7].value) // 8 bits\n *      #define RV (aRegs[8].value) // 16 bits\n *      #define RC (aRegs[9].value) // 16 bits\n *      #define EA (aRegs[10].value)// 16 bits\n *      #define LA (aRegs[11].value)// 16 bits\n *      #define PC (aRegs[12].value)// 16 bits\n *      #define EF (aRegs[13].value)// 8 bits\n *      #define C P0\n *      #define Z P1\n *      #define I P2\n *      #define D P3\n *      #define B P4\n *      #define V P6\n *      #define N P7\n *      #define W EF0\n *      #define LAZY_C (RCH0)\n *      #define SET_LAZY_C(b) (RCH0 = (b))\n *      #define LAZY_N (RN7)\n *      #define SET_LAZY_N(b) (RN7 = (b))\n *      #define SET_LAZY_NZ(v) (RN = RZ = (v))\n *      #define LAZY_Z ((byte)RZ == 0)\n *      #define SET_LAZY_Z(b) (RZ = !(b))\n *      #define LAZY_V ((((RVL ^ RU) ^ (RV >> 1)) & 0x80) != 0)\n *      #define SET_LAZY_V(b) (RV = 0, RU = ((b)? 0x80 : 0x00))\n *      #define SET_LAZY_OV(a,b,r) (RU = (a) ^ (b), RV = (r))\n */\n\n/*\n * Initialize every CPU module on the page (as IF there's ever going to be more than one ;-))\n */\nWeb.onInit(C1PCPU.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/rom.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PROM extends Component {\n    /**\n     * C1PROM(parmsROM)\n     *\n     * The ROM component expects the following (parmsROM) properties:\n     *\n     *      size: amount of ROM, in bytes\n     *      image: name of ROM image file\n     *\n     * NOTE: The final location for the ROM image, once loaded, will be specified\n     * by the Computer object, using the setBuffer() method.\n     *\n     * @this {C1PROM}\n     * @param {Object} parmsROM\n     * @property {function()} convertImage\n     */\n    constructor(parmsROM)\n    {\n        super(\"C1PROM\", parmsROM);\n\n        this.abMem = null;\n        this.abImage = null;\n        this.cbROM = parmsROM['size'];\n        this.sImage = parmsROM['image'];\n        if (this.sImage) {\n            var sFileURL = this.sImage;\n            /**\n             * If the selected ROM image has a \".json\" extension, then we assume it's a pre-converted\n             * JSON-encoded ROM image, so we load it as-is; ditto for files with a \".hex\" extension. Otherwise,\n             * we ask our server-side ROM image converter to return the corresponding JSON-encoded data,\n             * in compact form (ie, minimal whitespace, no ASCII data comments, etc).\n             */\n            var sFileExt = Str.getExtension(this.sImage);\n            if (sFileExt != DumpAPI.FORMAT.JSON && sFileExt != DumpAPI.FORMAT.HEX) {\n                sFileURL = Web.getHost() + DumpAPI.ENDPOINT + '?' + DumpAPI.QUERY.FILE + '=' + this.sImage + '&' + DumpAPI.QUERY.FORMAT + '=' + DumpAPI.FORMAT.BYTES;\n            }\n            var rom = this;\n            Web.getResource(sFileURL, null, true, function(sURL, sResponse, nErrorCode) {\n                rom.convertImage(sURL, sResponse, nErrorCode);\n            });\n        }\n    }\n\n    /**\n     * @this {C1PROM}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.offROM = start;\n        var cbROM = end - start + 1;\n        /*\n         * It's possible that the ROM component didn't specify a size,\n         * in which case just use the size the Computer component has specified.\n         */\n        if (!this.cbROM)\n            this.cbROM = cbROM;\n        if (cbROM != this.cbROM) {\n            this.setError(\"computer-specified ROM size (\" + Str.toHexWord(cbROM) + \") does not match component-specified size (\" + Str.toHexWord(this.cbROM) + \")\");\n            return;\n        }\n        if (cpu) {\n            this.cpu = cpu;\n            cpu.addWriteNotify(start, end, this, this.setByte);\n        }\n        this.copyImage();\n    }\n\n    /**\n     * @this {C1PROM}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n        }\n    }\n\n    /**\n     * @this {C1PROM}\n     * @param {number} addr\n     * @param {number|undefined} [addrFrom]\n     */\n    setByte(addr, addrFrom)\n    {\n        /*\n         * Beyond reporting this write, we need to \"repair\" the ROM, using the original image data,\n         * but only if addrFrom is defined (undefined implies this is a write from the Debugger, and\n         * we need to allow the Debugger to modify ROM contents).\n         */\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_PORT, true);\n            var offset = (addr - this.offROM);\n\n            if (!this.abImage)\n                this.abMem[this.offROM + offset] = 0;\n            else\n                this.abMem[this.offROM + offset] = this.abImage[offset];\n        }\n    }\n\n    /**\n     * @this {C1PROM}\n     * @param {string} sImageName\n     * @param {string} sImageData\n     * @param {number} nErrorCode (response from server if anything other than 200)\n     */\n    convertImage(sImageName, sImageData, nErrorCode)\n    {\n        if (nErrorCode) {\n            this.println(\"Error loading ROM \\\"\" + sImageName + \"\\\" (\" + nErrorCode + \")\");\n            return;\n        }\n        if (sImageData.charAt(0) == \"[\" || sImageData.charAt(0) == \"{\") {\n            try {\n                /*\n                 * The most likely source of any exception will be here: parsing the JSON-encoded ROM data.\n                 */\n                var rom = eval(\"(\" + sImageData + \")\");\n                var ab = rom['bytes'];\n                if (ab) {\n                    this.abImage = ab;\n                } else {\n                    this.abImage = rom;\n                }\n            } catch (e) {\n                this.println(\"Error processing ROM \\\"\" + sImageName + \"\\\": \" + e.message);\n                return;\n            }\n        }\n        else {\n            /*\n             * Parse the ROM image data manually; we assume it's in \"simplified\" hex form (a series of hex byte-values separated by whitespace)\n             */\n            var sData = sImageData.replace(/\\n/gm, \" \").replace(/ +$/, \"\");\n            var asData = sData.split(\" \");\n            this.abImage = new Array(asData.length);\n            for (var i=0; i < asData.length; i++) {\n                this.abImage[i] = parseInt(asData[i], 16);\n            }\n        }\n        this.copyImage();\n    }\n\n    /**\n     * @this {C1PROM}\n     */\n    copyImage()\n    {\n        /*\n         * The Computer object may give us the address of the ROM image before we've finished downloading the image,\n         * so both setBuffer() and convertImage() call copyImage(), which in turn will copy the image ONLY when both\n         * pieces are in place.  At that point, the component becomes \"ready\", in much the same way that other components\n         * (eg, CPU and Screen) become \"ready\" when all their prerequisites are satisfied.\n         */\n        if (!this.isReady()) {\n            if (!this.sImage) {\n                this.setReady();\n            }\n            else\n            if (this.abImage && this.abMem) {\n                var cbImage = this.abImage.length;\n                if (cbImage != this.cbROM) {\n                    this.setError(\"ROM image size (\" + Str.toHexWord(cbImage) + \") does not match component-specified size (\" + Str.toHexWord(this.cbROM) + \")\");\n                    return;\n                }\n                if (DEBUG) this.log(\"copyImage(): copying ROM to \" + Str.toHexWord(this.offROM) + \" (\" + Str.toHexWord(cbImage) + \" bytes)\");\n                for (var i=0; i < cbImage; i++) {\n                    this.abMem[this.offROM + i] = this.abImage[i];\n                }\n                this.setReady();\n            }\n        }\n    }\n\n    /**\n     * C1PROM.init()\n     *\n     * This function operates on every HTML element of class \"rom\", extracting the\n     * JSON-encoded parameters for the C1PROM constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PROM component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeROM = Component.getElementsByClass(document, C1PJS.APPCLASS, \"rom\");\n        for (var iROM=0; iROM < aeROM.length; iROM++) {\n            var eROM = aeROM[iROM];\n            var parmsROM = Component.getComponentParms(eROM);\n            var rom = new C1PROM(parmsROM);\n            Component.bindComponentControls(rom, eROM, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize all the ROM modules on the page.\n */\nWeb.onInit(C1PROM.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/ram.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PRAM extends Component {\n    /**\n     * C1PRAM(parmsRAM)\n     *\n     * The RAM component expects the following (parmsRAM) properties:\n     *\n     *      size: amount of RAM, in bytes\n     *\n     * NOTE: We may make a note of the specified size, but we will not actually allocate\n     * any memory for the RAM; we wait for the Computer object to tell us where our RAM is,\n     * using the setBuffer() method.\n     *\n     * @this {C1PRAM}\n     * @param {Object} parmsRAM\n     */\n    constructor(parmsRAM)\n    {\n        super(\"C1PRAM\", parmsRAM);\n    }\n\n    /**\n     * @this {C1PRAM}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n     // this.offRAM = start;\n     // this.cbRAM = end - start + 1;\n        this.setReady();\n    }\n\n    /**\n     * C1PRAM.init()\n     *\n     * This function operates on every HTML element of class \"ram\", extracting the\n     * JSON-encoded parameters for the C1PRAM constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PRAM component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeRAM = Component.getElementsByClass(document, C1PJS.APPCLASS, \"ram\");\n        for (var iRAM=0; iRAM < aeRAM.length; iRAM++) {\n            var eRAM = aeRAM[iRAM];\n            var parmsRAM = Component.getComponentParms(eRAM);\n            var ram = new C1PRAM(parmsRAM);\n            Component.bindComponentControls(ram, eRAM, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize all the RAM modules on the page.\n */\nWeb.onInit(C1PRAM.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/keyboard.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PKeyboard extends Component {\n    /**\n     * C1PKeyboard(parmsKbd)\n     *\n     * The Keyboard component can be configured with the following (parmsKbd) properties:\n     *\n     *      model: model number (one of: 542 or 600; 600 is the default)\n     *\n     * Its main purpose is to receive binding requests for various keyboard events,\n     * and to use those events to simulate the C1P's keyboard hardware; specifically,\n     * an OSI model 600 board (NOT the model 542).\n     *\n     * Keys on the C1P keyboard that differ from modern keyboards, along with their\n     * closest modern counterpart:\n     *\n     *      C1P      PC\n     *      ---      --\n     *      2\"       2@\n     *      6&       6^\n     *      7'       7&\n     *      8(       8*\n     *      9)       9(\n     *      0        0)\n     *      :*       -_\n     *      -=       =+\n     *      ;+       ;:\n     *      LINEFEED CTRL-J\n     *      RETURN   ENTER (or CTRL-M)\n     *      SHIFT-O  DELETE (or CTRL-H)\n     *      SHIFT-N  ^\n     *      SHIFT-P  @ (used by the BASIC-IN-ROM to abandon the current line)\n     *      SHIFT-L  \\\n     *      SHIFT-K  [\n     *      SHIFT-M  ]\n     *      CTRL-C   Same (used by the BASIC-IN-ROM to interrupt RUN and LIST, unless disabled with POKE 530,1)\n     *      CTRL-O   Same (used by the BASIC-IN-ROM to suppress output until another CTRL-O is typed)\n     *      RUB-OUT  (no mapping chosen for this key yet)\n     *      REPEAT   (no mapping chosen for this key yet)\n     *\n     * Problems with iOS Devices\n     * -------------------------\n     * The keyboard pops up with the SHIFT key depressed, which is not the initial keyboard state that the C1P expects.\n     * I tried to fix that by adding an 'autocapitalize=\"off\"' attribute alongside the 'contenteditable=\"true\"' attribute\n     * on the <canvas> element, but apparently Safari v5 honors that only inside certain elements (eg, <input>).  The simplest\n     * work-around is to tap the iOS device's SHIFT key before starting to type, but I'd prefer an automatic solution.\n     *\n     * Another work-around might be to NEVER pass the real CAPS-LOCK state to the virtual machine, and whenever CAPS-LOCK is\n     * actually down, automatically \"uncapitalize\" all letters.\n     *\n     * However, the current work-around is for keyPressSimulate() to ALWAYS convert all alphabetic charCodes to their\n     * lower-case equivalents, and simply let the C1P's own shift-key logic do its thing.  Note that we do this ONLY for\n     * iOS devices, so that on all other devices, you can still use special shifted key combinations like SHIFT-O and SHIFT-P;\n     * this work-around breaks those key combinations for iOS devices, but that seems like a reasonable trade-off.\n     *\n     * Simple C1P Virtual Hardware Test\n     * --------------------------------\n     * Using the following code:\n     *\n     *      10 POKE 530,1\n     *      20 KEY=57088\n     *      25 Q=-1\n     *      30 POKE KEY,64\n     *      40 P=PEEK(KEY)\n     *      50 IF P<>Q THEN PRINT P\n     *      60 Q=P\n     *      70 GOTO 30\n     *\n     * The value 64 (0x40) should have enabled every row except R6.  Here were the results for keys\n     * on row R7:\n     *\n     *        1   2   3   4   5   6   7\n     *      --- --- --- --- --- --- ---\n     *      126 190 222 238 246 250 252\n     *\n     * Sure enough, none of the keys on R6 worked, and all the keys on rows R0-R5 generated the same\n     * values as R7. But why were the values read all EVEN instead of ODD (ie, why was bit 0 cleared as\n     * well?)  Answer: because 0x40 also enables keys on row R0, where the SHIFT-LOCK key resides,\n     * and since the SHIFT-LOCK is normally locked AND also sits in column C0, bit 0 will be clear as well.\n     *\n     * This explains why the \"STAR WARS\" game (SAMPLE4.BAS) expected values \"126,190,222,238,246,250\"\n     * for keys 1-6 after POKE'ing 64 into location 57088 (0xdf00), instead of the more typical values\n     * \"127,191,223,239,247,251.\"  This also means that anyone who happened to unlock their SHIFT-LOCK\n     * would have trouble playing that game.\n     *\n     * @this {C1PKeyboard}\n     * @param {Object} parmsKbd\n     */\n    constructor(parmsKbd)\n    {\n        super(\"C1PKeyboard\", parmsKbd);\n\n        this.flags.powered = false;\n        this.nDefaultModel = parmsKbd['model'];\n\n        /*\n         * keyCodes that I must pay particular attention to\n         */\n        this.KEYCODE_DELETE     = 0x08;\n        this.KEYCODE_TAB        = 0x09;\n        this.KEYCODE_LF         = 0x0A;\n        this.KEYCODE_CR         = 0x0D;\n        this.KEYCODE_SHIFT      = 0x10;                 // I map this to CHARCODE_LSHIFT\n        this.KEYCODE_CONTROL    = 0x11;\n        this.KEYCODE_ALT        = 0x12;                 // I map this to CHARCODE_RSHIFT (since the C1P keyboard has no ALT key)\n        this.KEYCODE_CAPSLOCK   = 0x14;\n        this.KEYCODE_ESC        = 0x1B;                 // NOTE: for some reason, this comes in via keyDown/keyUp only, not keyPress\n        this.KEYCODE_COMMAND    = 0x5B;\n\n        /*\n         * The following charCodes are the same as the corresponding keyCodes\n         */\n        this.CHARCODE_DELETE    = this.KEYCODE_DELETE;\n        this.CHARCODE_LF        = this.KEYCODE_LF;\n        this.CHARCODE_CR        = this.KEYCODE_CR;\n        this.CHARCODE_ESC       = this.KEYCODE_ESC;\n\n        /*\n         * The following charCodes are NOT the same as the corresponding keyCodes, hence the bias (PSEUDO_CHARCODE);\n         * I've deliberately chosen a bias that still produces values in the byte range (0x00-0xFF) and will therefore\n         * fit into aCharCodeMap, but which shouldn't conflict with any actual, type-able keys.\n         */\n        this.PSEUDO_CHARCODE    = 0xE0;\n        this.CHARCODE_LSHIFT    = this.KEYCODE_SHIFT    + this.PSEUDO_CHARCODE;\n        this.CHARCODE_CTRL      = this.KEYCODE_CONTROL  + this.PSEUDO_CHARCODE;\n        this.CHARCODE_RSHIFT    = this.KEYCODE_ALT      + this.PSEUDO_CHARCODE;\n        this.CHARCODE_SHIFTLOCK = this.KEYCODE_CAPSLOCK + this.PSEUDO_CHARCODE;\n\n        /*\n         * Other common character codes, pseudo (like the C1P's \"BREAK\" key, which has no modern analog) or otherwise\n         */\n        this.CHARCODE_BREAK     = 0x00 + this.PSEUDO_CHARCODE;\n        this.CHARCODE_CTRLC     = 0x03;\n        this.CHARCODE_CTRLO     = 0x0F;\n\n        /*\n         * These are \"shift key\" bits I store in bitsShift, and with the exception of BIT_COMMAND (because\n         * the C1P doesn't have a COMMAND key), they all match the bit position of the corresponding shift key's\n         * column on row 0 (abKbdCols[0]) of the simulated keyboard hardware.\n         *\n         * NOTE: Whenever shift key bits need to be restored from bitsShift to abKbdCols[0] (eg, when restoring\n         * the current shift state at the completion of a simulated key), be sure to mask bitsShift with BITS_SIMULATE\n         * before propagating them.\n         */\n        this.BIT_SHIFTLOCK      = 0x01;\n        this.BIT_RSHIFT         = 0x02;\n        this.BIT_LSHIFT         = 0x04;\n        this.BIT_COMMAND        = 0x08;     // the C1P has no key \"wired\" to this column, so I can use this bit for COMMAND\n        this.BIT_CTRL           = 0x40;\n        this.BITS_SIMULATE      = (this.BIT_RSHIFT | this.BIT_LSHIFT | this.BIT_CTRL);\n\n        this.SIMCODE_KEYPRESS   = 0;\n        this.SIMCODE_KEYRELEASE = 1;\n        this.SIMCODE_KEYEVENT   = 2;\n        this.SIMCODE_KEYTIMEOUT = 3;\n        this.SIMCODE_AUTOCLEAR  = 4;\n        this.aSimCodeDescs = [\"keyPress\",\"keyRelease\",\"keyEvent\",\"keyTimeout\",\"autoClear\"];\n\n        /*\n         * From \"OSI C1P Technical Report\" p.19 regarding the Model 600 Board:\n         *\n         *      \"By holding down any key, one will first get one character output, and after approximately\n         *      a half second delay a repeat rate of approximately 5 characters per second.\"\n         */\n        this.nCyclesThreshold   = 8192;     // number of virtual CPU cycles required before aKbdStates is propagated\n        this.msReleaseDelay     = 250;      // number of milliseconds before a down key is \"forced\" up (unless we see it go up)\n        this.msReleaseRepeat    = 100;      // number of milliseconds before a held key is \"forced\" up (assuming auto-repeat)\n        this.msInjectDelay      = 300;      // number of milliseconds between injected keystrokes\n\n        this.aButtonCodeMap = {};\n        this.aButtonCodeMap['break']  = this.CHARCODE_BREAK;\n        this.aButtonCodeMap['esc']    = this.CHARCODE_ESC;\n        this.aButtonCodeMap['ctrl-c'] = this.CHARCODE_CTRLC;\n        this.aButtonCodeMap['ctrl-o'] = this.CHARCODE_CTRLO;\n\n        /*\n         * This array is used by keyEventSimulate() to lookup a given charCode and convert it to the appropriate\n         * row/col bit combination that the C1P requires.  I assign each supported charCode a 16-bit value, where\n         * the high byte contains the row/col pair (in the high and low nibbles, respectively), and the low byte\n         * contains any required shift-key code.\n         *\n         * For example, an apostrophe (0x27) is an unshifted key on a modern keyboard, but it is a SHIFT-7 on the\n         * C1P keyboard, so when I simulate the 7, I must also simulate a SHIFT (I always choose the LEFT shift\n         * key -- CHARCODE_LSHIFT -- but that choice is completely arbitrary).\n         *\n         * Using charCodes (from keyPress events) proved to be more robust than using keyCodes (from keyDown and\n         * keyUp events), in part because of differences between the C1P keyboard's layout and modern keyboards,\n         * and also because of differences in the way browsers generate the keyDown and keyUp events.  For\n         * example, Safari on iOS devices will not generate up/down events for shift keys, and for other keys,\n         * the up/down events are usually generated after the actual press is complete, and in rapid succession,\n         * which doesn't give the slow C1P virtual machine enough time to detect the key.\n         *\n         * There are still a few times that I call keyEventSimulate() from keyEvent(), and for those occasions,\n         * I create a pseudo-charCode value by adding PSEUDO_CHARCODE (0xE0) to the keyCode value, to avoid any\n         * confusion with real charCodes:\n         *\n         *      CHARCODE_LSHIFT     (originally 0x10, which also looks like CTRL-P, so converted to 0xF0)\n         *      CHARCODE_CTRL       (originally 0x11, which also looks like CTRL-Q, so converted to 0xF1)\n         *      CHARCODE_RSHIFT     (originally 0x12, which also looks like CTRL-R, so converted to 0xF2)\n         *      CHARCODE_SHIFTLOCK  (originally 0x14, which also looks like CTRL-T, so converted to 0xF4)\n         *\n         * Again, as things currently stand, iOS devices will never generate the above charCodes, so any C1P software\n         * that relies detecting on shift-key state changes will not work on those devices.\n         *\n         * For reference purposes, I've left some parenthetical references to corresponding keyCodes in the comments\n         * below.  Relying on keyCodes is problematic, which is why I've tried to eliminate most dependencies on them,\n         * but still, they're all you get on keyDown/keyUp events.\n         */\n        this.aCharCodeMap = [];\n        this.aCharCodeMap[0x31] = 0x7700; this.aCharCodeMap[0x21] = 0x7700 + this.CHARCODE_LSHIFT;  // 1 (0x31) ! (0x31)\n        this.aCharCodeMap[0x32] = 0x7600; this.aCharCodeMap[0x22] = 0x7600 + this.CHARCODE_LSHIFT;  // 2 (0x32) \" (0xDE)\n        this.aCharCodeMap[0x33] = 0x7500; this.aCharCodeMap[0x23] = 0x7500 + this.CHARCODE_LSHIFT;  // 3 (0x33) # (0x33)\n        this.aCharCodeMap[0x34] = 0x7400; this.aCharCodeMap[0x24] = 0x7400 + this.CHARCODE_LSHIFT;  // 4 (0x34) $ (0x34)\n        this.aCharCodeMap[0x35] = 0x7300; this.aCharCodeMap[0x25] = 0x7300 + this.CHARCODE_LSHIFT;  // 5 (0x35) % (0x35)\n        this.aCharCodeMap[0x36] = 0x7200; this.aCharCodeMap[0x26] = 0x7200 + this.CHARCODE_LSHIFT;  // 6 (0x36) & (0x37)\n        this.aCharCodeMap[0x37] = 0x7100; this.aCharCodeMap[0x27] = 0x7100 + this.CHARCODE_LSHIFT;  // 7 (0x37) ' (0xDE)\n        this.aCharCodeMap[0x38] = 0x6700; this.aCharCodeMap[0x28] = 0x6700 + this.CHARCODE_LSHIFT;  // 8 (0x38) ( (0x39)\n        this.aCharCodeMap[0x39] = 0x6600; this.aCharCodeMap[0x29] = 0x6600 + this.CHARCODE_LSHIFT;  // 9 (0x39) ) (0x30)\n        this.aCharCodeMap[0x30] = 0x6500;   // 0\n        this.aCharCodeMap[0x3A] = 0x6400; this.aCharCodeMap[0x2A] = 0x6400 + this.CHARCODE_LSHIFT;  // : (0xBA) * (0x38)\n        this.aCharCodeMap[0x2D] = 0x6300; this.aCharCodeMap[0x3D] = 0x6300 + this.CHARCODE_LSHIFT;  // - (0xBD) = (0xBB)\n      //this.aCharCodeMap[0x00] = 0x6200;   // RUB-OUT (no mapping chosen for this key yet)\n        this.aCharCodeMap[0x2E] = 0x5700; this.aCharCodeMap[0x3E] = 0x5700 + this.CHARCODE_LSHIFT;  // . (0xBE) > (0xBE)\n        this.aCharCodeMap[0x6C] = 0x5600; this.aCharCodeMap[0x4C] = 0x5600 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x5C] = 0x5600 + this.CHARCODE_LSHIFT; // l L \\\n        this.aCharCodeMap[0x6F] = 0x5500; this.aCharCodeMap[0x4F] = 0x5500 + this.CHARCODE_LSHIFT; this.aCharCodeMap[this.CHARCODE_DELETE] = 0x5500 + this.CHARCODE_LSHIFT; // o O DELETE\n        this.aCharCodeMap[this.CHARCODE_LF] = 0x5400;   // LINE-FEED\n        this.aCharCodeMap[this.CHARCODE_CR] = 0x5300;   // RETURN\n        this.aCharCodeMap[0x77] = 0x4700; this.aCharCodeMap[0x57] = 0x4700 + this.CHARCODE_LSHIFT;  // w W\n        this.aCharCodeMap[0x65] = 0x4600; this.aCharCodeMap[0x45] = 0x4600 + this.CHARCODE_LSHIFT;  // e E\n        this.aCharCodeMap[0x72] = 0x4500; this.aCharCodeMap[0x52] = 0x4500 + this.CHARCODE_LSHIFT;  // r R\n        this.aCharCodeMap[0x74] = 0x4400; this.aCharCodeMap[0x54] = 0x4400 + this.CHARCODE_LSHIFT;  // t T\n        this.aCharCodeMap[0x79] = 0x4300; this.aCharCodeMap[0x59] = 0x4300 + this.CHARCODE_LSHIFT;  // y Y\n        this.aCharCodeMap[0x75] = 0x4200; this.aCharCodeMap[0x55] = 0x4200 + this.CHARCODE_LSHIFT;  // u U\n        this.aCharCodeMap[0x69] = 0x4100; this.aCharCodeMap[0x49] = 0x4100 + this.CHARCODE_LSHIFT;  // i I\n        this.aCharCodeMap[0x73] = 0x3700; this.aCharCodeMap[0x53] = 0x3700 + this.CHARCODE_LSHIFT;  // s S\n        this.aCharCodeMap[0x64] = 0x3600; this.aCharCodeMap[0x44] = 0x3600 + this.CHARCODE_LSHIFT;  // d D\n        this.aCharCodeMap[0x66] = 0x3500; this.aCharCodeMap[0x46] = 0x3500 + this.CHARCODE_LSHIFT;  // f F\n        this.aCharCodeMap[0x67] = 0x3400; this.aCharCodeMap[0x47] = 0x3400 + this.CHARCODE_LSHIFT;  // g G\n        this.aCharCodeMap[0x68] = 0x3300; this.aCharCodeMap[0x48] = 0x3300 + this.CHARCODE_LSHIFT;  // h H\n        this.aCharCodeMap[0x6A] = 0x3200; this.aCharCodeMap[0x4A] = 0x3200 + this.CHARCODE_LSHIFT;  // j J\n        this.aCharCodeMap[0x6B] = 0x3100; this.aCharCodeMap[0x4B] = 0x3100 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x5B] = 0x3100 + this.CHARCODE_LSHIFT; // k K [\n        this.aCharCodeMap[0x78] = 0x2700; this.aCharCodeMap[0x58] = 0x2700 + this.CHARCODE_LSHIFT;  // x X\n        this.aCharCodeMap[0x63] = 0x2600; this.aCharCodeMap[0x43] = 0x2600 + this.CHARCODE_LSHIFT;  // c C\n        this.aCharCodeMap[0x76] = 0x2500; this.aCharCodeMap[0x56] = 0x2500 + this.CHARCODE_LSHIFT;  // v V\n        this.aCharCodeMap[0x62] = 0x2400; this.aCharCodeMap[0x42] = 0x2400 + this.CHARCODE_LSHIFT;  // b B\n        this.aCharCodeMap[0x6E] = 0x2300; this.aCharCodeMap[0x4E] = 0x2300 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x5E] = 0x2300 + this.CHARCODE_LSHIFT; // n N ^\n        this.aCharCodeMap[0x6D] = 0x2200; this.aCharCodeMap[0x4D] = 0x2200 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x5D] = 0x2200 + this.CHARCODE_LSHIFT; // m M ]\n        this.aCharCodeMap[0x2C] = 0x2100; this.aCharCodeMap[0x3C] = 0x2100 + this.CHARCODE_LSHIFT;  // , (0xBC) < (0xBC)\n        this.aCharCodeMap[0x71] = 0x1700; this.aCharCodeMap[0x51] = 0x1700 + this.CHARCODE_LSHIFT;  // q Q\n        this.aCharCodeMap[0x61] = 0x1600; this.aCharCodeMap[0x41] = 0x1600 + this.CHARCODE_LSHIFT;  // a A\n        this.aCharCodeMap[0x7A] = 0x1500; this.aCharCodeMap[0x5A] = 0x1500 + this.CHARCODE_LSHIFT;  // z Z\n        this.aCharCodeMap[0x20] = 0x1400;   // SPACE\n        this.aCharCodeMap[0x2F] = 0x1300; this.aCharCodeMap[0x3F] = 0x1300 + this.CHARCODE_LSHIFT;  // / (0xBF) ? (0xBF)\n        this.aCharCodeMap[0x3B] = 0x1200; this.aCharCodeMap[0x2B] = 0x1200 + this.CHARCODE_LSHIFT;  // ; (0xBA) + (0xBB)\n        this.aCharCodeMap[0x70] = 0x1100; this.aCharCodeMap[0x50] = 0x1100 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x40] = 0x1100 + this.CHARCODE_LSHIFT; // p P @\n      //this.aCharCodeMap[0x00]                     = 0x0700;   // REPEAT (no mapping chosen for this key yet)\n        this.aCharCodeMap[this.CHARCODE_CTRL]       = 0x0600;   // CTRL\n        this.aCharCodeMap[this.CHARCODE_ESC]        = 0x0500;   // ESC\n        this.aCharCodeMap[this.CHARCODE_LSHIFT]     = 0x0200;   // LEFT-SHIFT\n        this.aCharCodeMap[this.CHARCODE_RSHIFT]     = 0x0100;   // RIGHT-SHIFT\n        this.aCharCodeMap[this.CHARCODE_SHIFTLOCK]  = 0x0000;   // SHIFT-LOCK\n\n        this.reset();\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     */\n    reset()\n    {\n        this.setModel(this.nDefaultModel);\n\n        /*\n         * The physical (not virtual) state of various shift keys,\n         * with the exception of SHIFT-LOCK, which needs to start in the\n         * \"locked\" position, regardless of the physical CAPS-LOCK state.\n         *\n         * QUESTION: In JavaScript, how do you query initial key states?\n         */\n        this.bitsShift = this.BIT_SHIFTLOCK;\n\n        /*\n         * Every SET bit of bKbdRows represents an enabled row (this convention\n         * is the REVERSE of the C1P hardware, but I prefer it).\n         */\n        this.bKbdRows = 0x00;\n\n        /*\n         * Every SET bit of abKbdCols represents an enabled column; again, this is\n         * the REVERSE of the C1P hardware, but I compensate for that difference with\n         * a quick XOR in updateMemory().\n         *\n         * Like bitsShift, this 8x8 array (8 byte values, each with 8 bits) represents\n         * the physical state of the keyboard, encoded in C1P format; the C1P won't\n         * actually see data this until updateMemory() decides it's time to propagate it.\n         */\n        this.abKbdCols = [this.BIT_SHIFTLOCK,0x00,0x00,0x00,0x00,0x00,0x00,0x00];\n\n        /*\n         * After a new key event has updated abKbdCols, we \"push\" a copy of that\n         * updated keyboard state onto this array. updateMemory() will then \"shift\"\n         * the next copy off, update its own copy (abKbdColsLast), and then propagate\n         * that to the C1P's keyboard memory, once the CPU has had enough time to\n         * process the previous event (see nCyclesThreshold).\n         */\n        this.aKbdStates = [];\n\n        /*\n         * When a key \"down\" is simulated on behalf of some charCode, I save\n         * the timer object responsible for simulating the key \"up\" here, so that\n         * if I detect the actual key going up sooner, I can cancel the timer and\n         * simulate the \"up\" immediately.  Similarly, if another press for the same\n         * key arrives before last one expired (eg, auto-repeat), I need to cancel\n         * the previous timer for that key before setting another.\n         *\n         * NOTE: If this is anything other than an initial reset, then we need to\n         * make sure there are no outstanding timers before we blow the array away.\n         */\n        if (this.aKeyTimers) {\n            for (var i in this.aKeyTimers) {\n                if (isNaN(+i)) continue; // ignore any non-numeric properties, if any\n                if (this.aKeyTimers[i]) clearTimeout(this.aKeyTimers[i]);\n            }\n        }\n        this.aKeyTimers = [];\n        this.prevCharDown = 0;\n        this.prevKeyDown = 0;\n\n        /*\n         * These save the last values written to keyboard memory, so that I can\n         * avoid rewriting the memory if the values haven't changed since the last update.\n         */\n        this.bWriteLast = -1;\n        this.abKbdColsLast = this.abKbdCols;\n\n        /*\n         * Due to the way the C1P scans its keyboard rows (from R0 up to R7 *or* to the\n         * highest row for which a \"down\" key has just been detected), if we get back-to-back\n         * key events for, say, \"I\" and then \"S\", the C1P will see only the \"S\", never the \"I\",\n         * because \"I\" is on a higher row.\n         *\n         * That's why we have aKbdStates, which relies on the following CPU activity variables.\n         */\n        this.nReadsSinceLastEvent = 0;\n        this.nWritesSinceLastEvent = 0;\n        this.nCyclesSinceLastEvent = 0;\n\n        /*\n         * Make sure the auto-injection buffer is empty, too (an injection could have been\n         * in progress on any reset after the first).\n         */\n        this.sInjectBuffer = \"\";\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"esc\", \"ctrl-c\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        /*\n         * I want to bind to the first caller (ie, the Screen), not subsequent ones (eg, the Panel)\n         */\n        if (this.bindings[sBinding] === undefined) {\n            switch(sBinding) {\n            case \"keyDown\":\n                this.bindings[sBinding] = control;\n                control.onkeydown = function(kbd) {\n                    return function(event) {\n                        return kbd.keyEvent(event, true);\n                    };\n                }(this);\n                return true;\n            case \"keyPress\":\n                this.bindings[sBinding] = control;\n                control.onkeypress = function(kbd) {\n                    return function(event) {\n                        return kbd.keyPress(event);\n                    };\n                }(this);\n                return true;\n            case \"keyUp\":\n                this.bindings[sBinding] = control;\n                control.onkeyup = function(kbd) {\n                    return function(event) {\n                        return kbd.keyEvent(event, false);\n                    };\n                }(this);\n                return true;\n            case \"break\":\n                /*\n                 * The BREAK key is unusual: it requires us forcing the equivalent of someone pressing\n                 * our \"Reset\" and \"Run\" buttons.  As things stand, the Computer component is responsible\n                 * for end-user \"reset\" requests, so we can simply arrange to call this.cmp.reset(true).\n                 *\n                 * NOTE: At the risk of making keyPressSimulate() a bit uglier, I also permit BREAK\n                 * there, in case someone wants to \"inject\" the BREAK key; however, if it's followed by\n                 * other injected keys, I'll need to avoid clearing the injection buffer on a reset;\n                 * currently, reset() resets everything.\n                 */\n                this.bindings[sBinding] = control;\n                control.onclick = function(kbd) {\n                    return function(event) {\n                        if (DEBUG) kbd.println(\"keyPressSimulate(break)\");\n                        if (kbd.cmp) kbd.cmp.reset(true);\n                    };\n                }(this);\n                return true;\n            default:\n                if (this.aButtonCodeMap[sBinding] !== undefined) {\n                    this.bindings[sBinding] = control;\n                    control.onclick = function(kbd, sButton, charCode) {\n                        return function(event) {\n                            if (DEBUG) kbd.println(\"keyPressSimulate(\" + sButton + \")\");\n                            if (kbd.cpu) kbd.cpu.setFocus();\n                            return !kbd.keyPressSimulate(charCode);\n                        };\n                    }(this, sBinding, this.aButtonCodeMap[sBinding]);\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.offKbd = start;\n        this.cbKbd = end - start + 1;\n        this.offKbdLimit = this.offKbd + this.cbKbd;\n        if (cpu) {\n            this.cpu = cpu;\n            if (DEBUG) cpu.addReadNotify(start, end, this, this.getByte);\n            cpu.addWriteNotify(start, end, this, this.setByte);\n        }\n        this.setReady();\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} nModel\n     */\n    setModel(nModel)\n    {\n        this.nModel = nModel;\n        /*\n         * Default to Model 600 behavior, where the keyboard status lines are inverted\n         * (ie, a zero bit indicates a key press).\n         */\n        this.bInvert = 0xff;\n        if (this.nModel != 600) {\n            /*\n             * No inversion for model 542\n             */\n            this.bInvert = 0x00;\n            this.println(\"updated keyboard model: \" + this.nModel);\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     *\n     * We make a note of the Computer component, so that we can invoke its reset() method when our simulated\n     * BREAK key is pressed, and we query the Debugger component so that we can use its info() and halt() functions,\n     * which we use to buffer information without adversely affecting timing and then dump later using the Debugger's\n     * \"info\" command.\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            this.cmp = cmp;\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {boolean} [fReady] is assumed to indicate \"ready\" unless EXPLICITLY set to false\n     */\n    setReady(fReady)\n    {\n        this.iOS = Web.isUserAgent(\"iOS\");\n        this.fMobile = (this.iOS || Web.isUserAgent(\"Android\"));\n        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n            this.dbg.message(\"mobile keyboard support: \" + (this.fMobile? \"true\" : \"false\") + \" (\" + window.navigator.userAgent + \")\");\n        }\n        super.setReady();\n    }\n\n    /**\n     * calcReleaseDelay(fRepeat)\n     *\n     * This attempts to scale our default \"release\" delay appropriately for the current CPU speed.\n     *\n     * Note that if the effective CPU speed exceeds 16Mhz, it becomes very difficult to rely on timer-driven key events\n     * (even the shortest available timer delay still gives the CPU too much time, so it thinks that even the briefest key\n     * press represents a held key, resulting in multiple keystrokes).  We deal with this by artificially limiting the top\n     * speed in the CPU component (the current limit for \"fast\" mode is 8Mhz; see CPU.mhzFast)\n     *\n     * @this {C1PKeyboard}\n     * @param {boolean} fRepeat is true if a timeout had already been active for the current key\n     * @return {number}\n     */\n    calcReleaseDelay(fRepeat)\n    {\n        /*\n         * NOTE: This delay affects only the \"up\" delay, not repeat delay, but it's useful to have an initial\n         * \"up\" delay that's sufficiently large to ensure the native machine's auto-repeat behavior cooperates\n         * with the virtual machine's auto-repeat behavior. msReleaseDelay is the initial delay, msReleaseRepeat\n         * is the subsequent delay.\n         *\n         * Unfortunately, with a large initial delay, we need to enable the auto-clear code in the keyEvent()\n         * handler, otherwise doing things like pressing ENTER repeatedly will result in sluggish behavior\n         * (because you can generally press/release/repress keys faster than they will auto-repeat).\n         */\n        var msDelay = (fRepeat? this.msReleaseRepeat: this.msReleaseDelay);\n        if (this.cpu && this.cpu.mhz) {\n            msDelay /= this.cpu.mhz;\n        }\n        return msDelay;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} [notCharCode]\n     */\n    autoClear(notCharCode)\n    {\n        if (this.prevCharDown && (notCharCode === undefined || notCharCode != this.prevCharDown)) {\n            if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n                this.dbg.message(\"autoClear(\" + Str.toHexByte(this.prevCharDown) + \")\");\n            }\n\n            clearTimeout(this.aKeyTimers[this.prevCharDown]);\n            this.keyEventSimulate(this.prevCharDown, false, this.SIMCODE_AUTOCLEAR);\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {string} sKeyCodes\n     * @param {number} [msDelay] is an optional injection delay (default is msInjectDelay)\n     */\n    injectKeys(sKeyCodes, msDelay)\n    {\n        this.sInjectBuffer = sKeyCodes;\n        if (DEBUG) this.log(\"injectKeys(\" + this.sInjectBuffer.split(\"\\n\").join(\"\\\\n\") + \")\");\n        this.injectKeysFromBuffer(msDelay || this.msInjectDelay);\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} msDelay is the delay between injected keys\n     */\n    injectKeysFromBuffer(msDelay)\n    {\n        if (this.sInjectBuffer.length > 0) {\n            var ch = this.sInjectBuffer.charCodeAt(0);\n            /*\n             * I could require all callers to supply CRs instead of LFs, but this is friendlier.\n             */\n            if (ch == 0x0a)\n                ch = 0x0d;\n            /*\n             * Also, if upper-case characters are being injected, convert them to lower-case, and rely\n             * on the virtual SHIFT-LOCK remaining locked for the duration; otherwise, we'd have to simulate\n             * SHIFT key presses around every character (or around the entire set of characters) as well.\n             *\n             * UPDATE: Even though keyPressSimulate() currently has some code to do this automatically now,\n             * it's really intended as a work-around for a SHIFT-related problem on iOS devices only, so\n             * we can't rely on that in the general case.\n             */\n            if (ch >= 0x41 && ch <= 0x5A)\n                ch += 0x20;\n            this.sInjectBuffer = this.sInjectBuffer.substr(1);\n            this.keyPressSimulate(ch);\n        }\n        if (this.sInjectBuffer.length > 0) {\n            setTimeout(function(kbd) { return function() {kbd.injectKeysFromBuffer(msDelay);}; }(this), msDelay);\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {Object} event\n     * @param {boolean} fDown is true if called for a keyDown event, false if called for a keyUp event\n     * @return {boolean} true to pass the event along, false to consume it\n     */\n    keyEvent(event, fDown)\n    {\n        var fPass;\n        var fAutoClear = !fDown;\n        var keyCode = event.keyCode;\n\n        if (fDown) this.prevKeyDown = keyCode;\n\n        if (keyCode == this.CHARCODE_LSHIFT - this.PSEUDO_CHARCODE) {\n            this.bitsShift &= ~this.BIT_LSHIFT;\n            if (fDown) this.bitsShift |= this.BIT_LSHIFT;\n            keyCode += this.PSEUDO_CHARCODE;\n            fAutoClear = false;\n        }\n        else\n        if (keyCode == this.CHARCODE_RSHIFT - this.PSEUDO_CHARCODE) {\n            this.bitsShift &= ~this.BIT_RSHIFT;\n            if (fDown) this.bitsShift |= this.BIT_RSHIFT;\n            keyCode += this.PSEUDO_CHARCODE;\n            fAutoClear = false;\n        }\n        else\n        if (keyCode == this.CHARCODE_CTRL - this.PSEUDO_CHARCODE) {\n            this.bitsShift &= ~this.BIT_CTRL;\n            if (fDown) this.bitsShift |= this.BIT_CTRL;\n            keyCode += this.PSEUDO_CHARCODE;\n            fAutoClear = false;\n        }\n        else\n        if (keyCode == this.CHARCODE_SHIFTLOCK - this.PSEUDO_CHARCODE) {\n            /*\n             * FYI, this generates a \"down\" event ONLY when getting locked, and an \"up\" event ONLY\n             * when getting unlocked--which is exactly what I want, even though that may seem a little\n             * counter-intuitive (since the key itself actually went down AND up for each event).\n             *\n             * Moreover, since most people do NOT have CAPS-LOCK enabled, whereas the C1P needs it\n             * enabled by default, we invert fDown, so that if the user enables CAPS-LOCK for some\n             * reason, we treat is as *disabling* SHIFT-LOCK, and vice versa.\n             */\n            fDown = !fDown;\n            this.bitsShift &= ~this.BIT_SHIFTLOCK;\n            if (fDown) this.bitsShift |= this.BIT_SHIFTLOCK;\n            keyCode += this.PSEUDO_CHARCODE;\n            fAutoClear = false;\n        }\n        else\n        if (keyCode == this.KEYCODE_COMMAND) {\n            /*\n             * Avoid interfering with useful Browser key commands, like COMMAND-Q, COMMAND-T, etc.\n             */\n            this.bitsShift &= ~this.BIT_COMMAND;\n            if (fDown) this.bitsShift |= this.BIT_COMMAND;\n            fAutoClear = false;\n            fPass = true;\n        }\n        else\n        if (keyCode == this.KEYCODE_TAB) {\n            /*\n             * If I don't consume TAB on the \"down\" event, then that's all I'll see, because the\n             * browser will see it and give focus to the next control. But the \"down\" side is that\n             * that no \"press\" event will be generated.  This puts it in the same category as ESC,\n             * which also generates \"down\" and \"up\" events (LOTS of \"down\" events for that matter),\n             * but no \"press\" event.  However, the C1P has no TAB key, so it's safe to completely ignore.\n             */\n            fPass = fAutoClear = false;\n        }\n        else\n        if (keyCode == this.KEYCODE_ESC || keyCode == this.KEYCODE_DELETE) {\n            /*\n             * I don't get keyPress events for ESC (why?) and I never want the browser to act on DELETE\n             * (which does double-duty as the \"Back\" button and leaves the current page), so I have to\n             * simulate them now.\n             *\n             * Note that I call the \"press\" simulate method and NOT the \"event\" simulate method, because\n             * the former takes care of simulating both individual \"down\" and \"up\" events.\n             */\n            if (DEBUG && DEBUGGER && keyCode == this.KEYCODE_ESC && this.dbg) this.dbg.halt();\n            fPass = (fDown? !this.keyPressSimulate(keyCode) : false);\n        }\n        else {\n            /*\n             * Pass on everything else; I'll take care of this key at the keyPress stage, not the\n             * the keyDown or keyUp stage.\n             */\n            fPass = true;\n            /*\n             * At this point, I have a difficult choice to make: leave fAutoClear true for any remaining\n             * \"up\" events, so that keys will repeat immediately when released/pressed repeatedly (most\n             * noticeable with the Enter key), or set fAutoClear to false to ensure that polling apps have\n             * enough time to see every key press.\n             *\n             * I've decided that the former is more important than the latter, so if polling apps are still\n             * missing keystrokes, then perhaps nCyclesThreshold needs to be supplemented in some way.\n             *\n             *      fAutoClear = false;\n             */\n        }\n\n        if (fAutoClear) {\n            /*\n             * When you use a command like COMMAND-T, I see the COMMAND key going down, but not going up,\n             * so I think the COMMAND key is still down and ignore all input; to easily get out of that state,\n             * I clear our internal BIT_COMMAND whenever I see ANY key go up (well, ALMOST any key; cases\n             * above that explicitly clear fAutoClear -- such as the COMMAND key itself -- are exceptions\n             * to the rule).\n             */\n            this.bitsShift &= ~this.BIT_COMMAND;\n            /*\n             * I don't reliably get keyDown/keyUp events for all keys on all devices, but for those devices that\n             * I DO, it seems like a good idea to cancel any pending key \"up\" simulation on receipt of the actual\n             * keyUp event.\n             *\n             * However, the following code is problematic for Safari on iOS devices, which as noted above, doesn't\n             * generate keyDown/keyUp events until after the press operation is complete, and then they are generated\n             * in rapid succession, which doesn't give the C1P enough time to detect the key.  So I simply don't do\n             * this on iOS devices.\n             */\n            if (!this.fMobile && keyCode == this.prevKeyDown) this.autoClear();\n        }\n\n        if (fPass === undefined) {\n            fPass = !this.keyEventSimulate(keyCode, fDown, this.SIMCODE_KEYEVENT);\n        }\n\n        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n            this.dbg.message(/*(fDown?\"\\n\":\"\") +*/ \"key\" + (fDown?\"Down\":\"Up\") + \"(\" + Str.toHexByte(keyCode) + \"): \" + (fPass? \"pass\" : \"consume\"));\n        }\n        return fPass;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {Object} event\n     * @return {boolean} true to pass the event along, false to consume it\n     *\n     * We've stopped relying on keyPress for keyboard emulation purposes, but it's still handy to hook and monitor\n     * when debugging.\n     */\n    keyPress(event)\n    {\n        var fPass = true;\n        /*\n         * Browser-independent charCode extraction...\n         */\n        event = event || window.event;\n        var charCode = event.which || event.keyCode;\n\n        /*\n         * Let's stop any injection currently in progress, too\n         */\n        this.sInjectBuffer = \"\";\n\n        if (this.bitsShift & this.BIT_COMMAND)\n            this.bitsShift &= ~this.BIT_COMMAND;\n        else\n            fPass = !this.keyPressSimulate(charCode);\n\n        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n            this.dbg.message(\"keyPress(\" + Str.toHexByte(charCode) + \"): \" + (fPass? \"pass\" : \"consume\"));\n        }\n        return fPass;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} charCode\n     * @return {boolean} true if successfully simulated, false if unrecognized/unsupported key\n     */\n    keyPressSimulate(charCode)\n    {\n        var fSimulated = false;\n        if (charCode == this.CHARCODE_BREAK) {\n            /*\n             * The BREAK key is not wired up to the keyboard like the other keys are, but we simulate\n             * it here, so that it can be injected like any other key.\n             */\n            if (this.cmp) {\n                this.cmp.reset(true);\n                fSimulated = true;\n            }\n        }\n        else {\n            /*\n             * WARNING: The next line is why you cannot use SHIFT-N, SHIFT-O, SHIFT-P, etc. But without it,\n             * iOS devices with the annoying \"autocapitalization\" feature enabled make the keyboard unusable\n             * by default.  The trade-off is: either require all iOS users to first tap the shift key to turn\n             * \"autocapitalization\" off, or lose the ability to type any of the special shifted alphabetic keys.\n             * I choose the latter, because I have friendlier aliases already defined for those keys (eg,\n             * ^, DELETE, and @).\n             *\n             * Furthermore, by doing this for iOS (and Android) devices ONLY, other platforms retain the ability\n             * to use those special key combos.\n             */\n            if (this.fMobile) {\n                if (charCode >= 0x41 && charCode <= 0x5A)\n                    charCode += 0x20;\n            }\n\n            /*\n             * Auto-clear any previous down key EXCEPT for charCode (because it may be held and repeating).\n             */\n            this.autoClear(charCode);\n\n            if (this.keyEventSimulate(charCode, true, this.SIMCODE_KEYPRESS)) {\n                /*\n                 * If CPU speed is unlimited, then we switch to an alternate approach, which is to immediately\n                 * queue a \"release\" event as well.  The problem with the original timer-based approach at high\n                 * speeds is that the the CPU may get lucky and execute a LOT of instructions between delivery\n                 * of the keyPress event and the \"keyTimeout\" event. In that case, even enabling keyboard polling\n                 * detection in updateMemory() won't entirely help -- although we do that, too -- because JavaScript\n                 * events are delivered synchronously, so it may simply take too long for the \"keyTimeout\" event\n                 * to arrive.\n                 *\n                 * Why don't we ALWAYS do this? Because in the normal case (SPEED_SLOW, and even SPEED_FAST) we want\n                 * to faithfully simulate how long a key is held, so that features like auto-repeat work properly.\n                 * You'll notice in the SPEED_MAX case, holding a key no longer has any effect; even though multiple\n                 * keyPress events WILL arrive, if we simulate a release immediately after each one, then repeat\n                 * is defeated.  Also, the keyboard polling detection code in updateMemory() doesn't work well for\n                 * all apps.\n                 */\n                if (this.cpu.speed == this.cpu.SPEED_MAX) {\n                    this.keyEventSimulate(charCode, false, this.SIMCODE_KEYRELEASE);\n                }\n                else {\n                    var fRepeat = false;\n                    if (this.aKeyTimers[charCode]) {\n                        clearTimeout(this.aKeyTimers[charCode]);\n                        fRepeat = true;\n                    }\n                    var msDelay = this.calcReleaseDelay(fRepeat);\n                    this.aKeyTimers[this.prevCharDown = charCode] = setTimeout(function(kbd) { return function() {kbd.keyEventSimulate(charCode, false, kbd.SIMCODE_KEYTIMEOUT);}; }(this), msDelay);\n                    if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n                        this.dbg.message(\"keyPressSimulate(\" + Str.toHexByte(charCode) + \"): setTimeout()\");\n                    }\n                }\n                fSimulated = true;\n            }\n        }\n        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n            this.dbg.message(\"keyPressSimulate(\" + Str.toHexByte(charCode) + \"): \" + (fSimulated? \"true\" : \"false\"));\n        }\n        return fSimulated;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} charCode\n     * @param {boolean} fDown\n     * @param {number} simCode indicates the origin of the event\n     * @return {boolean} true if successfully simulated, false if unrecognized/unsupported key\n     */\n    keyEventSimulate(charCode, fDown, simCode)\n    {\n        var fSimulated = false;\n        if (!fDown) {\n            this.aKeyTimers[charCode] = null;\n            if (this.prevCharDown == charCode) this.prevCharDown = 0;\n        }\n        var bShift = 0;\n        var bCode = this.aCharCodeMap[charCode];\n        if (bCode === undefined) {\n            /*\n             * Perhaps we're dealing with a CTRL variation of an alphabetic key; this won't\n             * affect non-CTRL-key combos like CR or LF, because they're defined in aCharCodeMap,\n             * and this bit of code relieves us from having to explicitly define every CTRL-letter\n             * possibility in aCharCodeMap. However, CTRL-anything-else is a different matter.\n             */\n            if (charCode >= 0x01 && charCode <= 0x1A) {\n                charCode += 0x40;\n                bShift = this.CHARCODE_CTRL;\n            }\n            bCode = this.aCharCodeMap[charCode];\n        }\n        if (bCode !== undefined) {\n            var iRow = bCode >> 12;\n            var iCol = (bCode >> 8) & 0xf;\n            if (!bShift) bShift = bCode & 0xff;\n            if (fDown) {\n                this.abKbdCols[iRow] |= 1 << iCol;\n                if (bShift == this.CHARCODE_CTRL)\n                    this.abKbdCols[0] |= this.BIT_CTRL;\n                else\n                if (bShift == this.CHARCODE_LSHIFT)\n                    this.abKbdCols[0] |= this.BIT_LSHIFT;\n                else\n                if (bShift == this.CHARCODE_RSHIFT)\n                    this.abKbdCols[0] |= this.BIT_RSHIFT;\n                else\n                    this.abKbdCols[0] &= ~this.BITS_SIMULATE;\n            }\n            else {\n                this.abKbdCols[iRow] &= ~(1 << iCol);\n                this.abKbdCols[0] &= ~this.BITS_SIMULATE;\n                this.abKbdCols[0] |= (this.bitsShift & this.BITS_SIMULATE);\n            }\n            var fPropagate = (simCode == this.SIMCODE_KEYPRESS && !this.aKbdStates.length);\n            this.aKbdStates.push(this.abKbdCols.slice());\n            this.updateMemory(fPropagate);\n            fSimulated = true;\n        }\n        if (DEBUG && this.dbg) this.dbg.info(\"keyEventSimulate(\" + Str.toHexByte(charCode) + \",\" + (fDown?\"down\":\"up\") + \",\" + this.aSimCodeDescs[simCode] + \"): \" + (fSimulated? \"true\" : \"false\"));\n        return fSimulated;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} addr\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n     *\n     * NOTE: As long as we rely on the CPU processing a certain number of cycles (nCyclesThreshold) before\n     * propagating the next kbd state, and not how many reads and/or writes the CPU has performed, we could\n     * eliminate the overhead of this read-notification handler.\n     *\n     * It's useful for diagnostic purposes, which is why it's still here.\n     */\n    getByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this read (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (DEBUG) {\n            if (addrFrom !== undefined) {\n                this.nReadsSinceLastEvent++;\n                if (DEBUG && this.dbg) this.dbg.info(\"reading kbd \" + Str.toHexWord(addr) + \" @\" + this.cpu.getCycles() + \" cycles\");\n            }\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} addr\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to write the specified addr)\n     *\n     * NOTE: Ordinarily, I wouldn't allow Debugger writes (addrFrom === undefined) to interfere with the simulated\n     * hardware state, but for now, I find it useful to be able to prod the simulation code directly from the Debugger.\n     */\n    setByte(addr, addrFrom)\n    {\n        var b = this.cpu.getByte(addr);\n        this.bKbdRows = b ^ this.bInvert;\n        this.nWritesSinceLastEvent++;\n        this.updateMemory(false, addr, b);\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {boolean} fPropagate is true to propagate immediately, false to use normal propagation\n     * @param {number} [addr] is the memory address to update; default is the entire memory range\n     * @param {number} [bWrite] is the value of any immediately preceding write, or undefined if none\n     *\n     * Update emulated keyboard memory.  By updating the keyboard memory whenever it's written to,\n     * as well as whenever a key is pressed or released, I avoid the hit of a read-notification handler.\n     * Besides, read-notification handlers are called only AFTER the read has been performed, so it\n     * would be too late to update the memory at that point.\n     *\n     * WARNING: There is a slight risk of an application reading from a different keyboard memory address\n     * than it just wrote to.  That would be legal, but very odd, and we save valuable time by not updating\n     * every other byte in the entire memory range every time a different keyboard \"row\" is selected.\n     */\n    updateMemory(fPropagate, addr, bWrite)\n    {\n        /*\n         * First, we determine if it's time for event propagation...\n         */\n        var nCycles = this.cpu.getCycles();\n\n        /*\n         * Monitoring the C1P's keyboard polling activity is problematic, because not all apps monitor\n         * the keyboard in the same way.  It's better to simply wait for a certain amount of CPU activity to\n         * occur (nCyclesThreshold); it's more reliable and it scales well, because it's not affected by\n         * how many cycles we're executing in real time.  The trick is finding a value for nCyclesThreshold\n         * that works well across the board.\n         */\n        if (!fPropagate) {\n            if (this.cpu.speed == this.cpu.SPEED_MAX)\n                fPropagate = (addr !== undefined && this.nWritesSinceLastEvent >= 32);\n            else {\n                /*\n                 * We have to handle the delta being less than zero, in case the user changed the speed, thereby\n                 * resetting the cycle count returned by getCycles().\n                 */\n                var nCycleDelta = nCycles - this.nCyclesSinceLastEvent;\n                fPropagate = (nCycleDelta < 0 || nCycleDelta >= this.nCyclesThreshold);\n            }\n        }\n\n        /*\n         * Next, we propagate any buffered state (in abKbdStates) as appropriate\n         */\n        if (fPropagate) {\n            var abKbdCols = this.aKbdStates.shift();\n            if (abKbdCols !== undefined) {\n                if (DEBUG && this.dbg) this.dbg.info(\"kbd update @\" + nCycles + \" cycles, \" + this.nWritesSinceLastEvent + \" writes\");\n                this.abKbdColsLast = abKbdCols;\n            }\n            this.nReadsSinceLastEvent = this.nWritesSinceLastEvent = 0;\n            this.nCyclesSinceLastEvent = nCycles;\n        }\n        /*\n         * Then we calculate the value (which may or may not have just been propagated),\n         * based on the currently selected keyboard row(s) (bKbdRows).\n         */\n        var b = 0;\n        for (var iRow=0; iRow < 8; iRow++) {\n            if (!(this.bKbdRows & (1 << iRow)))\n                continue;\n            b |= this.abKbdColsLast[iRow];\n        }\n        /*\n         * Now invert all the bits, since I SET the column bit of an \"active\" key,\n         * whereas the C1P Model 600 keyboard expects \"active\" column bits to be CLEAR.\n         */\n        b ^= this.bInvert;\n\n        if (addr !== undefined) {\n            this.abMem[addr] = b;\n        }\n        else {\n            addr = this.offKbd;\n            if (b != this.bWriteLast) {\n                for (var offset=addr; offset < this.offKbdLimit; offset++)\n                    this.abMem[offset] = b;\n            }\n        }\n        this.bWriteLast = b;\n        if (DEBUG && this.dbg) this.dbg.info(\"updating kbd \" + Str.toHexWord(addr) + \" with \" + Str.toHexByte(b) + (bWrite !== undefined? (\" following write \" + Str.toHexByte(bWrite)) : \"\") + \" @\" + nCycles + \" cycles\");\n    }\n\n    /**\n     * isShift()\n     *\n     * @this {C1PKeyboard}\n     * @param {number} charCode\n     * @return {boolean}\n     *\n     isShift(charCode)\n     {\n         return charCode == this.CHARCODE_LSHIFT || charCode == this.CHARCODE_RSHIFT || charCode == this.CHARCODE_CTRL || charCode == this.CHARCODE_SHIFTLOCK;\n     }\n     */\n\n    /**\n     * C1PKeyboard.init()\n     *\n     * This function operates on every HTML element of class \"keyboard\", extracting the\n     * JSON-encoded parameters for the C1PKeyboard constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PKeyboard component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeKbd = Component.getElementsByClass(document, C1PJS.APPCLASS, \"keyboard\");\n        for (var iKbd=0; iKbd < aeKbd.length; iKbd++) {\n            var eKbd = aeKbd[iKbd];\n            var parmsKbd = Component.getComponentParms(eKbd);\n            var kbd = new C1PKeyboard(parmsKbd);\n            Component.bindComponentControls(kbd, eKbd, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize every Keyboard module on the page.\n */\nWeb.onInit(C1PKeyboard.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/video.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PVideo extends Component {\n    /**\n     * C1PVideo(parmsVideo, canvas, context, imgChars)\n     *\n     * The Video component can be configured with the following (parmsVideo) properties:\n     *\n     *      model: model number (one of: 540 or 600; 600 is the default)\n     *      screenWidth: width of the screen window, in pixels\n     *      screenHeight: height of the screen window, in pixels\n     *      charCols: number of character columns\n     *      charRows: number of character rows\n     *      charWidth: width of charSet characters, in pixels (default is 0)\n     *      charHeight: height of charSet characters, in pixels (default is 0)\n     *      charSet: path to image (eg, PNG) file that defines the character set\n     *      screenColor: background color of the screen window (default is black)\n     *\n     * The Video object assumes that the video buffer is organized such that offset 0 is mapped\n     * to the left-most column and top-most row (col=0,row=0), offset 1 is (1,0), offset 2\n     * is (2,0), and so on.\n     *\n     * The Video object initially contains no underlying video buffer; memory for the buffer\n     * must be given to it by the Computer object.  We allocate a separate buffer, called\n     * the screen buffer, into which we periodically copy the contents of the video buffer\n     * via updateScreen(); any differences between the two buffers are then rendered in the\n     * associated window, via updateWindow().\n     *\n     * When updateScreen() finds a byte in the screen buffer must be redisplayed, it converts\n     * the offset of that byte into a (col,row) character position for the updateWindow() function,\n     * which then converts (col,row) into (x,y) pixel offsets within the underlying canvas.\n     *\n     * Regarding the C1P (aka Model 600): The C1P has a 1K video buffer located at 0xD000-0xD3FF.\n     * The ROM draws the initial \"D/C/W/M ?\" prompt at the \"bottom\" of the video buffer at location\n     * 0xD365. That row really begins at 0xD360, but the C1P \"indents\" everything by 5 columns due\n     * to the lack of a \"guard band feature.\"  Similarly, BASIC defaults to a width of 24 columns\n     * avoid display problems near the right edge.  BASIC will let you choose a width SMALLER than\n     * 24 but not larger. So, while the video buffer supports a theoretical maximum of 32 rows x 32\n     * columns, the practical maximum is 25 rows x 24 columns; the last 4 rows of the video buffer\n     * are never used, and while content DOES scroll through the top 3 lines of the buffer, it should\n     * never be assumed that you can see the top 3 lines.\n     *\n     * This is partially confirmed by the \"C1P Character Graphics Reference Manual\", p3, which says\n     * that the \"the visible character field consists of 25 lines of 25 columns\" and that the \"first\n     * visible character in the upper left of the screen is accessed via address 53379,\" or 0xD083.\n     * However, they were wrong about both the number of columns and the first visible character.\n     *\n     * They probably meant 0xD085, because as mentioned earlier, the C1P indents every row by 5\n     * characters, not 3.  But that's not correct either, because the difference between 0xD365\n     * (where the bottom line starts) and 0xD085 is 0x2E0, or 736.  736 divided by 32 equals 23;\n     * add the bottom row, and that would give you 24 visible rows, not 25.  Since we now have\n     * screenshots of a C1P monitor displaying 25 rows (courtesy of Stephan Mhlstrasser), C1Pjs\n     * now assumes that only the first 3 lines are not visible, and that the address of the first\n     * visible character is actually 0xD065 (53349), yielding 25 visible rows.\n     *\n     * All of this explains why we now use setDimensions(iRowTop=3, nRowsVisible=25) instead of\n     * setDimensions(iRowTop=4, nRowsVisible=24) for the Model 600.\n     *\n     * Model 540 Video Board vs. Model 600 \"Superboard II\"\n     * ---------------------------------------------------\n     * This emulation was originally written for the Model 600 \"Superboard II\" (eg, Challenger 1P).\n     * Support for the Model 540 video board (as used in the Challenger II-4P and II-8P) was added\n     * later.\n     *\n     * NOTE: When Model 540 video emulation is enabled, Model 542 keyboard emulation must also be\n     * enabled, because the former always came with the latter keyboard interface; this is why when\n     * we call this.setModel(540), we must also notify the Keyboard via kbd.setModel(542).\n     *\n     * Key features/differences of the Model 540 video board include:\n     *\n     *      2K (8 pages) of video memory located at 0xD000-0xD7FF\n     *      Two display modes: 32 rows x 64 cols (default on power up), and 32 rows x 32 cols\n     *      64 bytes per screen row, regardless which display mode is selected\n     *      The following options can be selected via WRITE to port address 0xDE00:\n     *          Bit 0: clear to enable 32/64 mode (default on power up), set to enable 32/32\n     *          Bit 1: 1=tone on (542 keyboard)\n     *          Bit 2: 1=color on (Rev. B only?)\n     *          bit 3: 1=enable 38-40Khz AC Home control output (Rev. B only?)\n     *      Video timing counter status via READ from port address 0xDE00:\n     *          Bit 7: 0 for 1/120 second, then 1 for 1/120 second, based on video clock (60Hz)\n     *\n     * @this {C1PVideo}\n     * @param {Object} parmsVideo\n     * @param {HTMLCanvasElement} canvas\n     * @param {CanvasRenderingContext2D} context\n     * @param {HTMLImageElement} imgChars\n     */\n    constructor(parmsVideo, canvas, context, imgChars)\n    {\n        super(\"C1PVideo\", parmsVideo);\n\n        this.nDefaultModel = parmsVideo['model'];\n        this.nDefaultCols = parmsVideo['charCols'];\n        this.nDefaultRows = parmsVideo['charRows'];\n\n        this.cxScreen = parmsVideo['screenWidth'];\n        this.cyScreen = parmsVideo['screenHeight'];\n\n        /*\n         * These (source) character dimensions are tentative, and may not even be provided,\n         * but they will become definitive once imgChars has finished loading and setReady() is called.\n         */\n        this.cxChar = parmsVideo['charWidth'];\n        this.cyChar = parmsVideo['charHeight'];\n\n        /*\n         * This is a preliminary call to setDimensions(), to initialize default screen buffer and\n         * window dimensions.  A more extensive call to setDimensions() will take place when setModel()\n         * is called later, from reset() and possibly via the tripGuard() handler.\n         *\n         * This preliminary call merely establishes a default screen buffer size, so that when\n         * setBuffer() is called, it's able to verify the assigned address space is at least as big\n         * as the screen buffer.\n         */\n        this.setDimensions();\n\n        this.canvasScreen = canvas;\n        this.contextScreen = context;\n        this.imgChars = imgChars;\n\n        /*\n         * Support for disabling (or, less commonly, enabling) image smoothing, which all browsers\n         * seem to support now (well, OK, I still have to test the latest MS Edge browser), despite\n         * it still being labelled \"experimental technology\".  Let's hope the browsers standardize\n         * on this.  I see other options emerging, like the CSS property \"image-rendering: pixelated\"\n         * that's apparently been added to Chrome.  Sigh.\n         */\n        var i, sEvent, asWebPrefixes = ['', 'moz', 'ms', 'webkit'];\n        var fSmoothing = parmsVideo['smoothing'];\n        var sSmoothing = Web.getURLParm('smoothing');\n        if (sSmoothing) fSmoothing = (sSmoothing == \"true\");\n        if (fSmoothing != null) {\n            for (i = 0; i < asWebPrefixes.length; i++) {\n                sEvent = asWebPrefixes[i];\n                if (!sEvent) {\n                    sEvent = 'imageSmoothingEnabled';\n                } else {\n                    sEvent += 'ImageSmoothingEnabled';\n                }\n                if (this.contextScreen[sEvent] !== undefined) {\n                    this.contextScreen[sEvent] = fSmoothing;\n                    break;\n                }\n            }\n        }\n\n        /*\n         * QUESTION: Does this video port exist only on the Model 540?\n         */\n        this.addrVideoPort = 0xDE00;        // WARNING: Hard-coded port address -JP\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {boolean} [fPowerOn] is true for the initial reset, so that we have\n     * the option of rendering \"random\" graphic characters, just like the real machine would do.\n     */\n    reset(fPowerOn)\n    {\n        this.setModel(this.nDefaultModel);\n\n        if (this.abMem) {\n            /*\n             * Let's treat every reset like a power-cycle, just for fun.\n             * If you don't think that's fun, then simply remove the next line.\n             *\n                fPowerOn = true;\n             */\n            for (var offset = this.offVideo; offset < this.offVideoLimit; offset++) {\n                var b = (fPowerOn? Math.floor(Math.random() * 256) : 0x20);\n\n                this.abMem[offset] = b;\n            }\n        }\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"refresh\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        switch(sBinding) {\n        case \"refresh\":\n            this.bindings[sBinding] = control;\n            control.onclick = function(video) {\n                return function() {\n                    if (DEBUG) video.println(\"refreshScreen()\");\n                    video.initScreen();\n                    video.updateScreen();\n                };\n            }(this);\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.offVideo = start;\n        this.cbVideo = end - start + 1;\n        this.offVideoLimit = this.offVideo + this.cbVideo;\n\n        if (cpu) {\n            this.cpu = cpu;\n            if (this.addrVideoPort !== undefined) {\n                cpu.addReadNotify(this.addrVideoPort, this.addrVideoPort, this, this.getByte);\n                cpu.addWriteNotify(this.addrVideoPort, this.addrVideoPort, this, this.setByte);\n            }\n        }\n        this.reset(true);\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number|undefined} [nCols] (default is nDefaultCols)\n     * @param {number|undefined} [nRows] (default is nDefaultRows)\n     * @param {number|undefined} [iRowTop] (eg, 4; default is 0)\n     * @param {number|undefined} [nRowsVisible] (eg, 24; default is nRows)\n     */\n    setDimensions(nCols, nRows, iRowTop, nRowsVisible)\n    {\n        this.nCols = (nCols !== undefined? nCols : this.nDefaultCols);\n        this.nRows = (nRows !== undefined? nRows : this.nDefaultRows);\n        this.cbScreen = this.nCols * this.nRows;\n        this.offVideoLimit = this.offVideo + this.cbScreen;\n        /*\n         * Set the first visible row and total visible rows next\n         */\n        this.iRowTop = (iRowTop !== undefined? iRowTop : 0);\n        this.nRowsVisible = (nRowsVisible !== undefined? nRowsVisible : nRows);\n        this.setDrawingDimensions();\n    }\n\n    /**\n     * @this {C1PVideo}\n     *\n     * cxScreen and cyScreen give us the overall dimensions of the destination surface.  Dividing that by the number of\n     * columns and rows yields a target cell size (cxCharDst,cyCharDst), which may or may not map 1-1 to the source cell size\n     * (cxChar,cyChar).\n     */\n    setDrawingDimensions()\n    {\n        this.cxCharDst = Math.floor(this.cxScreen / this.nCols);\n        this.cyCharDst = Math.floor(this.cyScreen / this.nRowsVisible);\n    }\n\n    /**\n     * @this {C1PVideo}\n     */\n    setFocus()\n    {\n        this.canvasScreen.focus();\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} nModel\n     */\n    setModel(nModel)\n    {\n        this.nModel = nModel;\n        /*\n         * Default to model 600 behavior (1K video buffer);\n         * the only other supported model is 540 (2K video buffer).\n         */\n        if (this.nModel == 600) {\n            this.setDimensions(this.nDefaultCols, this.nDefaultRows, 3, 25);\n            if (this.cbScreen == 1024 && this.cpu) {\n                /*\n                 * NOTE: We deliberately set the guard address to the LAST byte of the 2K\n                 * buffer range, not the FIRST byte, which has the same effect but with the\n                 * added benefit of deferring any screen update until after the \"Model 540\"\n                 * screen initialization code has completely blanked the entire 2K buffer,\n                 * avoiding a brief flicker of unsightly characters.\n                 */\n                this.addrGuard = this.offVideoLimit + this.cbScreen - 1;\n                this.cpu.addWriteNotify(this.addrGuard, this.addrGuard, this, this.tripGuard);\n            }\n        }\n        else {\n            this.println(\"updated video model: \" + this.nModel);\n            this.setDimensions(64, 32);\n        }\n        this.initScreen();\n        this.updateScreen();\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        /*\n         * NOTE: No one should be calling power(true) before first checking isReady(), but we check\n         * it ourselves, too.  This also means that updateScreen() need check only fPower and not isReady(),\n         * since we guarantee that the former implies the latter.\n         */\n        if (fOn && !this.flags.powered && this.isReady()) {\n            this.flags.powered = true;\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n            /*\n             * If we have an associated keyboard, then ensure that the keyboard will be notified whenever\n             * the canvas gets focus and receives input.\n             *\n             * Also, when simulating a Model 540 video board, we need to access to the Keyboard component due\n             * to some shared I/O responsibilities; ie, bit 1 of the video control port at 0xDE00 enables whatever\n             * tone has been selected via the keyboard frequency port at 0xDF01 (frequency == 49152/n, where n\n             * is the value stored at 0xDF01).\n             */\n            this.kbd = cmp.getComponentByType(\"keyboard\");\n            if (this.kbd) {\n                this.kbd.setBinding(\"canvas\", \"keyDown\", this.canvasScreen);\n                this.kbd.setBinding(\"canvas\", \"keyPress\", this.canvasScreen);\n                this.kbd.setBinding(\"canvas\", \"keyUp\", this.canvasScreen);\n            }\n        }\n        else\n        if (!fOn && this.flags.powered) {\n            this.flags.powered = false;\n            /*\n             * This is where we would add some method of blanking the display, without the disturbing the video\n             * buffer contents, and blocking all further updates to the display.\n             */\n        }\n    }\n\n    /**\n     * cxChar and cyChar are the source cell size.  Originally, those values came strictly from the parmsVideo\n     * 'charWidth' and 'charHeight' properties.  Now, if those aren't defined (which is normally the case now),\n     * then we infer the source cell size from the dimensions of imgChars, which is expected to be a 16x16 array of\n     * character bitmaps.  We could be even more flexible, by allowing imgChars to be any rectangular dimension\n     * (eg, 1x256) as long as we can assume it contains exactly 256 characters, but there's no need to get carried away.\n     *\n     * @this {C1PVideo}\n     * @param {boolean} [fReady] is assumed to indicate \"ready\" unless EXPLICITLY set to false\n     */\n    setReady(fReady)\n    {\n        if (!this.cxChar) this.cxChar = Math.floor(this.imgChars.width / 16);\n        if (!this.cyChar) this.cyChar = Math.floor(this.imgChars.height / 16);\n        super.setReady();\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} addr (ie, addrVideoPort)\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n     *\n     * NOTE: Ordinarily, I wouldn't allow Debugger writes (addrFrom === undefined) to interfere with the simulated\n     * hardware state, but for now, I find it useful to be able to prod the simulation code directly from the Debugger.\n     */\n    getByte(addr, addrFrom)\n    {\n        var b = this.cpu.getByte(addr);\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_VIDEO);\n        }\n        /*\n         * The only documented READ bit in addrVideoPort is bit 7, which is supposed to alternate between\n         * 0 and 1 every 1/120 of a second.  There's no way we're going to add special code to the emulator to update\n         * this stupid byte every 8,333 cycles (assuming 1Mhz operation), so clearly we're going to fake it.\n         *\n         * Faking it means that any polling code will unavoidably get a stale value the FIRST time it reads bit 7.\n         * However, we can still do a pretty good job of faking any EXTENSIVE polling: get the number of cycles\n         * executed so far, divide that by 8333, floor the quotient, and then set/clear bit 7 according to whether the\n         * result is odd/even.\n         */\n        var nCyclesHigh = Math.floor(this.cpu.getCycles() / 8333);\n        this.cpu.setByte(addr, (b & 0x7F) | ((nCyclesHigh & 0x1)? 0x80 : 0));\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} addr (ie, addrVideoPort)\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to write the specified addr)\n     */\n    setByte(addr, addrFrom)\n    {\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_VIDEO);\n        }\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} addr (ie, addrGuard)\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n     */\n    tripGuard(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this read (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_VIDEO, true);\n            /*\n             * The CPU has just written to the guard address we established just beyond the video buffer's 1K boundary,\n             * implying that the system thinks we have a 2K buffer instead.  So we bump our model to 540, bump the\n             * associated keyboard model to 542, and remove this guard handler.\n             */\n            this.setModel(540);\n            if (this.kbd) this.kbd.setModel(542);\n            this.cpu.removeWriteNotify(this.addrGuard, this.addrGuard, this, this.tripGuard);\n        }\n    }\n\n    /**\n     * @this {C1PVideo}\n     */\n    initScreen()\n    {\n        this.abScreen = new Array(this.cbScreen);\n        for (var offset=0; offset <= this.cbScreen; offset++) {\n            this.abScreen[offset] = -1; // initialize every cell of the screen to an invalid value\n        }\n    }\n\n    /**\n     * updateScreen() updates the screen buffer from the video buffer and updates the window with any changes.\n     *\n     * @this {C1PVideo}\n     * @return {boolean}\n     *\n     * For every byte in the video buffer, this renders it if it differs from the byte stored in the screen buffer,\n     * and then updates the screen buffer to match.  Since initScreen() sets every byte in the screen buffer\n     * to an illegal byte value (ie, a value which is outside the byte range 0x00-0xff), that assures the first call\n     * to updateScreen() will redraw every byte in the video buffer.\n     */\n    updateScreen()\n    {\n        var offset = 0;\n        if (this.flags.powered) {\n            while (offset < this.cbScreen) {\n                var b = this.abMem[this.offVideo + offset];\n                if (this.abScreen[offset] != b) {\n                    if (!this.writeByte(offset, b)) {\n                        break;\n                    }\n                    this.abScreen[offset] = b;\n                }\n                offset++;\n            }\n        }\n        return (offset == this.cbScreen);\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} offset\n     * @param {number} b\n     * @return {boolean}\n     */\n    writeByte(offset, b)\n    {\n        var col = offset % this.nCols;\n        var row = Math.floor(offset / this.nCols);\n        return this.updateWindow(col, row, b);\n    }\n\n    /**\n     * updateWindow(col, row, b)\n     *\n     * Updates a particular position (row,col) in the associated window with the given byte (b)\n     *\n     * @this {C1PVideo}\n     * @param {number} col\n     * @param {number} row\n     * @param {number} b\n     * @return {boolean} true if successful, false if not\n     *\n     * I originally used (screenWidth,screenHeight) == (512,448) and (cols,rows) == (32,32) and (cxChar,cyChar) == (16,16),\n     * and I simply copied the source cells 1-to-1 to the destination (16,16), knowing that we would never try to display\n     * more than 28 rows (the last 4 rows of the 32 possible rows were never used to display any content).  However, I should\n     * still have ignored any attempt to draw past row 28 (aka screenHeight 448).  I now perform row clipping and biasing,\n     * according to the first visible row (iRowTop) and total visible rows (nRowsVisible).\n     *\n     * Moreover, I no longer copy the source cell images to the destination 1-to-1.  I calculate (cxCharDst,cyCharDst)\n     * separately (see setDrawingDimensions).  And I no longer assume that (cxChar,cyChar) are (16,16); once the source\n     * image file has finished loading, I calculate (cxChar,cyChar) based on the size of image file (see setReady).  I made\n     * this change when I created chargen1x.png.  In fact, at first I thought I might be able to eliminate chargen2x.png\n     * and just let drawImage() scale up the individual character images from (8,8) to (16,16) or whatever (cxCharDst,cyCharDst)\n     * size was needed, but the results were fuzzy, so it's still best to use chargen2x.png when using larger window sizes.\n     */\n    updateWindow(col, row, b)\n    {\n        if (row >= this.iRowTop) {\n            row -= this.iRowTop;\n            if (row < this.nRowsVisible) {\n                var xChar = (b * this.cxChar);\n                var ySrc = Math.floor(xChar / this.imgChars.width) * this.cyChar;\n                var xSrc = xChar % this.imgChars.width;\n                var xDst = col * this.cxCharDst;\n                var yDst = row * this.cyCharDst;\n                // if (DEBUG) this.log(\"updateWindow(\" + col + \",\" + row + \",\" + b +\"): drawing from \" + xSrc + \",\" + ySrc + \" to \" + xDst + \",\" + yDst);\n                this.contextScreen.drawImage(this.imgChars, xSrc, ySrc, this.cxChar, this.cyChar, xDst, yDst, this.cxCharDst, this.cyCharDst);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * C1PVideo.init()\n     *\n     * This function operates on every HTML element of class \"video\", extracting the\n     * JSON-encoded parameters for the C1PVideo constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PVideo component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeVideo = Component.getElementsByClass(document, C1PJS.APPCLASS, \"video\");\n        for (var iVideo=0; iVideo < aeVideo.length; iVideo++) {\n            var eVideo = aeVideo[iVideo];\n            var parmsVideo = Component.getComponentParms(eVideo);\n\n            /*\n             * As noted in keyboard.js, the keyboard on an iOS device pops up with the SHIFT key depressed,\n             * which is not the initial keyboard state that the C1P expects. I originally tried to fix that by\n             * adding an 'autocapitalize=\"off\"' attribute alongside the 'contenteditable=\"true\"' attribute\n             * on the <canvas> element, but apparently Safari honors that only inside certain elements (eg, <input>).\n             *\n             * I've since settled on a better work-around in keyboard.js, so I've stopped worrying about how to make\n             * \"autocapitalize\" work here.\n             */\n            var eCanvas = /** @type {HTMLCanvasElement} */ (document.createElement(\"canvas\"));\n            if (eCanvas === undefined || !eCanvas.getContext) {\n                eVideo.innerHTML = \"<br/>Missing &lt;canvas&gt; support. Please try a newer web browser.\";\n                return;\n            }\n            eCanvas.setAttribute(\"class\", C1PJS.APPCLASS + \"-canvas\");\n            eCanvas.setAttribute(\"width\", parmsVideo['screenWidth']);\n            eCanvas.setAttribute(\"height\", parmsVideo['screenHeight']);\n\n            eCanvas.setAttribute(\"contenteditable\", \"true\");\n            eCanvas.setAttribute(\"autocapitalize\", \"off\");\n            eCanvas.setAttribute(\"autocorrect\", \"off\");\n            eCanvas.style.backgroundColor = parmsVideo['screenColor'];\n\n            /*\n             * HACK: A canvas style of \"auto\" provides for excellent responsive canvas scaling in EVERY browser\n             * except IE9/IE10, so I recalculate the appropriate CSS height every time the parent DIV is resized;\n             * IE11 works without this hack, so we take advantage of the fact that IE11 doesn't report itself as \"MSIE\".\n             */\n            eCanvas.style.height = \"auto\";\n            if (Web.getUserAgent().indexOf(\"MSIE\") >= 0) {\n                eCanvas.style.height = (((eVideo.clientWidth * parmsVideo['screenHeight']) / parmsVideo['screenWidth']) | 0) + \"px\";\n                eVideo.onresize = function(eParent, eChild, cx, cy) {\n                    return function() {\n                        eChild.style.height = (((eParent.clientWidth * cy) / cx) | 0) + \"px\";\n                    };\n                }(eVideo, eCanvas, parmsVideo['screenWidth'], parmsVideo['screenHeight']);\n            }\n            eVideo.appendChild(eCanvas);\n\n            /*\n             * Now we can create the Video object, record it, and wire it up to the associated document elements.\n             *\n             * Regarding \"new Image()\", see https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement.Image:\n             *\n             *      This constructor exists for historical reasons only and returns an HTMLImageElement instance just as\n             *      document.createElement('img') would.\n             */\n            var imgCharSet = new Image();\n            var eContext = /** @type {CanvasRenderingContext2D} */ (eCanvas.getContext(\"2d\"));\n            var video = new C1PVideo(parmsVideo, eCanvas, eContext, imgCharSet);\n            imgCharSet.onload = function(video, sCharSet) {\n                return function() {\n                    if (DEBUG) video.log(\"onload(): finished loading \" + sCharSet);\n                    video.setReady();\n                };\n            }(video, parmsVideo['charSet']);        // jshint ignore:line\n            imgCharSet.src = parmsVideo['charSet'];\n\n            /*\n             * Bind any video-specific controls (eg, the Refresh button). There are no essential controls, however;\n             * even the \"Refresh\" button is just a diagnostic tool, to verify that the screen contents are up-to-date.\n             */\n            Component.bindComponentControls(video, eVideo, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize every Video module on the page.\n */\nWeb.onInit(C1PVideo.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/serial.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PSerialPort extends Component {\n    /**\n     * C1PSerialPort(parmsSerial)\n     *\n     * The SerialPort component has no component-specific parameters.\n     *\n     * @this {C1PSerialPort}\n     * @param {Object} parmsSerial\n     */\n    constructor(parmsSerial)\n    {\n        super(\"C1PSerialPort\", parmsSerial);\n\n        this.flags.powered = false;\n        this.fDemo = parmsSerial['demo'];\n\n        this.reset(true);\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {boolean} [fHard]\n     */\n    reset(fHard)\n    {\n        /*\n         * Because we reset the machine at the start of a 6502 HEX command file auto-load,\n         * we must avoid tossing the serial port's input buffer in that particular case (2).\n         */\n        if (fHard || this.autoLoad != C1PSerialPort.AUTOLOAD_6502) {\n\n            this.bInput = -1;\n            this.iInput = 0;\n            this.sInput = \"\";\n            if (this.fDemo) {\n                this.sInput = \"10 PRINT \\\"HELLO OSI #\" + this.getMachineNum() + \"\\\"\\n\";\n            }\n\n         // this.sOutput = new Array(0);\n         // this.iOutputNext = 0;\n\n            this.fConvertLF = true;\n            this.autoLoad = C1PSerialPort.AUTOLOAD_NONE;\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     */\n    start()\n    {\n        if (this.kbd && this.fDemo) {\n            this.kbd.injectKeys(\" C\\n\\n\", 3000);     // override the default injection delay (currently 300ms)\n            setTimeout(function(serial) { return function() {serial.startLoad();}; }(this), 12000);\n        }\n        this.fDemo = false;\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"listSerial\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        var serial = this;\n\n        switch(sBinding) {\n\n        case \"listSerial\":\n            this.bindings[sBinding] = control;\n            return true;\n\n        case \"loadSerial\":\n            this.bindings[sBinding] = control;\n            control.onclick = function onClickLoadSerial(event) {\n                if (serial.bindings[\"listSerial\"]) {\n                    var sFile = serial.bindings[\"listSerial\"].value;\n                    // serial.println(\"loading \" + sFile + \"...\");\n                    Web.getResource(sFile, null, true, function(sURL, sResponse, nErrorCode) {\n                        serial.loadFile(sURL, sResponse, nErrorCode);\n                    });\n                }\n            };\n            return true;\n\n        case \"mountSerial\":\n            /*\n             * Check for non-mobile (desktop) browser and the availability of FileReader\n             */\n            var controlInput = /** @type {Object} */ (control);\n            if (!Web.isMobile() && window && 'FileReader' in window) {\n                this.bindings[sBinding] = controlInput;\n                /*\n                 * Enable \"Mount\" button only if a file is actually selected\n                 */\n                controlInput.onchange = function onChangeMountSerial() {\n                    var fieldset = controlInput.children[0];\n                    var files = fieldset.children[0].files;\n                    var submit = fieldset.children[1];\n                    submit.disabled = !files.length;\n                };\n                controlInput.onsubmit = function onSubmitMountSerial(event) {\n                    var file = event.currentTarget[1].files[0];\n\n                    var reader = new FileReader();\n                    reader.onload = function() {\n                        // serial.println(\"mounting \" + file.name + \"...\");\n                        serial.loadFile(file.name, reader.result.toString(), 0);\n                    };\n                    reader.readAsText(file);\n\n                    /*\n                     * Prevent reloading of web page after form submission\n                     */\n                    return false;\n                };\n            }\n            else {\n                if (DEBUG) this.log(\"Local file support not available\");\n                controlInput.parentNode.removeChild(/** @type {Node} */ (controlInput));\n            }\n            return true;\n\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.offPort = start;\n        this.cbPort = end - start + 1;\n        this.offPortLimit = this.offPort + this.cbPort;\n        if ((this.cpu = cpu)) {\n            cpu.addReadNotify(start, end, this, this.getByte);\n            cpu.addWriteNotify(start, end, this, this.setByte);\n        }\n        this.setReady();\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     *\n     * We make a note of the Computer component, so that we can invoke its reset() method whenever we need to\n     * simulate a warm start, and we query the Keyboard component so that we can use its injectKeys() function.\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            this.cmp = cmp;\n            this.kbd = cmp.getComponentByType(\"keyboard\");\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     */\n    startLoad()\n    {\n        this.autoLoad = C1PSerialPort.AUTOLOAD_BASIC;\n        this.kbd.injectKeys(\"LOAD\\n\");\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {string} sFileName\n     * @param {string} sFileData (null if getResource() encountered an error)\n     * @param {number} nResponse from server\n     */\n    loadFile(sFileName, sFileData, nResponse)\n    {\n        if (!sFileData) {\n            this.println(\"Error loading file \\\"\" + sFileName + \"\\\" (\" + nResponse + \")\");\n            return;\n        }\n\n        this.iInput = 0;\n        this.sInput = sFileData;\n        this.fConvertLF = true;\n        this.autoLoad = C1PSerialPort.AUTOLOAD_NONE;\n\n        /*\n         * The following code adds support for loading \"65V\" files encoded as JSON, which is a cleaner\n         * way to store and deliver those files when they contain binary (non-ASCII) data.\n         *\n         * For example, my 6502 ASSEMBLER/DISASSEMBLER program starts with a conventional \"65V\" loading\n         * sequence, which loads and launches a small program loader that loads the rest of the program\n         * using a raw (1-to-1) binary format instead of the usual (3-to-1) HEX format used by \"65V\" files.\n         *\n         * The \"rawness\" of the binary format also necessitates disabling fConvertLF.\n         */\n        if (Str.endsWith(sFileName, \".json\")) {\n            try {\n                /*\n                 * The most likely source of any exception will be here: parsing the JSON-encoded data.\n                 */\n                var s = \"\";\n                var data = eval(\"(\" + sFileData + \")\");\n                var ab = data['bytes'];\n                for (var i = 0; i < ab.length; i++) {\n                    s += String.fromCharCode(ab[i]);\n                }\n                this.sInput = s;\n                this.fConvertLF = false;\n            } catch (e) {\n                this.println(\"Error processing file \\\"\" + sFileName + \"\\\": \" + e.message);\n                return;\n            }\n        }\n\n        if (this.cmp && this.kbd && this.cpu.isRunning()) {\n            this.println(\"auto-loading \" + sFileName);\n            /*\n             * QUESTION: Is this setFocus() call strictly necessary?  We're being called in the\n             * context of getResource(), not some user action.  If there was an original user action,\n             * then the handler for THAT action should take care to switch focus back, not us.\n             */\n            this.cpu.setFocus();\n            /*\n             * We interpret the presence of a \".\" at the beginning of the file as a \"65V Monitor\"\n             * address-mode command, and consequently treat the file as 6502 HEX command file.\n             *\n             * Anything else is treated as commands for the BASIC interpreter, which we re-initialize\n             * with \"NEW\" and \"LOAD\" commands.  To prevent that behavior, halt the CPU, perform the load,\n             * and then start it running again.  BASIC will start reading the data as soon as you type\n             * LOAD.\n             */\n            if (this.sInput.charAt(0) != '.') {\n                this.autoLoad = C1PSerialPort.AUTOLOAD_BASIC;\n                this.kbd.injectKeys(\"NEW\\nLOAD\\n\");\n            }\n            else {\n                /*\n                 * Set autoLoad to AUTOLOAD_6502 before the reset, so that when our reset() method is called,\n                 * we'll take care to preserve all the data we just loaded.\n                 */\n                this.autoLoad = C1PSerialPort.AUTOLOAD_6502;\n                /*\n                 * Although the Keyboard allows us to inject any key, even the BREAK key, like so:\n                 *\n                 *      this.kbd.injectKeys(String.fromCharCode(this.kbd.CHARCODE_BREAK))\n                 *\n                 * it's easier to initiate a reset() ourselves and then start the machine-language load process\n                 */\n                this.cmp.reset(true);\n                this.kbd.injectKeys(\"ML\");\n            }\n        }\n        else {\n            this.println(sFileName + \" ready to load\");\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {number} addr\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n     */\n    getByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this read (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            /*\n             *  WARNING: All I need to do for now is load the COM interface's \"data byte\"\n             *  with the next byte from the virtual cassette data stream -JP\n             */\n            if (!(addr & 0x01)) {\n                /*\n                 * An EVEN address implies they're looking, so if we have a fresh buffer,\n                 * then prime the pump.\n                 */\n                if (this.sInput && !this.iInput)\n                    this.advanceInput();\n            } else {\n                /*\n                 * An ODD address implies they just grabbed a data byte, so prep the next data byte.\n                 */\n                this.advanceInput();\n            }\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {number} addr\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to write the specified addr)\n     */\n    setByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this write (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_SERIAL, true);\n            /*\n             * WARNING: I don't yet care what state the CPU puts the port into.  When it's time to support serial output,\n             * obviously that will become an issue.\n             */\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     */\n    advanceInput()\n    {\n        if (this.sInput !== undefined) {\n            this.bInput = -1;\n            if (this.iInput < this.sInput.length) {\n                var b = this.sInput.charCodeAt(this.iInput++) & 0xff;\n                if (this.fConvertLF) {\n                    if (b == 0x0a) b = 0x0d;\n                }\n                this.bInput = b;\n                // if (DEBUG) this.log(\"advanceInput(\" + Str.toHexByte(b) + \")\");\n            }\n            else {\n                this.sInput = \"\";\n                this.iInput = 0;\n                if (DEBUG) this.log(\"advanceInput(): out of data\");\n                if (this.autoLoad == C1PSerialPort.AUTOLOAD_BASIC && this.kbd) {\n                    this.kbd.injectKeys(\" \\nRUN\\n\");\n                }\n                this.autoLoad = C1PSerialPort.AUTOLOAD_NONE;\n            }\n            this.updateMemory();\n        }\n        // else if (DEBUG) this.log(\"advanceInput(): no input\");\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     */\n    updateMemory()\n    {\n        var offset;\n        /*\n         * Update all the status (even) bytes\n         */\n        for (offset = this.offPort+0; offset < this.offPortLimit; offset+=2) {\n            this.abMem[offset] = (this.bInput >= 0? C1PSerialPort.STATUS_DATA : C1PSerialPort.STATUS_NONE);\n        }\n        /*\n         * Update all the data (odd) bytes\n         */\n        for (offset = this.offPort+1; offset < this.offPortLimit; offset+=2) {\n            this.abMem[offset] = (this.bInput >= 0? this.bInput : 0);\n        }\n    }\n\n    /**\n     * C1PSerialPort.init()\n     *\n     * This function operates on every HTML element of class \"serial\", extracting the\n     * JSON-encoded parameters for the C1PSerialPort constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PSerialPort component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeSerial = Component.getElementsByClass(document, C1PJS.APPCLASS, \"serial\");\n        for (var iSerial=0; iSerial < aeSerial.length; iSerial++) {\n            var eSerial = aeSerial[iSerial];\n            var parmsSerial = Component.getComponentParms(eSerial);\n            var serial = new C1PSerialPort(parmsSerial);\n            Component.bindComponentControls(serial, eSerial, C1PJS.APPCLASS);\n        }\n    }\n}\n\nC1PSerialPort.STATUS_NONE   = 0x00;\nC1PSerialPort.STATUS_DATA   = 0x01;     // indicates data available\n\n/*\n * Values for autoLoad:\n *\n *      0: no auto-load active\n *      1: BASIC command file auto-load in progress\n *      2: 6502 HEX command file auto-load in progress\n */\nC1PSerialPort.AUTOLOAD_NONE  = 0;\nC1PSerialPort.AUTOLOAD_BASIC = 1;\nC1PSerialPort.AUTOLOAD_6502  = 2;\n\n/*\n * Initialize every SerialPort module on the page.\n */\nWeb.onInit(C1PSerialPort.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/disk.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * @class Drive\n * @property {number} iType\n * @property {number} nTracks\n * @property {boolean} fProtected\n * @property {number} nIndexPulse\n * @property {number} iTrackSelect\n * @property {number} iTrackOffset\n * @property {Array} aTracks\n */\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PDiskController extends Component {\n    /**\n     * C1PDiskController(parmsDC)\n     *\n     * The C1PDiskController component has no component-specific parameters.\n     *\n     * This component is being built to supplement a C1P (aka SuperBoard II) Model 600\n     * single-board computer with the addition of a 610 Accessory Board, which included:\n     *\n     *      MC6820 PIA (Peripheral Interface Adapter at $C000-$C003, decoded at $C000-$C00F)\n     *      MC6850 ACIA (Asynchronous Communications Interface Adapter at $C010-$C011, decoded at $C010-$C01F)\n     *\n     * From \"OSI C1P Technical Report\" p.4 regarding the 610 Accessory Board:\n     *\n     *      \"This board holds up to 24K of additional RAM memory, a dual mini-floppy disk controller,\n     *      a BUS expansion facility to Model 620 BUS adapter, and switching circuitry to route the\n     *      600 board's serial interface to both the modem and printer as well as an audio cassette.\n     *      Thus, a fully expanded Challenger lP system can have BASIC-in-ROM, 32K of RAM memory,\n     *      dual mini-floppies, cassette, printer, modem, and full BUS expansion capability to the OSI\n     *      48 line BUS through which over 40 accessories can be added (A/D, D/A, voice, I/O, more memory,\n     *      etc.).\"\n     *\n     * On p.20, the Report says that the 610 Accessory Board contains:\n     *\n     *      - Up to 24K of RAM\n     *      - Dual mini-floppy controller\n     *      - Real Time Clock (although elsewhere the Report says this is disabled by default)\n     *      - Expansion interface to a model 620 BUS adapter\n     *\n     * On p.21, the Report also says:\n     *\n     *      \"The dual mini-floppy interface is designed after Ohio Scientific's extremely popular\n     *      and successful 470 floppy disk controller. This floppy disk controller and encoding\n     *      technique has been field proven for several years in thousands of floppy disks and is\n     *      believed to be one of the most reliable floppy disk configurations in existence. Although\n     *      the Challenger lP product line is new, it has the advantage of the experience of a company\n     *      which has been building high performance microcomputers for several years.\"\n     *\n     * From \"PEEK 65\" Vol.2 No.3 March 1981, p.9:\n     *\n     *      \"The 470 board wired as a floppy disk controller contains two different interfaces:\n     *      a PIA and an ACIA. The PIA A and B ports are used in control circuits: raise and lower\n     *      the head, detect drive ready, detect sector hole, clear error faults, etc. The ACIA is\n     *      the interface over which the data actually travels. Typical operation is to drop the head,\n     *      reset the ACIA, wait for the index hole to come around, activate the read or write circuit,\n     *      then read or write characters through the ACIA.\"\n     *\n     *      470 Board Addressing\n     *      --------------------\n     *\n     *      Address     Read                    Write\n     *      -------     ----                    -----\n     *      C000        PIA: PA0 thru PA7       PIA: PA0 thru PA7 or DDA0 thru DDA7\n     *      C001        PIA: Port A Ctrl        PIA: Port A Control\n     *      C002        PIA: PB0 thru PB7       PIA: PB0 thru PB7 or DDB0 thru DDB7\n     *      C003        PIA: Port B Ctrl        PIA: Port B Control\n     *      C010        ACIA: Status Reg.       ACIA: Control Register\n     *      C011        ACIA: Data Path         ACIA: Data Path\n     *      C020        Clear Real Time Clock   Clear Real Time Clock\n     *                  (Reset) ($FF returned)  (Reset) (Data Ignored)\n     *\n     *      PIA Data Register A Layout:\n     *\n     *      PA7     PA6     PA5     PA4     PA3     PA2     PA1     PA0\n     *      ---     ---     ---     ----    ---     ---     ---     ----\n     *      IHD  |  SD2  |  WP   |  RDY2 |  SHD  |  FD   |  TZD  |  RDY1\n     *      (In)    (Out)   (In)    (In)    (In)    (In)    (In)    (In)\n     *\n     *      PIA Data Register B Layout:\n     *\n     *      PB7     PB6     PB5     PB4     PB3     PB2     PB1     PB0\n     *      ---     ---     ---     ---     ---     ---     ---     ---\n     *      HLD  |  LCS  |  SD1  |  FR   |  ST   |  STI  |  EE   |  WE\n     *      (Out)   (Out)   (Out)   (Out)   (Out)   (Out)   (Out)   (Out)\n     *\n     *      PIA Data Register A Lines       PIA Data Register B Lines\n     *      -------------------------       -------------------------\n     *      IHD - Index Hole Detect         HLD - Head Load\n     *      SD2 - Select Drive 2 (Drive B)  LCS - Low Current Select\n     *      WP  - Write Protected           SD1 - Select Drive 1\n     *      RDY2- Drive 2 Ready             FR  - Fault Reset\n     *      SHD - Sector Hole Detect        ST  - Step\n     *      FD  - Fault Detected            STI - Step In\n     *      TZD - Track Zero Detected       EE  - Enable Erase\n     *      RDY1- Drive 1 Ready             WE  - Write Enable\n     *\n     * NOTE: The PIA bit assignments above agree with those described, albeit somewhat less clearly,\n     * in http://www.osiweb.org/osiweb/misc/osi-hardware.txt, under \"Model 475 Floppy disk system with\n     * 470 Controller board\".\n     *\n     * There is apparently significant overlap with another OSI board: the Model 505 CPU Board\n     * used in C4P/MF systems.  According to http://www.osiweb.org/osiweb/misc/osi-hardware.txt, it\n     * contained:\n     *\n     *      CPU board w/ ROM, ACIA, Floppy Disk I/O, Real Time Clock\n     *      ROM $FDxx, $FExx, $FFxx\n     *      Floppy disk interface: 6820 PIA at $C000, 6850 ACIA at $C010 [Original says \"6850 PIA\"]\n     *      ACIA 6850 at $FC00 for RS-232 serial I/O. Baud jumpers for 75,150,300,600,1200,2400,4800,9600\n     *      Disk PIA $C0xx CB1 connected to 400mSEC (2.5/sec) clock divided from system clock (RTC)\n     *      Home security - PIA $F700-F703\n     *\n     * Disk Formats (from http://osi.marks-lab.com/files/winOSI/old-source-V1.2/Disk_io.cpp):\n     *\n     *      5.25\" disk, 40 tracks, 8 sectors/track, 256 bytes/sector, 11 bits/byte (8E1) = 80K/disk.\n     *\n     *      NOTE: 8E1 refers to \"8 data bits, even parity, 1 stop bit,\" plus an implied start bit.\n     *\n     *      OSI uses 8E1 to give a max unformatted capacity of 2272 bytes per track (see below).\n     *      However other bit encodings (8N1) could give up to 2500 bytes/track.\n     *\n     *      NOTE: 8N1 refers to \"8 data bits, no parity, 1 stop bit,\" plus an implied start bit.\n     *\n     *      The standard speed for 5.25\" drives is 300rpm. Thus one rotation of the disk is 200ms.\n     *      Stated baud-rate is 125k or 125000 bits/sec and one serial byte is 11 bits (1 start,\n     *      8 data, 1 parity, 1 stop). So the theoretical absolute maximum storage per track is\n     *      (125000 x 0.2) / 11 = 2272 bytes or 8.8 pages.\n     *\n     *      OS-65D loses a bit more because it doesn't write until 10ms after the index pulse, so\n     *      (125000 x 0.19) / 11 = 2159 bytes or 8.4 pages and this doesn't even allow for the length\n     *      of the index pulse (a few milliseconds?) and the speed variation between drives.\n     *\n     *      8\" disk, 77 tracks, 12 sectors/track, 256 bytes/sector, 11 bits/byte (8E1) = 231K/disk.\n     *      OSI uses 8E1 to give a max unformatted capacity of 3772 bytes/track (see below).\n     *      However other bit encodings (8N1) could give up to 3900 bytes/track.\n     *\n     *      The standard speed for 8\" drives is 360rpm. Thus one rotation of the disk is 166.6ms.\n     *      Stated baud rate is 250K or 250000 bits/sec and one serial byte is 11 bits (1 start,\n     *      8 data, 1 parity, 1 stop). So the theoretical absolute maximum storage per track is\n     *      (250000 x 0.166 ) / 11 = 3772 or 14.7 pages.\n     *\n     *      OS-65D loses a bit more because it doesn't write until 10 mS after the index pulse, so\n     *      (250000 x 0.156) / 11 = 3545 bytes  or 13.8 pages and this doesn't even allow for the length\n     *      of the index pulse (a few milliseconds?) and the speed variation between drives.\n     *\n     *      Track 0 Format\n     *      --------------\n     *              (10ms delay after index hole)\n     *      0,1     load address of the track in hi,lo form\n     *      2       page count of how much data is written on track 0.\n     *      3+      sector data\n     *\n     *      Track N Format (N > 0)\n     *      ----------------------\n     *              (10ms delay after index hole)\n     *      0,1     2-byte start code $43, $57\n     *      2       BCD track number\n     *      3       track type code (always $58)\n     *      4+      sector data\n     *\n     *      Sector Format (5.25\" disks)\n     *      ---------------------------\n     *      There can be any mixture of various length sectors. The total page count can not\n     *      exceed 8 pages (8*256) if more than one sector is on a track. Each sector is written\n     *      in the following format:\n     *\n     *          previous sector length (4 if none before) times 800 microseconds of delay\n     *          sector start code $76\n     *          sector number in binary\n     *          sector length (#pages) in binary\n     *          sector data\n     *          (end of sector mark? $47, $53? MDS)\n     *\n     *      Directory Format\n     *      ----------------\n     *      2 sectors (1 & 2) on track 12 hold the directory information.\n     *      Each entry requires 8 bytes. There are a total of 64 entries. The entries are\n     *      formatted as follows:\n     *\n     *          0-5 ASCII 6 character filename\n     *          6 BCD first track of file\n     *          7 BCD Last track of file\n     *\n     * So far, all the 5.25\" disk images I've seen are 92160 bytes, regardless whether they have an\n     * .IMG or .65D extension.  If we divide that total by 40 (tracks/disk), we get 2304 (bytes/track).\n     * Divide 2304 by 256 (bytes/page) and we get 9 pages/track.  Presumably a fixed 9 pages was chosen\n     * to yield a consistent track size across the entire image, while also allowing room for all the\n     * metadata that's typically present on a track as well.  As explained above, the upper limit\n     * on data per track (both sector data and metadata) is 8.8 pages in theory, or 8.4 pages in practice.\n     *\n     * @this {C1PDiskController}\n     * @param {Object} parmsDC\n     */\n    constructor(parmsDC)\n    {\n        super(\"C1PDiskController\", parmsDC);\n\n        this.flags.powered = false;\n\n        /*\n         * Our DiskController simulates the combination of an MC6820 PIA and an MC6850 ACIA.\n         * This image of an OSI 470 Controller Board (http://osi.marks-lab.com/boards/images/OSI470.jpg)\n         * shows that the chips actually used were MC68B21P and MC68B50P.\n         *\n         * We start with definitions for the MC6820 PIA.\n         */\n        this.PORT_PDA   = 0;        // PIA Peripheral Data Register A\n        this.PORT_DDA   = 0;        // PIA Data Direction Register A (DDA shares the same register offset as PDA)\n        this.PORT_CRA   = 1;        // PIA Control Register A\n\n        this.PORT_PDB   = 2;        // PIA Peripheral Data Register B\n        this.PORT_DDB   = 2;        // PIA Data Direction Register B (DDB shares the same register offset as PDB)\n        this.PORT_CRB   = 3;        // PIA Control Register B\n\n        this.CR_IRQ1    = 0x80;     // IRQ1\n        this.CR_IRQ2    = 0x40;     // IRQ2\n     // this.CR_C2_OUT  = 0x20;     // C2 is designated an output\n     // this.CR_C2_CTRL = 0x18;     // C2 Control (00 and 10 mask IRQ2, 01 and 11 pass IRQ2 through to the CPU)\n        this.CR_PD_SEL  = 0x04;     // set to select PD (PDA or PDB), clear to select DD (DDA or DDB)\n     // this.CR_C1_CTRL = 0x03;     // C1 Control (00 and 10 mask IRQ1, 01 and 11 pass IRQ1 through to the CPU)\n\n        /*\n         * The PDA bits have the following hard-wired connections in the OSI Floppy Disk Controller.\n         * Each line marked INPUT should have its corresponding Data Direction bit clear (0), and each line\n         * marked OUTPUT should have its Data Direction bit set (1); however, we do not currently verify that\n         * the Data Direction bits are actually initialized to match these specs (and in fact, in the case\n         * of PDA_SD2, they may not be).\n         */\n        this.PDA_RDY1   = 0x01;     // INPUT:   0 = Drive 1 Ready\n        this.PDA_TZD    = 0x02;     // INPUT:   0 = Track Zero Detected\n        this.PDA_FD     = 0x04;     // INPUT:   0 = Fault Detected\n        this.PDA_SHD    = 0x08;     // INPUT:   0 = Sector Hole Detect\n        this.PDA_RDY2   = 0x10;     // INPUT:   0 = Drive 2 Ready\n        this.PDA_WP     = 0x20;     // INPUT:   0 = Write Protected\n        this.PDA_SD2    = 0x40;     // OUTPUT:  0 = Select Drive 2 (Drive B)\n        this.PDA_IHD    = 0x80;     // INPUT:   0 = Index Hole Detect\n\n     // this.PDB_WE     = 0x01;     // OUTPUT:  0 = Write Enable\n     // this.PDB_EE     = 0x02;     // OUTPUT:  0 = Erase Enable (set to 1)\n        this.PDB_STI    = 0x04;     // OUTPUT:  0 = Step In (away from track 0)\n        this.PDB_ST     = 0x08;     // OUTPUT:  0 = Step (on 1-to-0 transition)\n     // this.PDB_FR     = 0x10;     // OUTPUT:  0 = Fault Reset (set to 1)\n        this.PDB_SD1    = 0x20;     // OUTPUT:  0 = Select Drive 1\n     // this.PDB_LCS    = 0x40;     // OUTPUT:  0 = Low Current Select (set to 1)\n     // this.PDB_HLD    = 0x80;     // OUTPUT:  0 = Head Load (head on disk)\n\n        /*\n         * Next, definitions for the MC6850 ACIA.\n         *\n         * For reference, here are all the possible CTRL_WSEL (Word Select) values:\n         *\n         *      000     0x00        7 bits, even parity, 2 stop bits\n         *      001     0x04        7 bits, odd parity, 2 stop bits\n         *      010     0x08        7 bits, even parity, 1 stop bit\n         *      011     0x0C        7 bits, odd parity, 1 stop bit\n         *      100     0x10        8 bits, 2 stop bits\n         *      101     0x14        8 bits, 1 stop bit\n         *      110     0x18        8 bits, even parity, 1 stop bit\n         *      111     0x1C        8 bits, odd parity, 1 stop bit\n         *\n         * And here are all the possible CTRL_TCTL (Transmit Control) values:\n         *\n         *      00      0x00        RTS=Low, Transmitting Interrupt Disabled\n         *      01      0x20        RTS=Low, Transmitting Interrupt Enabled\n         *      10      0x40        RTS=High, Transmitting Interrupt Disabled\n         *      11      0x60        RTS=Low, Transmits a Break level on the Transmit Data Output; Transmitting Interrupt Disabled\n         */\n        this.PORT_CTRL = 0x10;  // ACIA Control Register (WRITE-only)\n        this.PORT_STAT = 0x10;  // ACIA Status Register (READ-only)\n        this.PORT_DATA = 0x11;  // ACIA Data Register (Transmit Data Register on WRITE, Receive Data Register on READ)\n\n        this.CTRL_CDIV  = 0x03; // Counter Divide (CR1,CR0) [OSI sets both, performing a \"Master Reset\", then immediately clears both, for a divide ratio of 1]\n     // this.CTRL_WSEL  = 0x1C; // Word Select (CR4,CR3,CR2), determining word length, parity and stop bits [OSI selects 0x18 for \"8 bits, even parity, 1 stop bit\"]\n     // this.CTRL_TCTL  = 0x60; // Transmit Control (CR6,CR5) [OSI selects 0x40 for \"RTS=High, Transmitting Interrupt Disabled\"]\n     // this.CTRL_RINT  = 0x80; // Receive Interrupt Enable (CR7) [OSI selects 0x00 for interrupts disabled]\n\n        this.STAT_RDRF  = 0x01; // Receive Data Register Full\n        this.STAT_TDRE  = 0x02; // Transmit Data Register Empty\n        this.STAT_DCD   = 0x04; // Data Carrier Detect\n        this.STAT_CTS   = 0x08; // Clear To Send\n     // this.STAT_FE    = 0x10; // Framing Error (ie, the received character is improperly framed by a start and a stop bit and is detected by the absence of the first stop bit)\n     // this.STAT_OVRN  = 0x20; // Receiver Overrun (ie, one or more characters in the data stream were lost due to not being read from the Receive Data Register in time)\n     // this.STAT_PE    = 0x40; // Parity Error (ie, the number of highs (ones) in the character does not agree with the preselected odd or even parity)\n     // this.STAT_IRQ   = 0x80; // Interrupt Request (ie, state of the IRQ output; cleared by a read operation to the Receive Data Register or a write operation to the Transmit Data Register)\n\n        /*\n         * Last but not least, some internal state definitions and hard-coded assumptions\n         */\n        this.DRIVETYPE_5INCH = 0;\n     // this.DRIVETYPE_8INCH = 1;\n\n        this.MAXTRACKS_5INCH = 40;\n     // this.MAXTRACKS_8INCH = 77;\n\n        /*\n         * Some random OS-65D notes\n         *\n         * Version 3.3 Initialization Code\n         * -------------------------------\n         *\n         * The following code (where X is 0x00):\n         *\n         *      2217 8E 01 F4  STX $F401\n         *      221A 8E 00 F4  STX $F400\n         *      221D 8E 03 F4  STX $F403\n         *\n         * is intended to reset a Printer PIA located at 0xF400.\n         *\n         * It then takes a detour to \"SET KEYBOARD SOUND GENERATOR TO LOWEST FREQUENCY (192.753 HZ)\"\n         * with X set to 0xFF; the sound generator is supposed to be turned off a bit later, presumably\n         * at the same time it sets \"64 char/line\" mode -- well, that's what v3.2 did anyway.\n         *\n         *      2220 CA        DEX\n         *      2221 8E 01 DF  STX $DF01\n         *\n         * While X is still 0xFF, it continues initializing the Printer PIA:\n         *\n         *      2224 8E 02 F4  STX $F402\n         *\n         * Then the code fiddles a bit with a mystery serial port (perhaps the \"Model 430B Cassette & Analog I/O\"\n         * interface?)\n         *\n         *      2227 AD 06 FB  LDA $FB06\n         *      222A 8E 05 FB  STX $FB05\n         *\n         * And then it's back to more Printer PIA initialization:\n         *\n         *      222D A9 04     LDA #$04\n         *      222F 8D 01 F4  STA $F401\n         *      2232 8D 03 F4  STA $F403\n         *\n         * Then it does some disk resetting (with A still 0x04 and Y set to 0x00):\n         *\n         *      2235 8C 01 C0  STY $C001\n         *      2238 A0 40     LDY #$40 ;'@'\n         *      223A 8C 00 C0  STY $C000\n         *      223D 8D 01 C0  STA $C001\n         *\n         * This code supposedly selects DRIVE 1:\n         *\n         *      2240 A9 01     LDA #$01\n         *      2242 20 C6 29  JSR $29C6\n         *\n         * Then it \"resets\" and \"sets\" the TERMINAL ACIA.  Note that the C1P serial port is addressed\n         * at 0xF000-0xF0FF, and the C1P has ROM mapped to 0xF800-0xFFFF, so we know nothing of the serial\n         * port mentioned above at 0xFBxx, nor this terminal ACIA port at 0xFCxx.\n         *\n         *      2245 A9 03     LDA #$03\n         *      2247 8D 00 FC  STA $FC00\n         *      224A A0 11     LDY #$11\n         *      224C 8C 00 FC  STY $FC00\n         *\n         * Next, there's some code to \"SET CA-10X 16 WAY SERIAL BOARD\" at 0xCF00-0xCF1F; again, something\n         * we know nothing about:\n         *\n         *      224F A2 1E     LDX #$1E\n         *      2251 9D 00 CF  STA $CF00,X\n         *      2254 98        TYA\n         *      2255 9D 00 CF  STA $CF00,X\n         *      2258 A9 03     LDA #$03\n         *      225A CA        DEX\n         *      225B CA        DEX\n         *      225C 10 F3     BPL $2251\n         *\n         * Then it clears 8 pages of video memory (ie, it simply ASSUMES that this is a Model 540 video board\n         * with 2K of video memory):\n         *\n         *      225E A2 08     LDX #$08\n         *      2260 A9 D0     LDA #$D0\n         *      2262 85 FF     STA $FF\n         *      2264 A0 00     LDY #$00\n         *      2266 84 FE     STY $FE\n         *      2268 A9 20     LDA #$20 ;' '\n         *      226A 91 FE     STA ($FE),Y\n         *      226C C8        INY\n         *      226D D0 FB     BNE $226A\n         *      226F E6 FF     INC $FF\n         *      2271 CA        DEX\n         *      2272 D0 F6     BNE $226A\n         *\n         * Then it performs a memory test, starting with a high page of 0xBF, and stores the highest page of\n         * available RAM at 0x2300:\n         *\n         *      2276 A0 BF     LDY #$BF\n         *      2278 20 EC 22  JSR $22EC\n         *      227B F0 03     BEQ $2280\n         *      227D 88        DEY\n         *      227E D0 F8     BNE $2278\n         *      2280 8C 00 23  STY $2300\n         *\n         * Now it checks for \"SERIAL OR VIDEO (EITHER 65-A OR 65-V PROM)\" (the byte at 0xFE01 on a C1P is 0x28,\n         * so X will be 2, implying \"VIDEO\"):\n         *\n         *      2283 A2 01     LDX #$01\n         *      2285 AD 01 FE  LDA $FE01\n         *      2288 F0 01     BEQ $228B\n         *      228A E8        INX\n         *      228B 8E C6 2A  STX $2AC6\n         *\n         * Finally, there's some code that's a little different from v3.2; in 3.2, it would set X to 0x01\n         * and then store X at 0xDE00, effectively forcing the video board into \"64 char/line\" mode -- which was\n         * originally EXACTLY what I was looking for in the video emulation component.  But v3.3 doesn't do that.\n         * Here's what it does instead:\n         *\n         *      228F A2 00     LDX #$00\n         *      2291 8E 80 DC  STX $DC80\n         *\n         * So, what's supposed to be at 0xDC80?\n         */\n\n        this.reset(true);\n    }\n\n    /**\n     * @this {C1PDiskController}\n     * @param {boolean|undefined} [fPowerOn] is true for the initial reset only\n     */\n    reset(fPowerOn)\n    {\n        this.resetRegs();\n        this.iDriveSelect = -1;\n        if (fPowerOn) {\n            this.aDrives = [];\n            this.resetDrive(0, this.DRIVETYPE_5INCH, this.MAXTRACKS_5INCH);\n        }\n    }\n\n    /**\n     * @this {C1PDiskController}\n     */\n    resetRegs()\n    {\n        this.regDDA = {\n            bits: this.PDA_SD2, // clear all DDA bits, indicating that all PDA bits represent INPUT lines (well, except for PDA_SD2)\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    if (b !== undefined) this.bits = b;\n                    if (!(controller.regCRA.bits & controller.CR_PD_SEL)) {\n                        controller.writePort(controller.PORT_DDA, this);\n                    }\n                };\n            }(this)\n        };\n        this.regPDA = {\n            bits: 0xff,\n            read: function() {\n                this.update();\n            },\n            update: function(controller) {\n                return function(b) {\n                    this.bits = controller.updatePDA(b);\n                    if (controller.regCRA.bits & controller.CR_PD_SEL) {\n                        controller.writePort(controller.PORT_PDA, this);\n                    }\n                };\n            }(this)\n        };\n        this.regCRA = {\n            bits: 0,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    /*\n                     * Most bits written to CRA should be left as-is (the CPU should read back what it wrote);\n                     * bits 7 and 6 (IRQ1 and IRQ2) are exceptions, since those are tied to peripheral \"Control Lines\"\n                     * C1 and C2, which can in theory generate an interrupt depending on how the C1_CTRL and C2_CTRL bits\n                     * in CRA are set.  However, assuming there's no need to simulate interrupts for this particular\n                     * controller hardware, all we'll do is simply insure those two bits are always off.\n                     */\n                    if (b !== undefined) this.bits = (b & ~(controller.CR_IRQ1 | controller.CR_IRQ2));\n                    controller.writePort(controller.PORT_CRA, this);\n                    /*\n                     * Since a CRA write may have also changed which register (PDA or DDA) is enabled via the corresponding\n                     * PDA port, we simply ask ask both to update (only the one that's enabled will write itself to memory).\n                     */\n                    controller.regPDA.update();\n                    controller.regDDA.update();\n                };\n            }(this)\n        };\n        this.regDDB = {\n            bits: 0xff,         // set all DDB bits, indicating that all PDB bits represent OUTPUT lines\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    if (b !== undefined) this.bits = b;\n                    if (!(controller.regCRB.bits & controller.CR_PD_SEL)) {\n                        controller.writePort(controller.PORT_DDB, this);\n                    }\n                };\n            }(this)\n        };\n        this.regPDB = {\n            bits: 0xff,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    this.bits = controller.updatePDB(b);\n                    if (controller.regCRB.bits & controller.CR_PD_SEL) {\n                        controller.writePort(controller.PORT_PDB, this);\n                    }\n                };\n            }(this)\n        };\n        this.regCRB = {\n            bits: 0,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    /*\n                     * Most bits written to CRB should be left as-is (the CPU should read back what it wrote);\n                     * bits 7 and 6 (IRQ1 and IRQ2) are exceptions, since those are tied to peripheral \"Control Lines\"\n                     * C1 and C2, which can in theory generate an interrupt depending on how the C1_CTRL and C2_CTRL bits\n                     * in CRB are set.  However, assuming there's no need to simulate interrupts for this particular\n                     * controller hardware, all we'll do is simply insure those two bits are always off.\n                     */\n                    if (b !== undefined) this.bits = (b & ~(controller.CR_IRQ1 | controller.CR_IRQ2));\n                    controller.writePort(controller.PORT_CRB, this);\n                    /*\n                     * Since a CRB write may have also changed which register (PDB or DDB) is enabled via the corresponding\n                     * PDB port, we simply ask ask both to update (only the one that's enabled will write itself to memory).\n                     */\n                    controller.regPDB.update();\n                    controller.regDDB.update();\n                };\n            }(this)\n        };\n        this.regCTRL = {\n            bits: 0,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    if (b !== undefined) {\n                        if ((b & controller.CTRL_CDIV) == controller.CTRL_CDIV) {\n                            /*\n                             * Setting both CTRL_CDIV bits (CR0 and CR1) constitutes a \"Master Reset\" of the ACIA\n                             */\n                            controller.regSTAT.bits = (controller.STAT_TDRE | controller.STAT_DCD | controller.STAT_CTS);\n                        }\n                        this.bits = b;\n                    }\n                    // regCTRL isn't readable; instead, we ensure regSTAT is rewritten in its place\n                    controller.regSTAT.update();\n                };\n            }(this)\n        };\n        this.regSTAT = {\n            bits: (this.STAT_TDRE | this.STAT_DCD | this.STAT_CTS),\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    this.bits = controller.updateSTAT(b);\n                    controller.writePort(controller.PORT_STAT, this);\n                };\n            }(this)\n        };\n        this.regDATA = {\n            bits: 0,\n            read: function(controller) {\n                return function() {\n                    controller.advanceDriveData();\n                };\n            }(this),\n            update: function(controller) {\n                return function(b) {\n                    if (b !== undefined) this.bits = b;\n                    controller.writePort(controller.PORT_DATA, this);\n                };\n            }(this)\n        };\n        this.regUnknown = {\n            bits: 0,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {};\n            }(this)\n        };\n        if (DEBUG) {\n            this.regDDA.sName = \"DDA\",\n            this.regDDA.aBitIDs = {0x80:\"DD7\",0x40:\"DD6\",0x20:\"DD5\",0x10:\"DD4\",0x08:\"DD3\",0x04:\"DD2\",0x02:\"DD1\",0x01:\"DD0\"};    // jshint ignore:line\n            this.regPDA.sName = \"PDA\";\n            this.regPDA.aBitIDs = {0x80:\"IHD\",0x40:\"SD2\",0x20:\"WP\",0x10:\"RDY2\",0x08:\"SHD\",0x04:\"FD\",0x02:\"TZD\",0x01:\"RDY1\"};\n            this.regCRA.sName = \"CRA\";\n            this.regCRA.aBitIDs = {0x80:\"IRQ1\",0x40:\"IRQ2\",0x20:\"C2OUT\",0x10:\"C2:1\",0x08:\"C2:0\",0x04:\"PDS\",0x02:\"C1:1\",0x01:\"C1:0\"};\n            this.regDDB.sName = \"DDB\";\n            this.regDDB.aBitIDs = {0x80:\"DD7\",0x40:\"DD6\",0x20:\"DD5\",0x10:\"DD4\",0x08:\"DD3\",0x04:\"DD2\",0x02:\"DD1\",0x01:\"DD0\"};\n            this.regPDB.sName = \"PDB\";\n            this.regPDB.aBitIDs = {0x80:\"HLD\",0x40:\"LCS\",0x20:\"SD1\",0x10:\"FR\",0x08:\"ST\",0x04:\"STI\",0x02:\"EE\",0x01:\"WE\"};\n            this.regCRB.sName = \"CRB\";\n            this.regCRB.aBitIDs = {0x80:\"IRQ1\",0x40:\"IRQ2\",0x20:\"C2OUT\",0x10:\"C2:1\",0x08:\"C2:0\",0x04:\"PDS\",0x02:\"C1:1\",0x01:\"C1:0\"};\n            this.regCTRL.sName = \"CTRL\";\n            this.regCTRL.aBitIDs = {0x80:\"CR7\",0x40:\"CR6\",0x20:\"CR5\",0x10:\"CR4\",0x08:\"CR3\",0x04:\"CR2\",0x02:\"CR1\",0x01:\"CR0\"};\n            this.regSTAT.sName = \"STAT\";\n            this.regDATA.sName = \"DATA\";\n            this.regUnknown.sName = \"unknown\";\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} iDrive\n    * @param {number} iDriveType\n    * @param {number} nMaxTracks\n    */\n    resetDrive(iDrive, iDriveType, nMaxTracks)\n    {\n        this.aDrives[iDrive] = {\n            iType: iDriveType,\n            nTracks: nMaxTracks,\n            fProtected: true,               // fake for now\n            nIndexPulse: 20,                // nIndex (20 is initial index pulse)\n            iTrackSelect: 0,                // nTrack\n            iTrackOffset: -1,               // nSector\n            /*\n             * Our disk data consists of an array of tracks, where each track is an array of sectors;\n             * as long as aTracks.length == 0 (empty array), the drive is not considered \"loaded\" with a disk.\n             */\n            aTracks: []\n        };\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n    * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"listDisk\")\n    * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n    * @param {string} [sValue] optional data value\n    * @return {boolean} true if binding was successful, false if unrecognized binding request\n    */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        switch(sBinding) {\n\n        case \"listDisk\":\n            this.bindings[sBinding] = control;\n            return true;\n\n        case \"loadDisk\":\n            this.bindings[sBinding] = control;\n            control.onclick = function(controller) {\n                return function() {\n                    if (controller.bindings[\"listDisk\"]) {\n                        var sFilePath = controller.bindings[\"listDisk\"].value;\n                        var sFileURL = sFilePath;\n                        /*\n                         * If the selected disk image has a \".json\" extension, then we assume it's a pre-converted\n                         * JSON-encoded disk image, so we load it as-is; otherwise, we ask our server-side disk image\n                         * converter to return the corresponding JSON-encoded data, in compact form (ie, minimal whitespace,\n                         * no ASCII data comments, etc).\n                         */\n                        if (sFilePath.substr(sFilePath.length-5) != \".json\") {\n                            /*\n                             * TODO: This code was using a deprecated parameter (compact=1); make sure things still work.\n                             *\n                             * TODO: Convert this code to use the new shared Disk API definitions and weblib functions; eg:\n                             *\n                             *      sDiskURL = Web.getHost() + DumpAPI.ENDPOINT + \"?\" + DumpAPI.QUERY.DISK + \"=\" + sDiskPath;\n                             */\n                            sFileURL = \"http://\" + window.location.host + \"/api/v1/dump?disk=\" + sFilePath;\n                        }\n                        controller.println(\"loading  \" + Str.getBaseName(sFilePath) + \"...\");\n                        Web.getResource(sFileURL, null, true, function(sURL, sResponse, nErrorCode) {\n                            controller.loadDisk(sURL, sResponse, nErrorCode);\n                        });\n                    }\n                };\n            }(this);\n            return true;\n\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {Array} abMemory\n    * @param {number} start\n    * @param {number} end\n    * @param {C1PCPU} cpu\n    */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.addrController = start;\n     // this.addrControllerLimit = end + 1;\n        if ((this.cpu = cpu)) {\n            cpu.addReadNotify(start, end, this, this.getByte);\n            cpu.addWriteNotify(start, end, this, this.setByte);\n        }\n        this.setReady();\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {boolean} fOn\n    * @param {C1PComputer} cmp\n    *\n    * We need We make a note of the Computer component, so that we can invoke its reset() method whenever we need to\n    * simulate a warm start, and we query the Keyboard component so that we can use its injectKeys() function.\n    */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {string} sDiskName\n    * @param {string} sDiskData\n    * @param {number} nErrorCode (response from server if anything other than 200)\n    *\n    * NOTE: Although I've expanded the JSON disk-image format to support multiple heads (ie, platters or disk surfaces),\n    * this controller implementation currently supports only single-head drives, and therefore only single-sided images.\n    * So, if the image contains more than one entry in head data array, all we use is the first entry; data for any remaining\n    * heads is discarded.\n    *\n    * WARNING: The disk-image format should match that used by PCjs, where the image is an array of cylinders, each of which\n    * is an array of heads.  That's also more typical, because it maintains the original data's physical locality.\n    */\n    loadDisk(sDiskName, sDiskData, nErrorCode)\n    {\n        if (nErrorCode) {\n            this.println(\"disk load error (\" + nErrorCode + \")\");\n            return;\n        }\n        var aHeads = [];\n        this.println(\"mounting \" + sDiskName + \"...\");\n        try {\n            /*\n             * The most likely source of any exception will be right here, where we're parsing\n             * the JSON-encoded disk data.\n             */\n            aHeads = eval(\"(\" + sDiskData + \")\");   // jshint ignore:line\n            if (!aHeads.length) {\n                this.println(\"no data: \" + sDiskName);\n                return;\n            }\n            if (!aHeads[0].length) {\n                this.println(\"no tracks: \" + sDiskName);\n                return;\n            }\n            var aTracks = aHeads[0];\n            if (aTracks[0]['trackNum'] === undefined) {\n                this.println(\"data error: \" + aTracks[0]);\n                return;\n            }\n            /*\n             * NOTE: This should never happen, otherwise we shouldn't have initiated the load\n             * in the first place. Can we guarantee that and eliminate this test?\n             */\n            if (!this.aDrives[0]) {\n                this.println(\"no available drives\");\n                return;\n            }\n            /*\n             * To make disk access more efficient, we need to supplement every track object with a\n             * simple byte-array (trackData) containing all the data bytes for the entire track.\n             */\n            for (var iTrack=0; iTrack < aTracks.length; iTrack++) {\n                var iTrackNum;\n                var track = aTracks[iTrack];\n                var sectors = track['sectors'];\n                /*\n                 * WARNING: There are MANY other ways the track data could be malformed, but we'll\n                 * start with the most egregious, and worry about the rest later.\n                 */\n                if ((iTrackNum = track['trackNum']) === undefined || sectors === undefined) {\n                    throw new Error(\"track \" + iTrack + \" missing data\");\n                }\n                /*\n                 * WARNING: We allow out-of-order tracks, because we store each track's data according\n                 * to its trackNum index, but just in case that wasn't intended, we're going to mention it.\n                 */\n                if (iTrackNum != iTrack) {\n                    Component.warning(\"track \" + iTrackNum + \" out of order (expected \" + iTrack + \")\");\n                }\n                /*\n                 * For each track, we start with an empty trackData array and \"push\" (ie, append) all the\n                 * sector data onto it. Most of the data is already in byte form and can simply use Array.push(),\n                 * but there is also some metadata (signatures, types, lengths, etc), for which we have assorted\n                 * helpers below: pushBCD, pushBin, and pushSig.\n                 */\n                var trackData = [], sector, sectorData, i;\n                if (!iTrackNum) {\n                    sector = sectors[0];\n                    sectorData = sector['sectorData'];\n                    this.pushBin(trackData, track, 'trackLoad', 2);\n                    this.pushBin(trackData, sector, 'sectorPages');\n                    for (i = 0; i < sectorData.length; i++) {\n                        trackData.push(sectorData[i]);\n                    }\n                }\n                else {\n                    this.pushSig(trackData, track, 'trackSig');\n                    this.pushBCD(trackData, track, 'trackNum');\n                    this.pushBin(trackData, track, 'trackType');\n                    for (var iSector=0; iSector < sectors.length; iSector++) {\n                        sector = sectors[iSector];\n                        sectorData = sector['sectorData'];\n                        this.pushBin(trackData, sector, 'sectorSig');\n                        this.pushBin(trackData, sector, 'sectorNum');\n                        this.pushBin(trackData, sector, 'sectorPages');\n                        for (i = 0; i < sectorData.length; i++) {\n                            trackData.push(sectorData[i]);\n                        }\n                        this.pushSig(trackData, sector, 'sectorEndSig');\n                    }\n                }\n                /*\n                 * Finally, here's where we add the newly-created chunk of track data to the current track object\n                 */\n                aTracks[iTrackNum].trackData = trackData;\n                if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_DISK)) {\n                    this.dbg.message(\"track \" + iTrackNum + \": \" + trackData.length + \" bytes\");\n                }\n            }\n            this.aDrives[0].aTracks = aTracks;\n            this.println(\"mount of \" + sDiskName + \" complete\");\n        } catch (e) {\n            this.println(\"disk data error: \" + e.message);\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {Array.<number>} a\n    * @param {Object} o is the object containing the key\n    * @param {string} k is the key of 8-bit value to convert to BCD (ie, two 4-bit BCD digits) and push\n    */\n    pushBCD(a, o, k)\n    {\n        var n = o[k];\n        if (n === undefined) {\n            throw new Error(\"missing bcd value: \" + k);\n        }\n        var bcd = (Math.floor(n / 10) << 4) | (n % 10);\n        a.push(bcd);\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {Array.<number>} a\n    * @param {Object} o is the object containing the key\n    * @param {string} k is the key of the value\n    * @param {number} [cb] is the number of bytes to push (only 1 or 2 is supported, and the default is 1)\n    */\n    pushBin(a, o, k, cb)\n    {\n        var n = o[k];\n        if (n === undefined) {\n            throw new Error(\"missing binary value: \" + k);\n        }\n        if (cb == 2) {\n            a.push((n >> 8) & 0xff);\n        }\n        a.push(n & 0xff);\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {Array.<number>} a\n    * @param {Object} o is the object containing the key\n    * @param {string} k is the key of the signature string to push\n    */\n    pushSig(a, o, k)\n    {\n        var s = o[k];\n        if (s === undefined) {\n            throw new Error(\"missing signature: \" + k);\n        }\n        for (var i=0; i < s.length; i++) {\n            a.push(s.charCodeAt(i));\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} port address (0x0000-0x00FF) relative to addrController (0xC000)\n    * @param {boolean} fWrite is true if port write, false if port read\n    * @return {Object} reg will always be a valid register object, but it may be the \"unknown\" register if we don't recognize the port.\n    */\n    getReg(port, fWrite)\n    {\n        var reg;\n        port &= 0x3F;\n        /*\n         * Now that we've masked the full port range of 0x00-0xFF down to 0x00-0x3F, we further mask the\n         * PIA port range (0x00-0x0F) to 0x00-0x03, and the ACIA port range (0x10-0x1F) to 0x10-0x11.\n         * The rest of the masked range (0x20-0x3F) is unmapped, so we map it to our global unknown register.\n         */\n        if (port < 0x10)\n            port &= 0x03;\n        else if (port < 0x20)\n            port &= 0x11;\n        switch(port) {\n        case this.PORT_PDA:\n            reg = (this.regCRA.bits & this.CR_PD_SEL)? this.regPDA : this.regDDA;\n            break;\n        case this.PORT_CRA:\n            reg = this.regCRA;\n            break;\n        case this.PORT_PDB:\n            reg = (this.regCRB.bits & this.CR_PD_SEL)? this.regPDB : this.regDDB;\n            break;\n        case this.PORT_CRB:\n            reg = this.regCRB;\n            break;\n        case this.PORT_CTRL:\n            reg = (fWrite? this.regCTRL : this.regSTAT);\n            break;\n        case this.PORT_DATA:\n            reg = this.regDATA;\n            break;\n        default:\n            reg = this.regUnknown;\n            break;\n        }\n        return reg;\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} addr\n    * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n    */\n    getByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this read (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            var port = addr - this.addrController;\n            var reg = this.getReg(port, false);\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_DISK, false, reg.sName);\n            reg.read();\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} addr\n    * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to write the specified addr)\n    */\n    setByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this write (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            var b = this.cpu.getByte(addr);\n            var port = addr - this.addrController;\n            var reg = this.getReg(port, true);\n            if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_DISK | this.dbg.MESSAGE_PORT)) {\n                this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_DISK, true, reg.sName);\n                if (reg.aBitIDs) {\n                    var bTest = 0x80;\n                    var bChanged = reg.bits ^ b;\n                    while (bChanged && bTest) {\n                        if (bChanged & bTest) {\n                            this.dbg.message(\"  changed \" + reg.sName + \".\" + reg.aBitIDs[bTest] + \" to \" + ((b & bTest)? \"1\" : \"0\"));\n                        }\n                        bTest >>= 1;\n                    }\n                }\n            }\n            reg.update(b);\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} bPDA\n    * @param {number} bPDB\n    */\n    setSelectedDrive(bPDA, bPDB)\n    {\n        var iDriveSelect = -1;\n        if (bPDA !== undefined && bPDB !== undefined) {\n            iDriveSelect = 0;\n            if (!(bPDB & this.PDB_SD1))\n                iDriveSelect |= 0x02;\n            if (!(this.regPDA.bits & this.PDA_SD2))\n                iDriveSelect |= 0x01;\n        }\n        if (this.iDriveSelect != iDriveSelect) {\n            this.iDriveSelect = iDriveSelect;\n            this.regSTAT.update();\n        }\n    }\n\n    /**\n     * @this {C1PDiskController}\n     */\n    startDriveData()\n    {\n        if (this.iDriveSelect >= 0) {\n            this.aDrives[this.iDriveSelect].iTrackOffset = 0;\n            this.advanceDriveData();\n        }\n    }\n\n    /**\n     * @this {C1PDiskController}\n     */\n    stopDriveData()\n    {\n        if (this.iDriveSelect >= 0) {\n            this.aDrives[this.iDriveSelect].iTrackOffset = -1;\n            this.regDATA.update(0xFF);          // QUESTION: Is this necessary or helpful in some way?\n            this.regSTAT.update();\n        }\n    }\n\n    /**\n     * @this {C1PDiskController}\n     * @return {number} current byte of data from the currently selected drive, or null if no (more) data available\n     */\n    advanceDriveData()\n    {\n        var b = null;\n        if (this.iDriveSelect >= 0) {\n            var drive = this.aDrives[this.iDriveSelect];\n            var track = drive.aTracks[drive.iTrackSelect];\n            if (track !== undefined) {\n                if (drive.iTrackOffset >= 0 && drive.iTrackOffset < track.trackData.length) {\n                    drive.nIndexPulse = 100;    // QUESTION: Necessary?\n                    b = track.trackData[drive.iTrackOffset++];\n                    this.regDATA.update(b);\n                    this.regSTAT.update();\n                }\n                else {\n                    drive.nIndexPulse = 10;     // QUESTION: Valid or necessary to force index pulse on next poll of $C000?\n                    this.stopDriveData();\n                }\n            }\n        }\n        return b;\n    }\n\n    /**\n     * updatePDA() calculates an updated value for the PDA register.\n     *\n     * In the process, this may also update iDriveSelect and assorted drive internal variables.\n     *\n     * @this {C1PDiskController}\n     * @param {number|undefined} bPDA\n     * @return {number} updated bits for PDA\n     */\n    updatePDA(bPDA)\n    {\n        if (bPDA === undefined)\n            bPDA = this.regPDA.bits;\n        else\n            this.setSelectedDrive(bPDA, this.regPDB.bits);\n\n        /*\n         * We start by turning ON most bits, except for PDA_RDY1, which we always leave\n         * OFF (indicating ready).  We leave PDA_SD2 alone, so that it reflects whatever\n         * the CPU had set.\n         *\n         * Then we dive into the update logic, which will turn OFF any of the bits we\n         * originally turned ON if the corresponding condition is true (because an OFF bit\n         * signals an active condition).\n         */\n        bPDA |= (this.PDA_IHD | this.PDA_WP | this.PDA_SHD | this.PDA_FD | this.PDA_TZD | this.PDA_RDY2);\n        bPDA &= ~(this.PDA_RDY1);\n\n        if (this.iDriveSelect >= 0) {\n\n            if (this.aDrives[this.iDriveSelect].aTracks.length) {\n\n                var drive = this.aDrives[this.iDriveSelect];\n\n                if (drive.fProtected) {\n                    bPDA &= ~this.PDA_WP;\n                }\n                if (!drive.iTrackSelect) {\n                    bPDA &= ~this.PDA_TZD;\n                }\n                /*\n                 * Simulate PHD_IHD (Index Hole Detect)\n                 */\n                if (--drive.nIndexPulse <= 10) {\n                    if (drive.nIndexPulse > 0) {\n                        bPDA &= ~this.PDA_IHD;\n                        this.stopDriveData();\n                    } else {\n                        drive.nIndexPulse = 100;\n                        this.startDriveData();\n                    }\n                }\n            }\n        }\n        return bPDA;\n    }\n\n    /**\n     * updatePDB() calculates an updated value for the PDB register.  However, since the\n     * PDB consists entirely of OUTPUT bits, none of the given bits should actually be modified.\n     *\n     * In the process, this may also update iDriveSelect and assorted drive internal variables,\n     * as well as selected PDA INPUT bits (hence the call to regPDA.update()).\n     *\n     * @this {C1PDiskController}\n     * @param {number|undefined} bPDB\n     * @return {number} updated bits for PDB\n     */\n    updatePDB(bPDB)\n    {\n        if (bPDB === undefined)\n            bPDB = this.regPDB.bits;\n        else\n            this.setSelectedDrive(this.regPDA.bits, bPDB);\n\n        if (this.iDriveSelect >= 0 && this.iDriveSelect < this.aDrives.length) {\n\n            var drive = this.aDrives[this.iDriveSelect];\n\n            if (drive.aTracks.length) {\n                /*\n                 * Is PDB_ST transitioning from 1 to 0?\n                 */\n                if ((this.regPDB.bits & this.PDB_ST) && !(bPDB & this.PDB_ST)) {\n                    /*\n                     *  PDB_STI == 0? step toward track 39 : step toward track 0\n                     */\n                    if (bPDB & this.PDB_STI)\n                        drive.iTrackSelect--;\n                    else\n                        drive.iTrackSelect++;\n\n                    if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_DISK)) {\n                        this.dbg.message(\"stepping \" + ((bPDB & this.PDB_STI)? \"down\" : \"up\") + \" to track \" + drive.iTrackSelect);\n                    }\n\n                    if (drive.iTrackSelect >= drive.nTracks)\n                        drive.iTrackSelect = drive.nTracks;\n\n                    if (drive.iTrackSelect < 0)\n                        drive.iTrackSelect = 0;\n\n                    drive.nIndexPulse = 20;\n\n                    this.regPDA.update(this.regPDA.bits | this.PDA_IHD);\n                    this.stopDriveData();\n                }\n            }\n        }\n        else if (DEBUG && this.iDriveSelect >= 0) {\n            this.println(\"updatePDB(\" + Str.toHexByte(bPDB) + \"): invalid drive: \" + this.iDriveSelect);\n        }\n        return bPDB;\n    }\n\n    /**\n     * updateSTAT() calculates an updated value for the ACIA Status register.\n     *\n     * @this {C1PDiskController}\n     * @param {number|undefined} bSTAT\n     * @return {number} updated bits for STAT\n     */\n    updateSTAT(bSTAT)\n    {\n        if (bSTAT === undefined)\n            bSTAT = this.regSTAT.bits;\n        bSTAT &= ~this.STAT_RDRF;\n        if (this.iDriveSelect >= 0 && this.aDrives[this.iDriveSelect].iTrackOffset >= 0)\n            bSTAT |= this.STAT_RDRF;\n        return bSTAT;\n    }\n\n    /**\n     * @this {C1PDiskController}\n     * @param {number} port\n     * @param {Object} reg\n     */\n    writePort(port, reg)\n    {\n        this.cpu.setByte(port + this.addrController, reg.bits);\n    }\n\n    /**\n     * @this {C1PDiskController}\n     * @param {boolean} fLoaded is true if the selected drive must be loaded, false if don't care\n     * @return {Object} drive reference to the selected drive, or null if no drive is selected or it doesn't meet the fLoaded requirement\n     *\n     getSelectedDrive(fLoaded)\n     {\n         var drive = null;\n         if (this.iDriveSelect >= 0) {\n             if (this.aDrives[this.iDriveSelect]) {\n                 if (!fLoaded || this.aDrives[this.iDriveSelect].aTracks.length)\n                     drive = this.aDrives[this.iDriveSelect];\n             }\n         }\n         return drive;\n     }\n     */\n\n    /**\n     * C1PDiskController.init()\n     *\n     * This function operates on every HTML element of class \"disk\", extracting the\n     * JSON-encoded parameters for the C1PDiskController constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PDiskController component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeDC = Component.getElementsByClass(document, C1PJS.APPCLASS, \"disk\");\n        for (var iDC=0; iDC < aeDC.length; iDC++) {\n            var eDC = aeDC[iDC];\n            var parmsDC = Component.getComponentParms(eDC);\n            var controller = new C1PDiskController(parmsDC);\n            Component.bindComponentControls(controller, eDC, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize every DiskController module on the page.\n */\nWeb.onInit(C1PDiskController.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/debugger.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * @class C1PDebugger\n * @unrestricted\n */\nclass C1PDebugger extends Component {\n    /**\n     * C1PDebugger(parmsDbg)\n     *\n     * The C1PDebugger component has no required (parmsDbg) properties.\n     *\n     * The C1PDebugger component is an optional component that implements a variety of user\n     * commands for controlling the CPU, dumping and editing memory, etc.\n     *\n     * @this {C1PDebugger}\n     * @param {Object} parmsDbg\n     */\n    constructor(parmsDbg)\n    {\n        if (DEBUGGER) {\n\n            super(\"C1PDebugger\", parmsDbg);\n\n            this.dbg = this;\n            /*\n             * This keeps track of instruction activity, but only when tracing or when\n             * Debugger checks have been enabled (eg, one or more breakpoints have been set).\n             *\n             * This is zeroed by CPU notification handlers reset() and stopped().\n             * We set it here to -1 to indicate that the CPU has not yet initialized us.\n             */\n            this.cIns = -1;\n\n            /*\n             * Some commands, like the dump (d) command, start at nextAddr when no address\n             * is given (and they also update nextAddr when they're done).\n             */\n            this.nextAddr = 0;\n\n            /*\n             * When Enter is pressed on an empty input buffer, we default to the previous\n             * command, which is preserved here.\n             */\n            this.prevCmd = null;\n\n            /*\n             * fAssemble is true when \"assemble mode\" is active, false when not.\n             */\n            this.fAssemble = false;\n            this.addrAssembleNext = 0;\n\n            /*\n             * Initialize the lists of breakpoint addresses.  aExecBreak is a list (Array) of addresses\n             * to halt at whenever attempting to execute an instruction at the corresponding address,\n             * and aReadBreak and aWriteBreak are lists of addresses to halt at whenever a read or write,\n             * respectively, occurs at the corresponding address.\n             */\n            this.clearBreakpoints();\n\n            /*\n             * Instead of pre-allocating these arrays, we wait until our reset() function is called.\n             * These arrays are updated in checkInstruction(), but the CPU will never actually call it\n             * unless checksEnabled() returns true, and that won't happen until one or more breakpoints\n             * have been set.  This ensures that, by default, the CPU runs as fast as possible.\n             */\n            this.iStepHistory = 0;\n            this.aStepHistory = [];\n            this.aaOpcodeFreqs = [];\n\n            /*\n             * This \"info\" buffer is a lightweight logging mechanism that has minimal impact on the\n             * browser (unlike printing to either window.console.log or an HTML control, which can make\n             * the browser unusable if printing is too frequent).  The Debugger's \"i\" command dumps\n             * this buffer.  Note that dumping too much at once can also bog things down, but by that\n             * point, you've presumably already captured the info you need and are willing to wait.\n             */\n            if (DEBUG) {\n                this.iInfoBuffer = 0;\n                this.aInfoBuffer = new Array(10000);\n            }\n\n            /*\n             * Message categories supported by the message() function; they are designed to be combined\n             * (ie, OR'ed) as needed.  The Debugger's \"option\" command is used to turn message categories\n             * on and off, like so:\n             *\n             *      o msg port on\n             *      o msg port off\n             *      ...\n             */\n            this.MESSAGE_PORT   = 0x01;\n            this.MESSAGE_KBD    = 0x10;\n            this.MESSAGE_VIDEO  = 0x20;\n            this.MESSAGE_DISK   = 0x40;\n            this.MESSAGE_SERIAL = 0x80;\n            this.MESSAGE_NONE   = 0x00;\n         // this.MESSAGE_ALL    = 0xff;\n            this.bitsMessage = this.MESSAGE_NONE;\n            this.aMessageCategories = {\n                'port':     this.MESSAGE_PORT,\n                'kbd':      this.MESSAGE_KBD,\n                'video':    this.MESSAGE_VIDEO,\n                'disk':     this.MESSAGE_DISK,\n                'serial':   this.MESSAGE_SERIAL\n            };\n\n            /*\n             * The aaOperations array is indexed by opcode, and each element is a sub-array that\n             * describes the corresponding opcode. The sub-elements are as follows:\n             *\n             *      [0]: {number} of the operation code (see OP_*)\n             *      [1]: {number} of additional bytes following the opcode byte, if any\n             *      [2]: {number} of the operation mode operand, if any (see MODE_*)\n             *\n             * These sub-elements are all optional. If [0] is not present, the opcode is undefined;\n             * if [1] is not present (or contains a zero), the opcode is a single-byte opcode; and if\n             * [2] is not present, the opcode uses no (or implied) operands.\n             */\n            this.OP_ADC = 0;\n            this.OP_AND = 1;\n            this.OP_ASL = 2;\n            this.OP_BCC = 3;\n            this.OP_BCS = 4;\n            this.OP_BEQ = 5;\n            this.OP_BIT = 6;\n            this.OP_BMI = 7;\n            this.OP_BNE = 8;\n            this.OP_BPL = 9;\n            this.OP_BRK = 10;\n            this.OP_BVC = 11;\n            this.OP_BVS = 12;\n            this.OP_CLC = 13;\n            this.OP_CLD = 14;\n            this.OP_CLI = 15;\n            this.OP_CLV = 16;\n            this.OP_CMP = 17;\n            this.OP_CPX = 18;\n            this.OP_CPY = 19;\n            this.OP_DEC = 20;\n            this.OP_DEX = 21;\n            this.OP_DEY = 22;\n            this.OP_EOR = 23;\n            this.OP_INC = 24;\n            this.OP_INX = 25;\n            this.OP_INY = 26;\n            this.OP_JMP = 27;\n            this.OP_JSR = 28;\n            this.OP_LDA = 29;\n            this.OP_LDX = 30;\n            this.OP_LDY = 31;\n            this.OP_LSR = 32;\n            this.OP_NOP = 33;\n            this.OP_ORA = 34;\n            this.OP_PHA = 35;\n            this.OP_PHP = 36;\n            this.OP_PLA = 37;\n            this.OP_PLP = 38;\n            this.OP_ROL = 39;\n            this.OP_ROR = 40;\n            this.OP_RTI = 41;\n            this.OP_RTS = 42;\n            this.OP_SBC = 43;\n            this.OP_SEC = 44;\n            this.OP_SED = 45;\n            this.OP_SEI = 46;\n            this.OP_STA = 47;\n            this.OP_STX = 48;\n            this.OP_STY = 49;\n            this.OP_TAX = 50;\n            this.OP_TAY = 51;\n            this.OP_TSX = 52;\n            this.OP_TXA = 53;\n            this.OP_TXS = 54;\n            this.OP_TYA = 55;\n            this.OP_SIM = 56;\n            this.OP_DB  = 57;\n\n            this.aOpCodes = [\n                \"ADC\",\"AND\",\"ASL\",\"BCC\",\"BCS\",\"BEQ\",\"BIT\",\"BMI\",\n                \"BNE\",\"BPL\",\"BRK\",\"BVC\",\"BVS\",\"CLC\",\"CLD\",\"CLI\",\n                \"CLV\",\"CMP\",\"CPX\",\"CPY\",\"DEC\",\"DEX\",\"DEY\",\"EOR\",\n                \"INC\",\"INX\",\"INY\",\"JMP\",\"JSR\",\"LDA\",\"LDX\",\"LDY\",\n                \"LSR\",\"NOP\",\"ORA\",\"PHA\",\"PHP\",\"PLA\",\"PLP\",\"ROL\",\n                \"ROR\",\"RTI\",\"RTS\",\"SBC\",\"SEC\",\"SED\",\"SEI\",\"STA\",\n                \"STX\",\"STY\",\"TAX\",\"TAY\",\"TSX\",\"TXA\",\"TXS\",\"TYA\",\n                \"SIM\",\".DB\"\n            ];\n\n            this.aOpSimCodes = [\n                \"HLT\", \"MSG\"\n            ];\n\n            this.setOpModes(true);\n\n            this.aaOperations = [\n                /* 0x00 */ [this.OP_BRK],\n                /* 0x01 */ [this.OP_ORA, 1, this.MODE_INDX],\n                /* 0x02 */ [this.OP_SIM, 1],\n                /* 0x03 */ [],\n                /* 0x04 */ [],\n                /* 0x05 */ [this.OP_ORA, 1, this.MODE_ZP],\n                /* 0x06 */ [this.OP_ASL, 1, this.MODE_ZP],\n                /* 0x07 */ [],\n                /* 0x08 */ [this.OP_PHP],\n                /* 0x09 */ [this.OP_ORA, 1, this.MODE_IMM],\n                /* 0x0a */ [this.OP_ASL, 0, this.MODE_ACC],\n                /* 0x0b */ [],\n                /* 0x0c */ [],\n                /* 0x0d */ [this.OP_ORA, 2, this.MODE_ABS],\n                /* 0x0e */ [this.OP_ASL, 2, this.MODE_ABS],\n                /* 0x0f */ [],\n                /* 0x10 */ [this.OP_BPL, 1, this.MODE_DISP],\n                /* 0x11 */ [this.OP_ORA, 1, this.MODE_INDY],\n                /* 0x12 */ [],\n                /* 0x13 */ [],\n                /* 0x14 */ [],\n                /* 0x15 */ [this.OP_ORA, 1, this.MODE_ZPX],\n                /* 0x16 */ [this.OP_ASL, 1, this.MODE_ZPX],\n                /* 0x17 */ [],\n                /* 0x18 */ [this.OP_CLC],\n                /* 0x19 */ [this.OP_ORA, 2, this.MODE_ABSY],\n                /* 0x1a */ [],\n                /* 0x1b */ [],\n                /* 0x1c */ [],\n                /* 0x1d */ [this.OP_ORA, 2, this.MODE_ABSX],\n                /* 0x1e */ [this.OP_ASL, 2, this.MODE_ABSX],\n                /* 0x1f */ [],\n                /* 0x20 */ [this.OP_JSR, 2, this.MODE_IMM16],\n                /* 0x21 */ [this.OP_AND, 1, this.MODE_INDX],\n                /* 0x22 */ [],\n                /* 0x23 */ [],\n                /* 0x24 */ [this.OP_BIT, 1, this.MODE_ZP],\n                /* 0x25 */ [this.OP_AND, 1, this.MODE_ZP],\n                /* 0x26 */ [this.OP_ROL, 1, this.MODE_ZP],\n                /* 0x27 */ [],\n                /* 0x28 */ [this.OP_PLP],\n                /* 0x29 */ [this.OP_AND, 1, this.MODE_IMM],\n                /* 0x2a */ [this.OP_ROL, 0, this.MODE_ACC],\n                /* 0x2b */ [],\n                /* 0x2c */ [this.OP_BIT, 2, this.MODE_ABS],\n                /* 0x2d */ [this.OP_AND, 2, this.MODE_ABS],\n                /* 0x2e */ [this.OP_ROL, 2, this.MODE_ABS],\n                /* 0x2f */ [],\n                /* 0x30 */ [this.OP_BMI, 1, this.MODE_DISP],\n                /* 0x31 */ [this.OP_AND, 1, this.MODE_INDY],\n                /* 0x32 */ [],\n                /* 0x33 */ [],\n                /* 0x34 */ [],\n                /* 0x35 */ [this.OP_AND, 1, this.MODE_ZPX],\n                /* 0x36 */ [this.OP_ROL, 1, this.MODE_ZPX],\n                /* 0x37 */ [],\n                /* 0x38 */ [this.OP_SEC],\n                /* 0x39 */ [this.OP_AND, 2, this.MODE_ABSY],\n                /* 0x3a */ [],\n                /* 0x3b */ [],\n                /* 0x3c */ [],\n                /* 0x3d */ [this.OP_AND, 2, this.MODE_ABSX],\n                /* 0x3e */ [this.OP_ROL, 2, this.MODE_ABSX],\n                /* 0x3f */ [],\n                /* 0x40 */ [this.OP_RTI],\n                /* 0x41 */ [this.OP_EOR, 1, this.MODE_INDX],\n                /* 0x42 */ [],\n                /* 0x43 */ [],\n                /* 0x44 */ [],\n                /* 0x45 */ [this.OP_EOR, 1, this.MODE_ZP],\n                /* 0x46 */ [this.OP_LSR, 1, this.MODE_ZP],\n                /* 0x47 */ [],\n                /* 0x48 */ [this.OP_PHA],\n                /* 0x49 */ [this.OP_EOR, 1, this.MODE_IMM],\n                /* 0x4a */ [this.OP_LSR, 0, this.MODE_ACC],\n                /* 0x4b */ [],\n                /* 0x4c */ [this.OP_JMP, 2, this.MODE_IMM16],\n                /* 0x4d */ [this.OP_EOR, 2, this.MODE_ABS],\n                /* 0x4e */ [this.OP_LSR, 2, this.MODE_ABS],\n                /* 0x4f */ [],\n                /* 0x50 */ [this.OP_BVC, 1, this.MODE_DISP],\n                /* 0x51 */ [this.OP_EOR, 1, this.MODE_INDY],\n                /* 0x52 */ [],\n                /* 0x53 */ [],\n                /* 0x54 */ [],\n                /* 0x55 */ [this.OP_EOR, 1, this.MODE_ZPX],\n                /* 0x56 */ [this.OP_LSR, 1, this.MODE_ZPX],\n                /* 0x57 */ [],\n                /* 0x58 */ [this.OP_CLI],\n                /* 0x59 */ [this.OP_EOR, 2, this.MODE_ABSY],\n                /* 0x5a */ [],\n                /* 0x5b */ [],\n                /* 0x5c */ [],\n                /* 0x5d */ [this.OP_EOR, 2, this.MODE_ABSX],\n                /* 0x5e */ [this.OP_LSR, 2, this.MODE_ABSX],\n                /* 0x5f */ [],\n                /* 0x60 */ [this.OP_RTS],\n                /* 0x61 */ [this.OP_ADC, 1, this.MODE_INDX],\n                /* 0x62 */ [],\n                /* 0x63 */ [],\n                /* 0x64 */ [],\n                /* 0x65 */ [this.OP_ADC, 1, this.MODE_ZP],\n                /* 0x66 */ [this.OP_ROR, 1, this.MODE_ZP],\n                /* 0x67 */ [],\n                /* 0x68 */ [this.OP_PLA],\n                /* 0x69 */ [this.OP_ADC, 1, this.MODE_IMM],\n                /* 0x6a */ [this.OP_ROR, 0, this.MODE_ACC],\n                /* 0x6b */ [],\n                /* 0x6c */ [this.OP_JMP, 2, this.MODE_ABS16],\n                /* 0x6d */ [this.OP_ADC, 2, this.MODE_ABS],\n                /* 0x6e */ [this.OP_ROR, 2, this.MODE_ABS],\n                /* 0x6f */ [],\n                /* 0x70 */ [this.OP_BVS, 1, this.MODE_DISP],\n                /* 0x71 */ [this.OP_ADC, 1, this.MODE_INDY],\n                /* 0x72 */ [],\n                /* 0x73 */ [],\n                /* 0x74 */ [],\n                /* 0x75 */ [this.OP_ADC, 1, this.MODE_ZPX],\n                /* 0x76 */ [this.OP_ROR, 1, this.MODE_ZPX],\n                /* 0x77 */ [],\n                /* 0x78 */ [this.OP_SEI],\n                /* 0x79 */ [this.OP_ADC, 2, this.MODE_ABSY],\n                /* 0x7a */ [],\n                /* 0x7b */ [],\n                /* 0x7c */ [],\n                /* 0x7d */ [this.OP_ADC, 2, this.MODE_ABSX],\n                /* 0x7e */ [this.OP_ROR, 2, this.MODE_ABSX],\n                /* 0x7f */ [],\n                /* 0x80 */ [],\n                /* 0x81 */ [this.OP_STA, 1, this.MODE_INDX],\n                /* 0x82 */ [],\n                /* 0x83 */ [],\n                /* 0x84 */ [this.OP_STY, 1, this.MODE_ZP],\n                /* 0x85 */ [this.OP_STA, 1, this.MODE_ZP],\n                /* 0x86 */ [this.OP_STX, 1, this.MODE_ZP],\n                /* 0x87 */ [],\n                /* 0x88 */ [this.OP_DEY],\n                /* 0x89 */ [],\n                /* 0x8a */ [this.OP_TXA],\n                /* 0x8b */ [],\n                /* 0x8c */ [this.OP_STY, 2, this.MODE_ABS],\n                /* 0x8d */ [this.OP_STA, 2, this.MODE_ABS],\n                /* 0x8e */ [this.OP_STX, 2, this.MODE_ABS],\n                /* 0x8f */ [],\n                /* 0x90 */ [this.OP_BCC, 1, this.MODE_DISP],\n                /* 0x91 */ [this.OP_STA, 1, this.MODE_INDY],\n                /* 0x92 */ [],\n                /* 0x93 */ [],\n                /* 0x94 */ [this.OP_STY, 1, this.MODE_ZPX],\n                /* 0x95 */ [this.OP_STA, 1, this.MODE_ZPX],\n                /* 0x96 */ [this.OP_STX, 1, this.MODE_ZPY],\n                /* 0x97 */ [],\n                /* 0x98 */ [this.OP_TYA],\n                /* 0x99 */ [this.OP_STA, 2, this.MODE_ABSY],\n                /* 0x9a */ [this.OP_TXS],\n                /* 0x9b */ [],\n                /* 0x9c */ [],\n                /* 0x9d */ [this.OP_STA, 2, this.MODE_ABSX],\n                /* 0x9e */ [],\n                /* 0x9f */ [],\n                /* 0xa0 */ [this.OP_LDY, 1, this.MODE_IMM],\n                /* 0xa1 */ [this.OP_LDA, 1, this.MODE_INDX],\n                /* 0xa2 */ [this.OP_LDX, 1, this.MODE_IMM],\n                /* 0xa3 */ [],\n                /* 0xa4 */ [this.OP_LDY, 1, this.MODE_ZP],\n                /* 0xa5 */ [this.OP_LDA, 1, this.MODE_ZP],\n                /* 0xa6 */ [this.OP_LDX, 1, this.MODE_ZP],\n                /* 0xa7 */ [],\n                /* 0xa8 */ [this.OP_TAY],\n                /* 0xa9 */ [this.OP_LDA, 1, this.MODE_IMM],\n                /* 0xaa */ [this.OP_TAX],\n                /* 0xab */ [],\n                /* 0xac */ [this.OP_LDY, 2, this.MODE_ABS],\n                /* 0xad */ [this.OP_LDA, 2, this.MODE_ABS],\n                /* 0xae */ [this.OP_LDX, 2, this.MODE_ABS],\n                /* 0xaf */ [],\n                /* 0xb0 */ [this.OP_BCS, 1, this.MODE_DISP],\n                /* 0xb1 */ [this.OP_LDA, 1, this.MODE_INDY],\n                /* 0xb2 */ [],\n                /* 0xb3 */ [],\n                /* 0xb4 */ [this.OP_LDY, 1, this.MODE_ZPX],\n                /* 0xb5 */ [this.OP_LDA, 1, this.MODE_ZPX],\n                /* 0xb6 */ [this.OP_LDX, 1, this.MODE_ZPY],\n                /* 0xb7 */ [],\n                /* 0xb8 */ [this.OP_CLV],\n                /* 0xb9 */ [this.OP_LDA, 2, this.MODE_ABSY],\n                /* 0xba */ [this.OP_TSX],\n                /* 0xbb */ [],\n                /* 0xbc */ [this.OP_LDY, 2, this.MODE_ABSX],\n                /* 0xbd */ [this.OP_LDA, 2, this.MODE_ABSX],\n                /* 0xbe */ [this.OP_LDX, 2, this.MODE_ABSY],\n                /* 0xbf */ [],\n                /* 0xc0 */ [this.OP_CPY, 1, this.MODE_IMM],\n                /* 0xc1 */ [this.OP_CMP, 1, this.MODE_INDX],\n                /* 0xc2 */ [],\n                /* 0xc3 */ [],\n                /* 0xc4 */ [this.OP_CPY, 1, this.MODE_ZP],\n                /* 0xc5 */ [this.OP_CMP, 1, this.MODE_ZP],\n                /* 0xc6 */ [this.OP_DEC, 1, this.MODE_ZP],\n                /* 0xc7 */ [],\n                /* 0xc8 */ [this.OP_INY],\n                /* 0xc9 */ [this.OP_CMP, 1, this.MODE_IMM],\n                /* 0xca */ [this.OP_DEX],\n                /* 0xcb */ [],\n                /* 0xcc */ [this.OP_CPY, 2, this.MODE_ABS],\n                /* 0xcd */ [this.OP_CMP, 2, this.MODE_ABS],\n                /* 0xce */ [this.OP_DEC, 2, this.MODE_ABS],\n                /* 0xcf */ [],\n                /* 0xd0 */ [this.OP_BNE, 1, this.MODE_DISP],\n                /* 0xd1 */ [this.OP_CMP, 1, this.MODE_INDY],\n                /* 0xd2 */ [],\n                /* 0xd3 */ [],\n                /* 0xd4 */ [],\n                /* 0xd5 */ [this.OP_CMP, 1, this.MODE_ZPX],\n                /* 0xd6 */ [this.OP_DEC, 1, this.MODE_ZPX],\n                /* 0xd7 */ [],\n                /* 0xd8 */ [this.OP_CLD],\n                /* 0xd9 */ [this.OP_CMP, 2, this.MODE_ABSY],\n                /* 0xda */ [],\n                /* 0xdb */ [],\n                /* 0xdc */ [],\n                /* 0xdd */ [this.OP_CMP, 2, this.MODE_ABSX],\n                /* 0xde */ [this.OP_DEC, 2, this.MODE_ABSX],\n                /* 0xdf */ [],\n                /* 0xe0 */ [this.OP_CPX, 1, this.MODE_IMM],\n                /* 0xe1 */ [this.OP_SBC, 1, this.MODE_INDX],\n                /* 0xe2 */ [],\n                /* 0xe3 */ [],\n                /* 0xe4 */ [this.OP_CPX, 1, this.MODE_ZP],\n                /* 0xe5 */ [this.OP_SBC, 1, this.MODE_ZP],\n                /* 0xe6 */ [this.OP_INC, 1, this.MODE_ZP],\n                /* 0xe7 */ [],\n                /* 0xe8 */ [this.OP_INX],\n                /* 0xe9 */ [this.OP_SBC, 1, this.MODE_IMM],\n                /* 0xea */ [this.OP_NOP],\n                /* 0xeb */ [],\n                /* 0xec */ [this.OP_CPX, 2, this.MODE_ABS],\n                /* 0xed */ [this.OP_SBC, 2, this.MODE_ABS],\n                /* 0xee */ [this.OP_INC, 2, this.MODE_ABS],\n                /* 0xef */ [],\n                /* 0xf0 */ [this.OP_BEQ, 1, this.MODE_DISP],\n                /* 0xf1 */ [this.OP_SBC, 1, this.MODE_INDY],\n                /* 0xf2 */ [],\n                /* 0xf3 */ [],\n                /* 0xf4 */ [],\n                /* 0xf5 */ [this.OP_SBC, 1, this.MODE_ZPX],\n                /* 0xf6 */ [this.OP_INC, 1, this.MODE_ZPX],\n                /* 0xf7 */ [],\n                /* 0xf8 */ [this.OP_SED],\n                /* 0xf9 */ [this.OP_SBC, 2, this.MODE_ABSY],\n                /* 0xfa */ [],\n                /* 0xfb */ [],\n                /* 0xfc */ [],\n                /* 0xfd */ [this.OP_SBC, 2, this.MODE_ABSX],\n                /* 0xfe */ [this.OP_INC, 2, this.MODE_ABSX],\n                /* 0xff */ []\n            ];\n\n        }   // endif DEBUGGER\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\", \"canvas\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"reset\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        var dbg = this;\n        switch(sBinding) {\n        case \"debugInput\":\n            this.bindings[sBinding] = control;\n            this.eDebug = /** @type {HTMLInputElement} */ (control);\n            this.eDebug.focus();\n            control.onkeypress = function(dbg, e) {\n                return function(event) {\n                    if (event.keyCode == 13) {\n                        sBinding = e.value;\n                        e.value = \"\";\n                        C1PDebugger.input(dbg, sBinding);\n                    }\n                };\n            }(this, control);\n            return true;\n            \n        case \"debugEnter\":\n            this.bindings[sBinding] = control;\n            /*\n             * I've replaced the standard \"onclick\" code with a call to our onClickRepeat() helper in\n             * component.js, so that the \"Enter\" button can be held to repeat, just like the \"Step\" button.\n             */\n            Web.onClickRepeat(\n                control, 500, 100,\n                function(fRepeat) {\n                    if (dbg.eDebug) {\n                        sBinding = dbg.eDebug.value;\n                        //\n                        //  If we want to use the debugEnter button to repeatedly enter the same command,\n                        //  then don't clear the command string.\n                        //\n                        //      dbg.eDebug.value = \"\";\n                        //\n                        C1PDebugger.input(dbg, sBinding);\n                        return true;\n                    }\n                    if (DEBUG) dbg.log(\"no debugger input buffer\");\n                    return false;\n                }\n            );\n            return true;\n            \n        case \"step\":\n            this.bindings[sBinding] = control;\n            Web.onClickRepeat(\n                control, 500, 100,\n                function(fRepeat) {\n                    var fCompleted = false;\n                    if (!dbg.isBusy(true)) {\n                        dbg.setBusy(true);\n                        fCompleted = dbg.step(fRepeat? 1 : 0);\n                        dbg.setBusy(false);\n                    }\n                    return fCompleted;\n                }\n            );\n            return true;\n            \n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     */\n    setBuffer(abMemory, start, end)\n    {\n        this.abMem = abMemory;\n        this.offMem = start;\n        this.cbMem = end - start + 1;\n        this.offLimit = this.offMem + this.cbMem;\n        this.setReady();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            this.cpu = cmp.getComponentByType(\"cpu\");\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    setFocus()\n    {\n        this.eDebug.focus();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {boolean} fClassic is true for \"classic\" operand syntax, or false for \"modern\" operand syntax\n     *\n     * The strings describing the operand(s) also describe the addressing mode, as follows:\n     *\n     *      bbb     mode    classic     modern         description\n     *      ---     ----    -------     -------         ----------------\n     *      000     INDX    ($nn,X)     [[nn+X]]        Indexed Indirect\n     *      001     ZP      $nn         [nn]            Zero-Page\n     *      010     IMM     #$nn        nn              Immediate\n     *      011     ABS     $nnnn       [nnnn]          Absolute\n     *      100     INDY    ($nn),Y     [[nn]+Y]        Indirect Indexed\n     *      101     ZPX     $nn,X       [nn+X]          Zero-Page,X\n     *      110     ABSY    $nnnn,Y     [nnnn+Y]        Absolute,Y\n     *      111     ABSX    $nnnn,X     [nnnn+X]        Absolute,X\n     *\n     * where bbb generally corresponds to bits 2-4 of the opcode.  I find that using brackets in the\n     * descriptors to indicate a memory access (or multiple brackets, in the case of indirect accesses),\n     * along with \"+\" and any index register, is more intuitive than the \"classic\" operand formats;\n     * the absence of any brackets implies immediate data, eliminating the need for a prepended \"#\".\n     * Also, the use of 2-digit instead of 4-digit addresses indicates that a zero-page address is\n     * being used.  Finally, all displacements/addresses and immediate values are displayed in hex by\n     * default, so there is no need to waste space prepending the traditional \"$\" to such values.\n     *\n     * Other addressing modes:\n     *\n     *      101     ZPY     $nn,Y           Zero-Page,Y (used by LDX and STX only)\n     *\n     *              ACC     A               Accumulator\n     *\n     *              IMM16   $nnnn           Used by JSR (0x20) and JMP (0x4C); I consider this an \"Immediate\" operation\n     *                                      that uses 16 bits, but it is documented as \"Absolute\" addressing (see Zaks)\n     *\n     *                                      FYI, this is the same operand format used for branch displacements (MODE_DISP),\n     *                                      except the displacements are 8-bit values that are signed-extended to 16 bits, so\n     *                                      discriminating between MODE_DISP and MODE_IMM16 also requires checking the operand size\n     *\n     *              ABS16   ($nnnn)         Used by JMP (0x6C); I consider this an \"Absolute\" operation that fetches\n     *                                      16 bits of data, but it is documented as \"Indirect\" addressing (see Zaks)\n     */\n    setOpModes(fClassic)\n    {\n        /*\n         * NOTE: The modes are arranged within aOpModes so that longer matches are checked before\n         * any subsets that could also match (eg, check for \"$nn,X\" before \"$nn\", \"$nnnn,X\" before \"$nnnn\", etc).\n         */\n        this.MODE_ACC   = 0;\n        this.MODE_IMM   = 1;\n        this.MODE_ABSX  = 2;\n        this.MODE_ABSY  = 3;\n        this.MODE_IMM16 = 4;\n        this.MODE_ABS16 = 5;\n        this.MODE_ZPX   = 6;\n        this.MODE_ZPY   = 7;\n        this.MODE_INDX  = 8;\n        this.MODE_INDY  = 9;\n        this.MODE_ABS   = 10;\n        this.MODE_ZP    = 11;\n        this.MODE_DISP  = this.MODE_IMM16;\n\n        var sRegEx = \"\";\n        var iMode, sMode;\n\n        if (fClassic) {\n            this.aOpModes = [\n                            \"A\",            // MODE_ACC\n                /* 010b */  \"#$nn\",         // MODE_IMM\n                /* 111b */  \"$nnnn,X\",      // MODE_ABSX\n                /* 110b */  \"$nnnn,Y\",      // MODE_ABSY\n                            \"$nnnn\",        // MODE_IMM16\n                            \"($nnnn)\",      // MODE_ABS16\n                /* 101b */  \"$nn,X\",        // MODE_ZPX\n                            \"$nn,Y\",        // MODE_ZPY\n                /* 000b */  \"($nn,X)\",      // MODE_INDX\n                /* 100b */  \"($nn),Y\",      // MODE_INDY\n                /* 011b */  \"$nnnn\",        // MODE_ABS\n                /* 001b */  \"$nn\"           // MODE_ZP\n            ];\n            for (iMode=0; iMode < this.aOpModes.length; iMode++) {\n                sMode = this.aOpModes[iMode];\n                sRegEx += \"(\" + sMode.replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\").replace(/nnnn/g, \"[0-9A-F][0-9A-F][0-9A-F][0-9A-F]?\").replace(/nn/g, \"[0-9A-F][0-9A-F]?\").replace(/\\$/g, \"\\\\$\") + \"|)\";\n            }\n            this.regexOpModes = new RegExp(sRegEx);\n        }\n        else {\n            this.aOpModes = [\n                            \"A\",            // MODE_ACC\n                /* 010b */  \"nn\",           // MODE_IMM\n                /* 111b */  \"[nnnn+X]\",     // MODE_ABSX\n                /* 110b */  \"[nnnn+Y]\",     // MODE_ABSY\n                            \"nnnn\",         // MODE_IMM16\n                            \"[nnnn]\",       // MODE_ABS16\n                /* 101b */  \"[nn+X]\",       // MODE_ZPX\n                            \"[nn+Y]\",       // MODE_ZPY\n                /* 000b */  \"[[nn+X]]\",     // MODE_INDX\n                /* 100b */  \"[[nn]+Y]\",     // MODE_INDY\n                /* 011b */  \"[nnnn]\",       // MODE_ABS\n                /* 001b */  \"[nn]\"          // MODE_ZP\n            ];\n            for (iMode=0; iMode < this.aOpModes.length; iMode++) {\n                sMode = this.aOpModes[iMode];\n                sRegEx += \"(\" + sMode.replace(/\\[/g, \"\\\\[\").replace(/]/g, \"\\\\]\").replace(/nnnn/g, \"[0-9A-F][0-9A-F][0-9A-F][0-9A-F]?\").replace(/nn/g, \"[0-9A-F][0-9A-F]?\").replace(/\\+/g, \"\\\\+\") + \"|)\";\n            }\n            this.regexOpModes = new RegExp(sRegEx);\n        }\n        /*\n         * Regrettably, if \"classic\" operand syntax is in effect, then we will have to look at the context of the\n         * operand (ie, the operation code) whenever we have a MODE_IMM16 (or MODE_DISP) match, because it might actually\n         * be a MODE_ABS operand.  MODE_IMM16 is used with only 2 operations (OP_JSR and OP_JMP), and MODE_DISP only 8\n         * (OP_BPL, OP_BMI, OP_BVC, OP_BVS, OP_BCC, OP_BCS, OP_BNE, and OP_BEQ), so if the operation isn't one of those\n         * codes (in the following array), then we should convert MODE_IMM16 (aka MODE_DISP) into MODE_ABS.\n         */\n        this.aImm16Codes = [this.OP_JMP, this.OP_JSR, this.OP_BPL, this.OP_BMI, this.OP_BVC, this.OP_BVS, this.OP_BCC, this.OP_BCS, this.OP_BNE, this.OP_BEQ];\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    halt()\n    {\n        /*\n         * We ask the CPU to halt, but we can't assume it's stopped until it calls stop()\n         */\n        this.cpu.halt();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} s is any diagnostic string that you can print later using the Debugger's \"i\" command\n     */\n    info(s)\n    {\n        if (DEBUG) {\n            this.aInfoBuffer[this.iInfoBuffer++] = s;\n            if (this.iInfoBuffer >= this.aInfoBuffer.length)\n                this.iInfoBuffer = 0;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Component} component\n     * @param {number} addr\n     * @param {number|undefined} addrFrom\n     * @param {boolean} bitsMessage is a Debugger MESSAGE_* category flag\n     * @param {boolean|undefined} [fWrite] is true if this was a write, false (or undefined) if read\n     * @param {string|undefined} [name] of the port, if any\n     */\n    messageIO(component, addr, addrFrom, bitsMessage, fWrite, name)\n    {\n        if ((this.bitsMessage & bitsMessage) == bitsMessage) {\n            var b = this.cpu.getByte(addr);\n            this.message(component.id + \".\" + (fWrite? \"setByte\":\"getByte\") + \"(\" + Str.toHexWord(addr) + \")\" + (addrFrom !== undefined? (\" @\" + Str.toHexWord(addrFrom)) : \"\") + \": \" + (name? (name + \"=\") : \"\") + Str.toHexByte(b));\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sMessage is any caller-defined message string\n     */\n    message(sMessage)\n    {\n        this.println(sMessage);\n        this.cpu.yieldCPU();    // these print() calls are at risk of being called with high frequency, so we need to yieldCPU() more\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    init()\n    {\n        // this.doHelp();\n        this.println(\"Type ? for list of debugger commands\\n\");\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {boolean}\n     */\n    run()\n    {\n        if (!this.isCPUOK()) return false;\n        this.cpu.run();\n        return true;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} n (0 implies a single-step, and therefore breakpoints should be ignored)\n     * @return {boolean}\n     */\n    step(n)\n    {\n        if (!this.isCPUOK()) return false;\n        var fCompleted;\n        try {\n            fCompleted = this.cpu.step(n);\n        }\n        catch(e) {\n            fCompleted = undefined;\n            this.cpu.setError(e.stack || e.message);\n        }\n        if (fCompleted !== undefined) this.cIns++;\n        /*\n         * Because we called cpu.step() and not cpu.run(), we must\n         * nudge the CPU's update code, and then update our own state.\n         */\n        this.cpu.update(true);\n        this.update(true);\n        return fCompleted;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {boolean} [fStep]\n     */\n    update(fStep)\n    {\n        this.nextAddr = this.cpu.regPC;\n        if (fStep || this.fStepOver)\n            this.doUnassemble();\n        else\n            this.doRegisters();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {boolean}\n     *\n     * Make sure the CPU is ready (finished initializing), not busy (already running), and not in an error state.\n     */\n    isCPUOK()\n    {\n        if (!this.cpu)\n            return false;\n        if (!this.cpu.isReady())\n            return false;\n        if (this.cpu.isBusy())\n            return false;\n        return !this.cpu.isError();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     *\n     * This is a notification handler, called by the CPU, to inform us that the CPU has been reset.\n     */\n    reset()\n    {\n        var i;\n        if (!this.aStepHistory.length)\n            this.aStepHistory = new Array(1000);\n        for (i = 0; i < this.aStepHistory.length; i++)\n            this.aStepHistory[i] = -1;\n        if (!this.aaOpcodeFreqs.length)\n            this.aaOpcodeFreqs = new Array(256);\n        for (i = 0; i < this.aaOpcodeFreqs.length; i++)\n            this.aaOpcodeFreqs[i] = [i, 0];\n        if (this.cIns) this.update();\n        this.cIns = 0;\n        this.cReads = this.cWrites = this.cWritesZP = 0;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     *\n     * This is a notification handler, called by the CPU, to inform us that the CPU has started running.\n     */\n    start()\n    {\n        if (!this.fStepOver) this.println(\"running\");\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} msStart\n     * @param {number} nCycles\n     *\n     * This is a notification handler, called by the CPU, to inform us that the CPU has now stopped running.\n     */\n    stop(msStart, nCycles)\n    {\n        if (!this.fStepOver) {\n            this.println(\"stopped\");\n            if (nCycles) {\n                var msTotal = Usr.getTime();\n                msTotal -= msStart;\n                this.println(msTotal + \"ms (\" + nCycles + \" cycles)\");\n                if (DEBUG && msTotal > 0) {\n                    nCycles = nCycles * 1000 / msTotal;\n                    this.println(\"total cycles/second: \" + Math.round(nCycles));\n                    var percent = Math.round((this.cIns? this.cReads / this.cIns : 0) * 1000) / 10;\n                    this.println(\"total reads: \" + this.cReads + \" (\" + percent + \"%)\");\n                    percent = Math.round((this.cIns? this.cWrites / this.cIns : 0) * 1000) / 10;\n                    this.println(\"total writes: \" + this.cWrites + \" (\" + percent + \"%)\");\n                    percent = Math.round((this.cIns? this.cWritesZP / this.cIns : 0) * 1000) / 10;\n                    this.println(\"total zero-page writes: \" + this.cWritesZP + \" (\" + percent + \"%)\");\n                    this.println(\"total instructions: \" + this.cIns);\n                }\n            }\n        }\n        this.update();\n        this.setFocus();\n        if (!this.fStepOver) {\n            this.cIns = 0;\n            this.cReads = this.cWrites = this.cWritesZP = 0;\n        }\n        this.clearTempBreakpoint(this.cpu.regPC);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     *\n     * This is a check function, called by the CPU, indicating whether other instructions need to be checked.\n     */\n    checksEnabled()\n    {\n        return (DEBUG? true : (this.aExecBreak.length > 0 || this.aReadBreak.length > 0 || this.aWriteBreak.length > 0));\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} bOpCode\n     * @return {boolean} true to proceed, false to halt\n     *\n     * This is a check function, called by the CPU, to inform us about the next instruction to be executed, giving\n     * us an opportunity to look for \"exec\" breakpoints and update opcode frequencies and instruction history.\n     */\n    checkInstruction(addr, bOpCode)\n    {\n        var fBreak = false;\n        if (this.checkBreakpoint(addr, this.aExecBreak, \"exec\"))\n            fBreak = true;\n        else {\n            this.cIns++;\n            this.aaOpcodeFreqs[bOpCode][1]++;\n            this.aStepHistory[this.iStepHistory++] = this.cpu.regPC;\n            if (this.iStepHistory >= this.aStepHistory.length)\n                this.iStepHistory = 0;\n        }\n        return !fBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {boolean} true to proceed, false to halt\n     *\n     * This is a check function, called by the CPU, to inform us that a memory read occurred, giving us an\n     * opportunity to track the read if we want, and look for a matching \"read\" breakpoint, if any.\n     */\n    checkMemoryRead(addr)\n    {\n        var fBreak = false;\n        this.cReads++;\n        if (this.checkBreakpoint(addr, this.aReadBreak, \"read\"))\n            fBreak = true;\n        return !fBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} value written\n     * @return {boolean} true to proceed, false to halt\n     *\n     * This is a check function, called by the CPU, to inform us that a memory write occurred, giving us an\n     * opportunity to track the write if we want, and look for a matching \"write\" breakpoint, if any.\n     */\n    checkMemoryWrite(addr, value)\n    {\n        var fBreak = false;\n        this.cWrites++;\n        /*\n         * NOTE: We keep track of zero-page writes mainly as a reminder to look into whether it makes sense\n         * for the CPU to calculate zero-page EAs using a different variable (eg, regEAWriteZP instead of regEAWrite),\n         * because write-notification handlers never care about page zero accesses, and while write breakpoints *may*\n         * care, it may not be worth the cost of tracking writes to page zero if there's an associated perf penalty.\n         */\n        if (!(addr & 0xff00))\n            this.cWritesZP++;\n        if ((value & 0xff) != value) {\n            this.println(\"invalid value at \" + Str.toHexWord(addr) + \": \" + value);\n            fBreak = true;\n        }\n        if (this.checkBreakpoint(addr, this.aWriteBreak, \"write\"))\n            fBreak = true;\n        return !fBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} b\n     * @return {number}\n     */\n    addSignedByte(addr, b)\n    {\n        return addr + ((b << 24) >> 24);\n    }\n\n    /**\n     * getByte() should be used for all memory reads performed by the Debugger (eg, doDump, doUnassemble),\n     * to insure that the CPU is properly notified (and by extension, any device that's registered a\n     * notification handler with the CPU).\n     *\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {number|undefined}\n     */\n    getByte(addr)\n    {\n        var b;\n        if (addr >= this.offMem && addr < this.offLimit) {\n            this.cpu.checkReadNotify(addr);\n            b = this.abMem[this.offMem + addr];\n\n            b &= 0xff;\n        }\n        return b;\n    }\n\n    /**\n     * setByte() should be used for all memory writes performed by the Debugger (eg, doAssemble, doEdit),\n     * to insure that the CPU is properly notified (and by extension, any device that's registered a\n     * notification handler with the CPU).\n     *\n     * NOTE: Even though we call all write-notification handlers, we don't include a \"from\" address,\n     * because the write originated from the Debugger, not from a CPU instruction.  As a result, handlers should\n     * not refuse the write unless they have good reason; in particular, the ROM handlers will not refuse our writes,\n     * allowing the Debugger to modify ROM contents as needed.\n     *\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} b\n     */\n    setByte(addr, b)\n    {\n        if (addr < this.offMem || addr >= this.offLimit) {\n            this.println(\"invalid address: \" + Str.toHexWord(addr));\n            return;\n        }\n        this.abMem[this.offMem + addr] = (b & 0xff);\n        this.cpu.checkWriteNotify(addr);\n        this.cpu.update();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    clearBreakpoints()\n    {\n        this.aExecBreak = [];\n        this.aReadBreak = [];\n        this.aWriteBreak = [];\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {boolean}\n     */\n    addExecBreakpoint(addr)\n    {\n        if (!this.findExecBreakpoint(addr)) {\n            this.aExecBreak.push(addr);\n        }\n        return true;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {boolean}\n     */\n    addReadBreakpoint(addr)\n    {\n        if (!this.findReadBreakpoint(addr)) {\n            this.aReadBreak.push(addr);\n        }\n        return true;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {boolean}\n     */\n    addWriteBreakpoint(addr)\n    {\n        if (!this.findWriteBreakpoint(addr)) {\n            this.aWriteBreak.push(addr);\n        }\n        return true;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {Array}\n     */\n    getExecBreakpoints()\n    {\n        return this.aExecBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {Array}\n     */\n    getReadBreakpoints()\n    {\n        return this.aReadBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {Array}\n     */\n    getWriteBreakpoints()\n    {\n        return this.aWriteBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array} aBreak\n     * @param {number} addr\n     * @param {boolean} [fRemove]\n     * @return {boolean}\n     */\n    findBreakpoint(aBreak, addr, fRemove)\n    {\n        var fMatch = false;\n        for (var i=0; i < aBreak.length; i++) {\n            if (aBreak[i] == addr) {\n                if (fRemove) {\n                    aBreak.splice(i, 1);\n                }\n                fMatch = true;\n                break;\n            }\n        }\n        return fMatch;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {boolean} [fRemove]\n     * @return {boolean}\n     */\n    findExecBreakpoint(addr, fRemove)\n    {\n        return this.findBreakpoint(this.aExecBreak, addr, fRemove);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {boolean} [fRemove]\n     * @return {boolean}\n     */\n    findReadBreakpoint(addr, fRemove)\n    {\n        return this.findBreakpoint(this.aReadBreak, addr, fRemove);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {boolean} [fRemove]\n     * @return {boolean}\n     */\n    findWriteBreakpoint(addr, fRemove)\n    {\n        return this.findBreakpoint(this.aWriteBreak, addr, fRemove);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number|undefined} addr of new temp breakpoint\n     */\n    setTempBreakpoint(addr)\n    {\n        if (addr !== undefined) {\n            /*\n             * I don't want temporary breakpoints growing out of control, so I forcibly clear any\n             * existing temp breakpoint by feeding clearTempBreakpoint() the current temp address, if any;\n             * but you can remove the next line if you decide multiple temp breakpoints are a good thing.\n             */\n            this.clearTempBreakpoint(this.addrTempBP);\n            if (this.addExecBreakpoint(addr))\n                this.addrTempBP = addr;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr to compare to addrTempBP; the latter is cleared if there's a match\n     */\n    clearTempBreakpoint(addr)\n    {\n        if (this.addrTempBP !== undefined && addr == this.addrTempBP) {\n            if (this.findExecBreakpoint(this.addrTempBP, true)) {\n                this.addrTempBP = undefined;\n            }\n        }\n        this.fStepOver = false;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {Array} aBreakpoints\n     * @param {string} sType (ie, \"exec\" or \"write\")\n     * @return {boolean} true if breakpoint has been hit, false if not\n     */\n    checkBreakpoint(addr, aBreakpoints, sType)\n    {\n        /*\n         * Time to check for execution breakpoints; note that this should be done BEFORE updating any of the frequency\n         * or history data (see checkInstruction), since we might not actually execute the current instruction.\n         */\n        var fBreak = false;\n        for (var i=0; i < aBreakpoints.length; i++) {\n            if (aBreakpoints[i] == addr) {\n                if (addr != this.addrTempBP)\n                    this.println(\"breakpoint hit: \" + Str.toHexWord(addr) + \" (\" + sType + \")\");\n                fBreak = true;\n                break;\n            }\n        }\n        return fBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} [nIns] is an associated instruction number, or 0 (or undefined) if none\n     * @return {string}\n     */\n    getInstruction(addr, nIns)\n    {\n        var sLine = Str.toHex(addr, 4);\n        var bOpCode = this.getByte(addr++);\n        var b = (bOpCode === undefined? 0 : bOpCode);\n        var aOpDesc = this.aaOperations[b];\n        var abOperand = [];\n        var cb = (aOpDesc[1] === undefined? 0 : aOpDesc[1]);\n        do {\n            sLine += \" \" + Str.toHex(b, 2);\n            if (!(cb--)) break;\n            b = this.getByte(addr++);\n            if (b === undefined) break;\n            abOperand.push(b);\n        } while (true);\n        if (aOpDesc[0] === undefined) {\n            aOpDesc = [this.OP_DB, 1, this.MODE_IMM];\n            abOperand.push(bOpCode);\n        }\n        sLine = (sLine + \"        \").substr(0, 15);\n        sLine += this.aOpCodes[aOpDesc[0]];\n        var sOperand = null;\n        if (aOpDesc[2] !== undefined) {\n            var bOpMode = aOpDesc[2];\n            sOperand = this.aOpModes[bOpMode];\n            if (aOpDesc[1] == 1 && bOpMode == this.MODE_DISP) {\n                sOperand = sOperand.replace(/nnnn/, Str.toHex(this.addSignedByte(addr, b = abOperand.pop()), 4));\n            }\n            else {\n                while (abOperand.length) {\n                    sOperand = sOperand.replace(/nn/, Str.toHex(b = abOperand.pop(), 2));\n                }\n            }\n            if (bOpMode == this.MODE_IMM && aOpDesc[1] == 1) {\n                if (b >= 0x20 && b < 0x80)\n                    sOperand += \" ;'\" + String.fromCharCode(b) + \"'\";\n            }\n        }\n        if (bOpCode == this.cpu.OP_SIM) {\n            if (b < this.aOpSimCodes.length)\n                sOperand = this.aOpSimCodes[b];\n            if (b == this.cpu.SIMOP_MSG) {\n                cb = 0;\n                sOperand = \"\\\"\";\n                while ((b = this.getByte(addr++))) {\n                    if (cb < 16)\n                        sOperand += String.fromCharCode(b);\n                    else if (cb == 16)\n                        sOperand += \"\";\n                    cb++;\n                }\n                sOperand += \"\\\"\";\n            }\n        }\n        if (sOperand) sLine += \" \" + sOperand;\n        if (nIns) {\n            sLine += \"               \";\n            sLine = sLine.substr(0, 30);\n            sLine += \";\" + nIns.toString();\n        }\n        this.nextIns = addr;\n        return sLine;\n    }\n\n    /**\n     * parseInstruction(sCode, sOperand, addr)\n     *\n     * This generally requires an exact match of both the operation code (sCode) and mode operand (sOperand)\n     * against the aOpCodes[] and aOpModes[] arrays, respectively; however, the regular expression built from\n     * aOpModes and stored in regexOpModes does relax the matching criteria slightly; ie, a 4-digit hex value\n     * (\"nnnn\") will be satisfied with either 3 or 4 digits, and similarly, a 2-digit hex address (nn) will\n     * be satisified with either 1 or 2 digits.\n     *\n     * Note that this function does not actually store the instruction into memory, even though it requires\n     * a target address (addr); that parameter is currently needed ONLY for \"branch\" instructions, because in\n     * order to calculate the branch displacement, it needs to know where the instruction will ultimately be\n     * stored, relative to its target address.\n     *\n     * Another handy feature of this function is its ability to display all available modes for a particular\n     * operation. For example, while in \"assemble mode\", if one types:\n     *\n     *      ldy?\n     *\n     * the Debugger will display:\n     *\n     *      supported opcodes:\n     *           A0: LDY nn\n     *           A4: LDY [nn]\n     *           AC: LDY [nnnn]\n     *           B4: LDY [nn+X]\n     *           BC: LDY [nnnn+X]\n     *\n     * Use of a trailing \"?\" on any opcode will display all variations of that opcode; no instruction will be\n     * assembled, and the operand parameter, if any, will be ignored.\n     *\n     * Although this function is capable of reporting numerous errors, roughly half of them indicate internal\n     * consistency errors, not user errors; the former should really be asserts, but I'm not comfortable bombing\n     * out because of my error as opposed to their error.  The only errors a user should expect to see:\n     *\n     *      \"unknown operation\":    sCode is not a valid operation (per aOpCodes)\n     *      \"unknown operand\":      sOperand is not a valid operand (per aOpModes)\n     *      \"unknown instruction\":  the combination of sCode + sOperand does not exist (per aaOperations)\n     *      \"branch out of range\":  the branch address, relative to addr, is too far away\n     *\n     * @this {C1PDebugger}\n     * @param {string} sCode\n     * @param {string|undefined} sOperand\n     * @param {number} addr of memory where this instruction is being assembled\n     * @return {Array.<number>} of opcode bytes; if the instruction can't be parsed, the array will be empty\n     */\n    parseInstruction(sCode, sOperand, addr)\n    {\n        var aOpBytes = [];\n        if (sCode !== undefined) {\n            var iCode, iMode;\n            /*\n             * Find the iCode that corresponds to the given operation code\n             */\n            sCode = sCode.toUpperCase();\n            if (sCode.charAt(sCode.length-1) == \"?\") {\n                sOperand = \"?\";\n                sCode = sCode.substr(0, sCode.length-1);\n            }\n            for (iCode=0; iCode < this.aOpCodes.length; iCode++) {\n                if (sCode == this.aOpCodes[iCode]) {\n                    break;\n                }\n            }\n            if (iCode == this.aOpCodes.length) {\n                this.println(\"unknown operation: \" + sCode);\n                iCode = -1;\n            }\n            var sMode = \"\", aModeMatch, i;\n            if (iCode >= 0 && sOperand !== undefined) {\n                sMode = sOperand.toUpperCase();\n                if (sMode == \"?\") {\n                    var cModes = 0;\n                    for (i = 0; i < this.aaOperations.length; i++) {\n                        if (this.aaOperations[i][0] === iCode) {\n                            if (!cModes) this.println(\"supported opcodes:\");\n                            this.println(\"     \" + Str.toHex(i, 2) + \": \" + sCode + (this.aaOperations[i][2] !== undefined? (\" \" + this.aOpModes[this.aaOperations[i][2]]) : \"\"));\n                            cModes++;\n                        }\n                    }\n                    iCode = -1;\n                }\n                else {\n                    /*\n                     * Find the iMode that corresponds to the given operand\n                     */\n                    aModeMatch = sMode.match(this.regexOpModes);\n                    if (aModeMatch !== null && aModeMatch[0] == sMode) {\n                        /*\n                         * One of the sub-patterns must have matched as well; the index of the matching\n                         * sub-pattern will correspond to the proper aOpModes index, albeit off-by-one since\n                         * the regex match at [0] is the complete match, not a sub-pattern match.\n                         */\n                        for (i = 1; i < aModeMatch.length; i++) {\n                            if (aModeMatch[i] == sMode) {\n                                if (iMode === undefined)\n                                    iMode = i-1;\n                                else {\n                                    /*\n                                     * This is really an internal consistency error; regardless what the user types, this should not occur.\n                                     */\n                                    //noinspection JSUnusedAssignment\n                                    this.println(\"too many operand matches (both \" + this.aOpModes[iMode] + \" and \" + this.aOpModes[i-1] + \")\");\n                                    iCode = -1;\n                                    break;\n                                }\n                            }\n                        }\n                        /*\n                         * Regrettably, if \"classic\" operand syntax is in effect, then we must look at the context of the\n                         * operand (ie, the operation code) whenever we have a MODE_IMM16 (or MODE_DISP) match, because it might\n                         * actually be a MODE_ABS operand; see setOpModes() for details of the aImm16Codes array.\n                         */\n                        if (iMode == this.MODE_IMM16) {\n                            if (this.aImm16Codes.indexOf(iCode) < 0)\n                                iMode = this.MODE_ABS;\n                        }\n                        /*\n                         * Even in \"modern\" syntax mode, we have to look at the context of a MODE_ABS16 match, because unless\n                         * the operation is OP_JMP, then the mode must actually be MODE_ABS.\n                         */\n                        if (iMode == this.MODE_ABS16) {\n                            if (iCode != this.OP_JMP)\n                                iMode = this.MODE_ABS;\n                        }\n                    }\n                    else {\n                        this.println(\"unknown operand: \" + sMode);\n                        iCode = -1;\n                    }\n                }\n            }\n            if (iCode >= 0) {\n                /*\n                 * So we have an iCode and possibly an iMode; find the one (and hopefully only) aaOperations instruction entry that matches\n                 */\n                var bOpCode = -1;\n                for (i = 0; i < this.aaOperations.length; i++) {\n                    if (this.aaOperations[i][0] === iCode && this.aaOperations[i][2] === iMode) {\n                        if (bOpCode < 0)\n                            bOpCode = i;\n                        else {\n                            /*\n                             * This is really an internal consistency error; regardless what the user types, this should not occur.\n                             */\n                            this.println(\"too many instruction matches (both \" + Str.toHexByte(bOpCode) + \" and \" + Str.toHexByte(i) + \")\");\n                            bOpCode = -2;\n                            break;\n                        }\n                    }\n                }\n                if (bOpCode >= 0) {\n                    aOpBytes.push(bOpCode);\n                    if (iMode !== undefined) {\n                        var cb = this.aaOperations[bOpCode][1];\n                        var asHex = sMode.match(/[0-9A-F]+/);\n                        if (asHex !== null) {\n                            var nHex = parseInt(asHex[0], 16);\n                            if (cb == 1 && iMode == this.MODE_DISP) {\n                                nHex -= (addr + 2);\n                                if (nHex < -128 || nHex > 127) {\n                                    this.println(\"branch out of range (\" + nHex + \")\");\n                                    aOpBytes = [];\n                                    cb = 0;\n                                }\n                            }\n                            for (i = 0; i < cb; i++) {\n                                aOpBytes.push(nHex & 0xff);\n                                nHex >>>= 8;\n                            }\n                        }\n                        else if (cb) {\n                            /*\n                             * This is really an internal consistency error; regardless what the user types, this should not occur.\n                             */\n                            this.println(\"instruction missing \" + cb + \" bytes\");\n                        }\n                    }\n                }\n                else {\n                    this.println(\"unknown instruction: \" + sCode + \" \" + sMode + (DEBUG? (\" (\" + iMode + \")\") : \"\"));\n                }\n            }\n        }\n        return aOpBytes;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {string}\n     */\n    getRegs()\n    {\n        return \"A=\" + Str.toHex(this.cpu.regA, 2) +\n              \" X=\" + Str.toHex(this.cpu.regX, 2) +\n              \" Y=\" + Str.toHex(this.cpu.regY, 2) +\n              \" P=\" + Str.toHex(this.cpu.getRegP(), 2) +\n              \" S=\" + Str.toHex(this.cpu.regS, 4) +\n              \" PC=\" + Str.toHex(this.cpu.regPC, 4);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string|undefined} [sAddr]\n     * @return {number|undefined}\n     */\n    getUserAddr(sAddr)\n    {\n        var addr = this.nextAddr;\n        if (sAddr !== undefined) {\n            var nBase = 16;\n            if (sAddr.charAt(0) == \"$\")\n                sAddr = sAddr.substr(1);\n            else\n            if (sAddr.substr(0, 2) == \"0x\")\n                sAddr = sAddr.substr(2);\n            else\n            if (sAddr.charAt(sAddr.length-1) == \".\") {\n                nBase = 10;\n                sAddr = sAddr.substr(0, sAddr.length-1);\n            }\n            addr = parseInt(sAddr, nBase);\n            if (isNaN(addr)) {\n                this.println(\"invalid base-\" + nBase + \" address: \" + sAddr);\n                addr = undefined;\n            }\n        }\n        if (addr !== undefined && (addr < this.offMem || addr >= this.offLimit)) {\n            this.println(\"address out of range: \" + Str.toHex(addr));\n            addr = undefined;\n        }\n        return addr;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    doHelp()\n    {\n        this.println(\"\\ncommands:\\n?\\thelp\\na [#]\\tassemble\\nb [#]\\tbreakpoint\\nd [#]\\tdump memory\\ne [#]\\tedit memory\\nf\\tdump frequencies\\ng [#]\\trun to [#]\\nh\\thalt\\no\\toptions\\np [#]\\tdump history\\nr\\tdump/edit registers\\ns\\tstep over instruction\\nt [#]\\tstep instruction(s)\\nu [#]\\tunassemble\");\n        this.println(\"note: frequency and history commands operate only when breakpoints are set\");\n    }\n\n    /**\n     * doAssemble() always receives the complete argument array, where the order of the arguments is:\n     *\n     *      [0]: the assemble command (assumed to be \"a\")\n     *      [1]: the target address (eg, \"200\")\n     *      [2]: the operation code, aka mnemonic (eg, \"adc\")\n     *      [3]: the operation mode operand, if any (eg, \"14\", \"[1234]\", etc)\n     *\n     * The Debugger enters \"assemble mode\" whenever only the first (or first and second) arguments are present.\n     * As long as \"assemble mode is active, the user can omit the first two arguments on all later assemble commands\n     * until \"assemble mode\" is cancelled with an empty command line; the command processor automatically prepends \"a\"\n     * and the next available target address to the argument array.\n     *\n     * Entering \"assemble mode\" is optional; one could enter a series of fully-qualified assemble commands; eg:\n     *\n     *      a ff00 cld\n     *      a ff01 ldx 28\n     *      ...\n     *\n     * without ever entering \"assemble mode\", but of course, that requires more typing and doesn't take advantage\n     * of automatic target address advancement (see addrAssembleNext).\n     *\n     * NOTE: As the previous example implies, you can even assemble new instructions into ROM address space;\n     * as our setByte() function explains, the ROM write-notification handlers only refuse writes from the CPU.\n     *\n     * @this {C1PDebugger}\n     * @param {Array.<string>} asArgs is the complete argument array, beginning with the \"a\" command in asArgs[0]\n     */\n    doAssemble(asArgs)\n    {\n        var addr = this.getUserAddr(asArgs[1]);\n        if (addr === undefined)\n            return;\n        this.addrAssembleNext = addr;\n        if (asArgs[2] === undefined) {\n            this.println(\"begin assemble @\" + Str.toHexWord(this.addrAssembleNext));\n            this.fAssemble = true;\n            this.cpu.update();\n            return;\n        }\n        var aOpBytes = this.parseInstruction(asArgs[2], asArgs[3], this.addrAssembleNext);\n        if (aOpBytes.length) {\n            for (var i=0; i < aOpBytes.length; i++) {\n                // this.println(Str.toHexWord(this.addrAssembleNext) + \": \" + Str.toHexByte(aOpBytes[i]));\n                this.setByte(this.addrAssembleNext+i, aOpBytes[i]);\n            }\n            this.println(this.getInstruction(this.addrAssembleNext));\n            this.addrAssembleNext += aOpBytes.length;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} [sParm]\n     * @param {string} [sAddr]\n     */\n    doBreak(sParm, sAddr)\n    {\n        if (sParm === undefined || sParm == \"?\") {\n            this.println(\"\\nbreakpoint commands:\");\n            this.println(\"bp [a]\\tset exec breakpoint at [a]\");\n            this.println(\"br [a]\\tset read breakpoint at [a]\");\n            this.println(\"bw [a]\\tset write breakpoint at [a]\");\n            this.println(\"bc [a]\\tclear breakpoint at [a]\");\n            this.println(\"bl\\tlist all breakpoints\");\n            return;\n        }\n        if (sAddr === undefined && sParm.length > 1) {\n            sAddr = sParm.substr(1);\n            sParm = sParm.substr(0, 1);\n        }\n        if (sParm == \"l\") {\n            var cBreaks = 0, i;\n            var aAddrs = this.getExecBreakpoints();\n            for (i = 0; i < aAddrs.length; i++) {\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(aAddrs[i]) + \" (exec)\");\n                cBreaks++;\n            }\n            aAddrs = this.getReadBreakpoints();\n            for (i = 0; i < aAddrs.length; i++) {\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(aAddrs[i]) + \" (read)\");\n                cBreaks++;\n            }\n            aAddrs = this.getWriteBreakpoints();\n            for (i = 0; i < aAddrs.length; i++) {\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(aAddrs[i]) + \" (write)\");\n                cBreaks++;\n            }\n            if (!cBreaks)\n                this.println(\"no breakpoints\");\n            return;\n        }\n        if (sAddr === undefined) {\n            this.println(\"missing breakpoint address\");\n            return;\n        }\n        if (sParm == \"c\" && sAddr == \"*\") {\n            this.clearBreakpoints();\n            this.println(\"all breakpoints cleared\");\n            return;\n        }\n        var addr = this.getUserAddr(sAddr);\n        if (addr === undefined)\n            return;\n        if (sParm == \"p\") {\n            if (this.addExecBreakpoint(addr))\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(addr) + \" (exec)\");\n            else\n                this.println(\"breakpoint not set: \" + Str.toHexWord(addr));\n            return;\n        }\n        if (sParm == \"c\") {\n            if (this.findExecBreakpoint(addr, true))\n                this.println(\"breakpoint cleared: \" + Str.toHexWord(addr) + \" (exec)\");\n            else\n            if (this.findReadBreakpoint(addr, true))\n                this.println(\"breakpoint cleared: \" + Str.toHexWord(addr) + \" (read)\");\n            else\n            if (this.findWriteBreakpoint(addr, true))\n                this.println(\"breakpoint cleared: \" + Str.toHexWord(addr) + \" (write)\");\n            else\n                this.println(\"breakpoint missing: \" + Str.toHexWord(addr));\n            return;\n        }\n        if (sParm == \"r\") {\n            if (this.addReadBreakpoint(addr))\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(addr) + \" (read)\");\n            else\n                this.println(\"breakpoint not set: \" + Str.toHexWord(addr));\n            return;\n        }\n        if (sParm == \"w\") {\n            if (this.addWriteBreakpoint(addr))\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(addr) + \" (write)\");\n            else\n                this.println(\"breakpoint not set: \" + Str.toHexWord(addr));\n            return;\n        }\n        this.println(\"unknown breakpoint command: \" + sParm);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sAddr\n     * @param {string} sLen\n     */\n    doDump(sAddr, sLen)\n    {\n        if (sAddr == \"?\") {\n            this.println(\"\\ndump commands:\");\n            this.println(\"d [a] [#]    dump # lines of memory\");\n            return;\n        }\n        var addr = this.getUserAddr(sAddr);\n        if (addr === undefined)\n            return;\n        var cLines = 0;\n        if (sLen !== undefined) {\n            if (sLen.charAt(0) == \"l\")\n                sLen = sLen.substr(1);\n            cLines = parseInt(sLen, 10);\n        }\n        if (!cLines) cLines = 1;\n        for (var line=0; line < cLines; line++) {\n            var sBytes = \"\";\n            var sChars = \"\";\n            var addrLine = addr;\n            for (var i=0; i < 8 && addr < this.offLimit; i++) {\n                var b = this.getByte(addr);\n                if (b === undefined) b = 0;\n                sBytes += Str.toHex(b, 2) + \" \";\n                sChars += (b >= 32 && b < 127? String.fromCharCode(b) : \".\");\n                addr++;\n            }\n            this.println(Str.toHex(addrLine, 4) + \" \" + sBytes + sChars);\n        }\n        this.nextAddr = addr;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array.<string>} asArgs\n     */\n    doEdit(asArgs)\n    {\n        var sAddr = asArgs[1];\n        if (sAddr === undefined) {\n            this.println(\"missing address\");\n            return;\n        }\n        var addr = this.getUserAddr(sAddr);\n        if (addr === undefined)\n            return;\n        for (var i=2; i < asArgs.length; i++) {\n            var b = parseInt(asArgs[i], 16);\n            this.setByte(addr++, b);\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sParm\n     */\n    doFreqs(sParm)\n    {\n        if (sParm == \"?\") {\n            this.println(\"\\nfrequency commands:\");\n            this.println(\"clear\\tclear all frequency counts\");\n            return;\n        }\n        var cData = 0, i;\n        if (this.aaOpcodeFreqs) {\n            if (sParm == \"clear\") {\n                for (i = 0; i < this.aaOpcodeFreqs.length; i++)\n                    this.aaOpcodeFreqs[i] = [i, 0];\n                this.println(\"frequency data cleared\");\n                cData++;\n            }\n            else if (sParm !== undefined) {\n                this.println(\"unknown frequency command: \" + sParm);\n                cData++;\n            }\n            else {\n                var aaSortedOpcodeFreqs = this.aaOpcodeFreqs.slice();\n                aaSortedOpcodeFreqs.sort(function(p, q) {return q[1] - p[1];});\n                for (i = 0; i < aaSortedOpcodeFreqs.length; i++) {\n                    var bOpcode = aaSortedOpcodeFreqs[i][0];\n                    var cFreq = aaSortedOpcodeFreqs[i][1];\n                    if (cFreq) {\n                        this.println(this.aOpCodes[this.aaOperations[bOpcode][0]] + \" (\" + Str.toHexByte(bOpcode) + \"): \" + cFreq + \" times\");\n                        cData++;\n                    }\n                }\n            }\n        }\n        if (!cData) {\n            this.println(\"no frequency data available\");\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    doHalt()\n    {\n        this.halt();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sCount\n     */\n    doHistory(sCount)\n    {\n        var cLines = 10;\n        var iHistory = this.iStepHistory;\n        var aHistory = this.aStepHistory;\n        if (aHistory !== undefined) {\n            var n = (sCount === undefined? this.nextHistory : parseInt(sCount, 10));\n            if (n === undefined)\n                n = 10;\n            if (n > aHistory.length) {\n                this.println(\"note: only \" + aHistory.length + \" available\");\n                n = aHistory.length;\n            }\n            if (sCount !== undefined) {\n                this.nInsHistory = 0;\n                this.println(n + \" instructions earlier:\");\n            }\n            var nIns = (this.nInsHistory? this.nInsHistory : 1);\n            iHistory -= n;\n            if (iHistory < 0) iHistory = aHistory.length - 1;\n            while (cLines && iHistory != this.iStepHistory) {\n                var addr = aHistory[iHistory];\n                if (addr < 0) break;\n                this.println(this.getInstruction(addr, nIns++));\n                if (++iHistory == aHistory.length) iHistory = 0;\n                cLines--;\n                n--;\n            }\n            this.nextHistory = n;\n            this.nInsHistory = nIns;\n        }\n        if (cLines == 10) this.println(\"no history available\");\n    }\n\n    /**\n     * Prints the contents of the Debugger's \"info\" buffer (filled by calls like cpu.dbg.info())\n     * @this {C1PDebugger}\n     * @param {string|undefined} sCount\n     * @return {boolean|undefined} true only if the \"info\" command is supported\n     */\n    doInfo(sCount)\n    {\n        if (DEBUG) {\n            var cLines = (sCount === undefined? -1 : parseInt(sCount, 10));\n            var i = this.iInfoBuffer;\n            do {\n                var s = this.aInfoBuffer[i++];\n                if (s !== undefined) {\n                    this.println(s);\n                    cLines--;\n                }\n                if (i >= this.aInfoBuffer.length)\n                    i = 0;\n            } while (cLines && i != this.iInfoBuffer);\n            this.println(\"nYieldsPerSecond: \" + this.cpu.nYieldsPerSecond);\n            this.println(\"msPerYield: \" + this.cpu.msPerYield);\n            this.println(\"nCyclesPerBurst: \" + this.cpu.nCyclesPerBurst);\n            this.println(\"nCyclesPerYield: \" + this.cpu.nCyclesPerYield);\n            this.println(\"nCyclesPerVideoUpdate: \" + this.cpu.nCyclesPerVideoUpdate);\n            this.println(\"nCyclesPerStatusUpdate: \" + this.cpu.nCyclesPerStatusUpdate);\n            return true;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} [sAddr]\n     * @param {string} [sAddrEnd]\n     * @param {number} [n]\n     */\n    doUnassemble(sAddr, sAddrEnd, n)\n    {\n        var addr = this.getUserAddr(sAddr);\n        if (addr === undefined)\n            return;\n\n        if (n === undefined) n = 1;\n        var addrEnd = this.offLimit;\n        if (sAddrEnd !== undefined) {\n            addrEnd = this.getUserAddr(sAddrEnd);\n            if (addrEnd === undefined || addrEnd < addr)\n                return;\n            if (!DEBUG && (addrEnd - addr) > 0x100) {\n                /*\n                 * Limiting the amount of disassembled code to one \"memory page\" in non-DEBUG builds is partly\n                 * to prevent the user from wedging their browser, but also a recognition that, in non-DEBUG builds,\n                 * the println() output buffer is truncated to 8K, which is only enough for about two pages of\n                 * disassembled code anyway.\n                 */\n                this.println(\"range too large\");\n                return;\n            }\n            addrEnd++;\n            n = -1;\n        }\n\n        if (addr != this.nextAddr)\n            this.println();\n\n        while (n-- && addr < addrEnd) {\n            var sIns = this.getInstruction(addr, this.isBusy(false) || this.fStepOver? this.cIns : 0);\n            this.println(sIns);\n            this.nextAddr = addr = this.nextIns;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array.<string>} asArgs\n     */\n    doOptions(asArgs)\n    {\n        if (asArgs[1] === undefined || asArgs[1] == \"?\") {\n            this.println(\"\\noption commands:\");\n            this.println(\"max\\trun at maximum speed\");\n            this.println(\"fast\\trun faster (up to \" + this.cpu.mhzFast + \"Mhz)\");\n            this.println(\"slow\\trun at normal speed (1Mhz)\");\n            this.println(\"classic\\tuse classic operand syntax\");\n            this.println(\"modern\\tuse modern operand syntax\");\n            this.println(\"msg\\tenable message categories\");\n            return;\n        }\n        var sOption = asArgs[1];\n        switch(sOption) {\n        case \"slow\":\n            this.cpu.setSpeed(this.cpu.SPEED_SLOW);\n            break;\n        case \"fast\":\n            this.cpu.setSpeed(this.cpu.SPEED_FAST);\n            break;\n        case \"max\":\n            this.cpu.setSpeed(this.cpu.SPEED_MAX);\n            break;\n        case \"classic\":\n            this.setOpModes(true);\n            this.println(\"classic syntax enabled\");\n            break;\n        case \"modern\":\n            this.setOpModes(false);\n            this.println(\"modern syntax enabled\");\n            break;\n        case \"msg\":\n            var bitsMessage = 0;\n            if (asArgs[2] !== undefined) {\n                if (asArgs[2] == \"all\")\n                    bitsMessage = 0xff;\n                else if (this.aMessageCategories[asArgs[2]] !== undefined)\n                    bitsMessage = this.aMessageCategories[asArgs[2]];\n                if (bitsMessage) {\n                    if (asArgs[3] == \"on\") {\n                        this.bitsMessage |= bitsMessage;\n                    }\n                    else if (asArgs[3] == \"off\") {\n                        this.bitsMessage &= ~bitsMessage;\n                    }\n                }\n            }\n            for (var sCategory in this.aMessageCategories) {\n                if (asArgs[2] !== undefined && (asArgs[2] != \"all\" && asArgs[2] != sCategory)) continue;\n                bitsMessage = this.aMessageCategories[sCategory];\n                this.println(sCategory + \" messages: \" + ((this.bitsMessage & bitsMessage)? \"on\" : \"off\"));\n            }\n            break;\n        default:\n            this.println(\"unknown option: \" + sOption);\n            break;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array.<string>} [asArgs]\n     */\n    doRegisters(asArgs)\n    {\n        if (asArgs && asArgs[1] == \"?\") {\n            this.println(\"\\nregister commands:\");\n            this.println(\"r to display all\");\n            this.println(\"r [target=value] to modify\");\n            this.println(\"supported targets:\");\n            this.println(\"A,X,Y,S,PC and flags C,Z,D,V,N\");\n            return;\n        }\n        var fIns = true;\n        if (asArgs !== undefined && asArgs.length > 1) {\n            fIns = false;\n            var sReg = asArgs[1];\n            var sValue = null;\n            var i = sReg.indexOf(\"=\");\n            if (i > 0) {\n                sValue = sReg.substr(i+1);\n                sReg = sReg.substr(0, i);\n            }\n            else if (asArgs.length > 2) {\n                sValue = asArgs[2];\n            }\n            else {\n                this.println(\"missing value for \" + asArgs[1]);\n                return;\n            }\n            var b = parseInt(sValue, 16);\n            if (!isNaN(b)) {\n                switch(sReg.toUpperCase()) {\n                case \"A\":\n                    this.cpu.regA = b & 0xff;\n                    break;\n                case \"X\":\n                    this.cpu.regX = b & 0xff;\n                    break;\n                case \"Y\":\n                    this.cpu.regY = b & 0xff;\n                    break;\n                case \"C\":\n                    if (b) this.cpu.setC(); else this.cpu.clearC();\n                    break;\n                case \"Z\":\n                    if (b) this.cpu.setZ(); else this.cpu.clearZ();\n                    break;\n                case \"D\":\n                    if (b) this.cpu.setBCD(); else this.cpu.clearBCD();\n                    break;\n                case \"V\":\n                    if (b) this.cpu.setV(); else this.cpu.clearV();\n                    break;\n                case \"N\":\n                    if (b) this.cpu.setN(); else this.cpu.clearN();\n                    break;\n                case \"S\":\n                    if ((b & ~0xff) != 0x100) {\n                        this.println(\"invalid stack pointer: \" + sValue);\n                        return;\n                    }\n                    this.cpu.regS = b;\n                    break;\n                case \"PC\":\n                    fIns = true;\n                    this.cpu.regPC = b & 0xffff;\n                    this.nextAddr = this.cpu.regPC;\n                    break;\n                default:\n                    this.println(\"unknown register: \" + sReg);\n                    return;\n                }\n            }\n            else {\n                this.println(\"invalid value: \" + sValue);\n                return;\n            }\n            this.cpu.update();\n        }\n        this.println(this.getRegs());\n        if (fIns) this.doUnassemble(Str.toHex(this.nextAddr = this.cpu.regPC, 4));\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sAddr\n     */\n    doRun(sAddr)\n    {\n        if (sAddr !== undefined)\n            this.setTempBreakpoint(this.getUserAddr(sAddr));\n        if (!this.run()) {\n            this.cpu.setFocus();\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    doStep()\n    {\n        if (this.getByte(this.cpu.regPC) == this.cpu.OP_JSR) {\n            this.setTempBreakpoint(this.cpu.regPC+3);\n            this.fStepOver = true;\n            if (!this.run())\n                this.cpu.setFocus();\n        }\n        else {\n            this.doTrace();\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} [sCount]\n     */\n    doTrace(sCount)\n    {\n        var c = (sCount === undefined? 1 : parseInt(sCount, 10));\n        var n = (c == 1? 0 : 1);\n        Web.onCountRepeat(\n            c,\n            function(dbg) {\n                return function() {\n                    return dbg.setBusy(true) && dbg.step(n);\n                };\n            }(this),\n            function(dbg) {\n                return function() {\n                    dbg.setBusy(false);\n                };\n            }(this)\n        );\n    }\n\n    static input(dbg, sCmd)\n    {\n        if (!sCmd.length) {\n            if (dbg.fAssemble) {\n                dbg.println(\"ended assemble @\" + Str.toHex(dbg.addrAssembleNext, 4));\n                dbg.nextAddr = dbg.addrAssembleNext;\n                dbg.fAssemble = false;\n            }\n            else\n            if (dbg.prevCmd)\n                sCmd = dbg.prevCmd;\n        }\n        if (dbg.isReady() && !dbg.isBusy(true) && sCmd.length > 0) {\n\n            if (dbg.fAssemble) {\n                sCmd = \"a \" + Str.toHex(dbg.addrAssembleNext, 4) + \" \" + sCmd;\n            }\n            else if (sCmd.length > 1 && sCmd.indexOf(\" \") != 1) {\n                /*\n                 * For certain commands lacking a space after the first character,\n                 * insert an automatic space, so that split(\" \") has the desired effect.\n                 */\n                var ch = sCmd.charAt(0).toLowerCase();\n                sCmd = ch + \" \" + sCmd.substr(1);\n            }\n\n            var asArgs = sCmd.split(\" \");\n            dbg.prevCmd = asArgs[0];\n\n            switch(asArgs[0].toLowerCase()) {\n            case \"a\":\n                dbg.doAssemble(asArgs);\n                break;\n            case \"b\":\n                dbg.doBreak(asArgs[1], asArgs[2]);\n                break;\n            case \"d\":\n                dbg.doDump(asArgs[1], asArgs[2]);\n                break;\n            case \"e\":\n                dbg.doEdit(asArgs);\n                break;\n            case \"f\":\n                dbg.doFreqs(asArgs[1]);\n                break;\n            case \"g\":\n                dbg.doRun(asArgs[1]);\n                break;\n            case \"h\":\n                dbg.doHalt();\n                break;\n            case \"o\":\n                dbg.doOptions(asArgs);\n                break;\n            case \"p\":\n                dbg.doHistory(asArgs[1]);\n                break;\n            case \"r\":\n                dbg.doRegisters(asArgs);\n                break;\n            case \"s\":\n                dbg.doStep();\n                break;\n            case \"t\":\n                dbg.doTrace(asArgs[1]);\n                break;\n            case \"u\":\n                dbg.doUnassemble(asArgs[1], asArgs[2], 8);\n                break;\n            case \"?\":\n            case \"help\":\n                dbg.doHelp();\n                break;\n            case \"i\":\n                if (dbg.doInfo(asArgs[1])) break;\n                /* falls through */\n            default:\n                dbg.println(\"unknown command: \" + sCmd);\n                break;\n            }\n        }\n    }\n\n    /**\n     * C1PDebugger.init()\n     *\n     * This function operates on every HTML element of class \"debugger\", extracting the\n     * JSON-encoded parameters for the C1PDebugger constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PDebugger component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeDbg = Component.getElementsByClass(document, C1PJS.APPCLASS, \"debugger\");\n        for (var iDbg=0; iDbg < aeDbg.length; iDbg++) {\n            var eDbg = aeDbg[iDbg];\n            var parmsDbg = Component.getComponentParms(eDbg);\n            var dbg = new C1PDebugger(parmsDbg);\n            Component.bindComponentControls(dbg, eDbg, C1PJS.APPCLASS);\n        }\n    }\n}\n\nif (DEBUGGER) {\n\n    /*\n     * Initialize every Debugger module on the page (as IF there's ever going to be more than one ;-))\n     */\n    Web.onInit(C1PDebugger.init);\n\n}   // endif DEBUGGER\n\n/**\n * @copyright https://www.pcjs.org/modules/c1pjs/lib/computer.js (C) Jeff Parsons 2012-2018\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PComputer extends Component {\n    /**\n     * C1PComputer(parmsComputer, modules)\n     *\n     * The C1PComputer component expects the following (parmsComputer) properties:\n     *\n     *      modules[{}] (from the <module> definition(s) for the computer)\n     *\n     * This component processes all the <module> \"start\" and \"end\" specifications\n     * and \"wires\" everything to a common \"address buffer\"; namely, the abMemory array.\n     * abMemory encompasses the computer's entire address space, but every component must\n     * play nice and use only its assigned section of abMemory -- and pretend it's an array\n     * of bytes, when in fact it's an array of floating-point values (the only primitive\n     * numeric data type that JavaScript provides).\n     *\n     * This component also insures that all the other components are ready; in particular,\n     * this means that the ROM and Video components have finished loading their resources\n     * and are ready for operation.  Other components become ready as soon as we call their\n     * setBuffer() method (eg, CPU, RAM, Keyboard, Debugger, SerialPort, DiskController), and\n     * others, like Panel, become ready even earlier, at the end of their initialization.\n     *\n     * Once every component has indicated it's ready, we call its setPower() notification\n     * function (if it has one; it's optional).  We call the CPU's setPower() function last,\n     * so that the CPU is assured that all other components are ready and \"powered\".\n     *\n     * @this {C1PComputer}\n     * @param {Object} parmsComputer\n     * @param {Object} modules\n     */\n    constructor(parmsComputer, modules)\n    {\n        super(\"C1PComputer\", parmsComputer);\n\n        this.modules = modules;\n    }\n\n    /**\n     * reset(fPowerOn)\n     *\n     * @this {C1PComputer}\n     * @param {boolean} [fPowerOn] is true to indicate that we should start the CPU running\n     */\n    reset(fPowerOn)\n    {\n        var cpu = null;\n        for (var sType in this.modules) {\n            for (var i=0; i < this.modules[sType].length; i++) {\n                var component = this.modules[sType][i];\n                if (component && component.reset) {\n                    if (DEBUG) this.println(\"resetting \" + sType);\n                    component.reset();\n                    if (sType == \"cpu\") cpu = component;\n                }\n            }\n        }\n        if (cpu) {\n            cpu.update();\n            if (fPowerOn) cpu.run();\n        }\n    }\n\n    /**\n     * start()\n     *\n     * Called by the CPU to notify all component start() handlers.\n     *\n     * @this {C1PComputer}\n     */\n    start()\n    {\n        for (var sType in this.modules) {\n            if (sType == \"cpu\") continue;\n            for (var i=0; i < this.modules[sType].length; i++) {\n                var component = this.modules[sType][i];\n                if (component && component.start) {\n                    component.start();\n                }\n            }\n        }\n    }\n\n    /**\n     * stop(msStart, nCycles)\n     *\n     * Called by the CPU to notify all component stop() handlers\n     *\n     * @this {C1PComputer}\n     * @param {number} msStart\n     * @param {number} nCycles\n     */\n    stop(msStart, nCycles)\n    {\n        for (var sType in this.modules) {\n            if (sType == \"cpu\") continue;\n            for (var i=0; i < this.modules[sType].length; i++) {\n                var component = this.modules[sType][i];\n                if (component && component.stop) {\n                    component.stop(msStart, nCycles);\n                }\n            }\n        }\n    }\n\n    /**\n     * @this {C1PComputer}\n     * @param {string} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"reset\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        switch(sBinding) {\n        case \"reset\":\n            this.bindings[sBinding] = control;\n            control.onclick = function(computer) {\n                return function() {\n                    computer.reset();\n                };\n            }(this);\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * NOTE: If there are multiple components for a given type, we may need to provide a means of discriminating.\n     *\n     * @this {C1PComputer}\n     * @param {string} sType\n     * @param {string} [idRelated] of related component\n     * @param {Component|null} [componentPrev] of previously returned component, if any\n     * @return {Component|null}\n     */\n    getComponentByType(sType, idRelated, componentPrev)\n    {\n        if (this.modules[sType]) {\n            return this.modules[sType][0];\n        }\n        return null;\n    }\n\n    static power(computer)\n    {\n        /*\n         * Insure that the ROMs, Video and CPU are all ready before \"powering\" everything; always \"power\"\n         * the CPU last, to make sure it doesn't start asking other components to do things before they're ready.\n         */\n        var cpu = null;\n        for (var sType in computer.modules) {\n            for (var i=0; i < computer.modules[sType].length; i++) {\n                var component = computer.modules[sType][i];\n                if (!component) continue;\n                if (!component.isReady()) {\n                    component.isReady(function(computer) {\n                        return function() {\n                            C1PComputer.power(computer);\n                        };\n                    }(computer));   // jshint ignore:line\n                    return;\n                }\n                /*\n                 * The CPU component's setPower() notification handler is a special case: we don't want\n                 * to call it until the end (below), after all others have been called.\n                 */\n                if (sType == \"cpu\")\n                    cpu = component;\n                else if (component.setPower) {\n                    component.setPower(true, computer);\n                }\n            }\n        }\n\n        /*\n         * The entire computer is finally ready; we call our own setReady() for completeness, not because any\n         * other component actually cares when we're ready.\n         */\n        computer.setReady();\n\n        computer.println(C1PJS.APPNAME + \" v\" + C1PJS.APPVERSION + \"\\n\" + COPYRIGHT);\n\n        /*\n         * Once we get to this point, we're guaranteed that all components are ready, so it's safe to \"power\" the CPU;\n         * setPower() includes an automatic reset(fPowerOn), so the CPU should begin executing immediately, unless a debugger\n         * is attached.\n         */\n        if (cpu) cpu.setPower(true, computer);\n    }\n\n    /*\n     * C1PComputer.init()\n     *\n     * This function operates on every HTML element of class \"c1pjs-computer\", extracting the\n     * JSON-encoded parameters for the C1PComputer constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PComputer component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        /*\n         * In non-COMPILED builds, embedMachine() may have set XMLVERSION.\n         */\n        if (!COMPILED && XMLVERSION) C1PJS.APPVERSION = XMLVERSION;\n\n        var aeComputers = Component.getElementsByClass(document, C1PJS.APPCLASS, \"computer\");\n\n        for (var iComputer=0; iComputer < aeComputers.length; iComputer++) {\n\n            var eComputer = aeComputers[iComputer];\n            var parmsComputer = Component.getComponentParms(eComputer);\n\n            var component;\n            var modules = {};\n\n            var abMemory;\n            var addrStart = 0, addrEnd = 0;\n\n            for (var iAddr=0; iAddr < parmsComputer['modules'].length; iAddr++) {\n                var addrInfo = parmsComputer['modules'][iAddr];\n                /*\n                 * The first address range (ie, the CPU range) must specify the range for the entire\n                 * address space (abMemory), which we allocate and zero-initialize.\n                 *\n                 * NOTE: We might consider doing what the Video component does on first reset: initializing\n                 * the entire memory buffer to random values.  However, a constant (eg, 0xA5) might be\n                 * more useful, acting as a crude indicator of memory the client code hasn't written yet.\n                 */\n                if (!iAddr) {\n                    if (addrInfo['type'] != \"cpu\") break;\n                    addrStart = addrInfo['start'];\n                    addrEnd = addrInfo['end'];\n                    abMemory = new Array(addrEnd+1 - addrStart);\n                    for (var addr=addrStart; addr < abMemory.length; addr++) {\n                        abMemory[addr] = 0;\n                    }\n                }\n                component = Component.getComponentByID(addrInfo['refID'], parmsComputer['id']);\n                if (component) {\n                    var sType = addrInfo['type'];\n                    if (modules[sType] === undefined)\n                        modules[sType] = [];\n                    modules[sType].push(component);\n                    if (component.setBuffer && addrInfo['start'] !== undefined) {\n                        component.setBuffer(abMemory, addrInfo['start'], addrInfo['end'], modules['cpu'][0]);\n                    }\n                }\n                else {\n                    Component.error(\"no component for <module refid=\\\"\" + addrInfo['refID'] + \"\\\">\");\n                    return;\n                }\n            }\n\n            if (abMemory === undefined) {\n                Component.error(\"<module type=\\\"cpu\\\"> definition must appear first in the <computer> specification\");\n                return;\n            }\n\n            /*\n             * Let's see if the Debugger is installed (NOTE: its ID must be \"debugger\", and only one per machine is supported);\n             * the Debugger needs our setBuffer(), setPower() and reset() notifications, and this relieves us from having an explicit\n             * <module> entry for type=\"debugger\".\n             */\n            component = Component.getComponentByID('debugger', parmsComputer['id']);\n            if (component) {\n                modules['debugger'] = [component];\n                if (component.setBuffer) {\n                    component.setBuffer(abMemory, addrStart, addrEnd, modules['cpu'][0]);\n                }\n            }\n\n            var computer = new C1PComputer(parmsComputer, modules);\n\n            /*\n             * Let's see if the Control Panel is installed (NOTE: its ID must be \"panel\", and only one per machine is supported);\n             * the Panel needs our setPower() notifications, and this relieves us from having an explicit <module> entry for type=\"panel\".\n             */\n            var panel = Component.getComponentByID('panel', parmsComputer['id']);\n            if (panel) {\n                modules['panel'] = [panel];\n                /*\n                 * Iterate through all the other components and update their print methods if the Control Panel has provided overrides.\n                 */\n                var controlPrint = panel.bindings['print'];\n                if (controlPrint) {\n                    var aComponents = Component.getComponents(parmsComputer['id']);\n                    for (var iComponent = 0; iComponent < aComponents.length; iComponent++) {\n                        component = aComponents[iComponent];\n                        if (component == panel) continue;\n                        component.notice = panel.notice;\n                        component.print = panel.print;\n                        component.println = panel.println;\n                    }\n                }\n            }\n\n            /*\n             *  We may eventually add a \"Power\" button, but for now, all we have is a \"Reset\" button\n             */\n            Component.bindComponentControls(computer, eComputer, C1PJS.APPCLASS);\n\n            /*\n             * \"Power\" the computer automatically\n             */\n            C1PComputer.power(computer);\n        }\n    }\n}\n\n/*\n * Initialize every Computer on the page.\n */\nWeb.onInit(C1PComputer.init);\n\n/**\n * @copyright https://www.pcjs.org/modules/shared/lib/embed.js (C) Jeff Parsons 2012-2018\n */\n\n\n/*\n * We now support asynchronous XML and XSL file loads; simply set fAsync (below) to true.\n *\n * NOTE: For that support to work, we have to keep track of the number of machines on the page\n * (ie, how many embedMachine() calls were issued), reduce the count as each machine XML file\n * is fully transformed into HTML, and when the count finally returns to zero, notify all the\n * machine component init() handlers.\n *\n * Also, to prevent those init() handlers from running prematurely, we must disable all page\n * notification events at the start of the embedding process (Web.enablePageEvents(false)) and\n * re-enable them at the end (Web.enablePageEvents(true)).\n */\nvar fAsync = true;\nvar cAsyncMachines = 0;\n\n/**\n * loadXML(sFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)\n *\n * This is the preferred way to load all XML and XSL files. It uses getResource()\n * to load them as strings, which parseXML() can massage before parsing/transforming them.\n *\n * For example, since I've been unable to get the XSLT document() function to work inside any\n * XSL document loaded by JavaScript's XSLT processor, that has prevented me from dynamically\n * loading any XML machine file that uses the \"ref\" attribute to refer to and incorporate\n * another XML document.\n *\n * To solve that, I've added an fResolve parameter that tells parseXML() to fetch any\n * referenced documents ITSELF and insert them into the XML string prior to parsing, instead\n * of relying on the XSLT template to pull them in.  That fetching is handled by resolveXML(),\n * which iterates over the XML until all \"refs\" have been resolved (including any nested\n * references).\n *\n * Also, XSL files with a <!DOCTYPE [...]> cause MSIE's Microsoft.XMLDOM.loadXML() function\n * to choke, so I strip that out prior to parsing as well.\n *\n * TODO: Figure out why the XSLT document() function works great when the web browser loads an\n * XML file (and the associated XSL file) itself, but does not work when loading documents via\n * JavaScript XSLT support. Is it broken, is it a security issue, or am I just calling it wrong?\n *\n * @param {string} sXMLFile\n * @param {string} idMachine\n * @param {string} sAppName\n * @param {string} sAppClass\n * @param {string} sParms (machine parameters, if any)\n * @param {string} sClass (an optional machine class name used to style the machine)\n * @param {boolean} fResolve is true to resolve any \"ref\" attributes\n * @param {function(string)} display\n * @param {function(string,Object)} done (string contains the unparsed XML string data, and Object contains a parsed XML object)\n */\nfunction loadXML(sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)\n{\n    var doneLoadXML = function(sURLName, sXML, nErrorCode) {\n        if (nErrorCode) {\n            if (!sXML) sXML = \"unable to load \" + sXMLFile + \" (\" + nErrorCode + \")\";\n            done(sXML, null);\n            return;\n        }\n        parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done);\n    };\n    display(\"Loading \" + sXMLFile + \"...\");\n    Web.getResource(sXMLFile, null, fAsync, doneLoadXML);\n}\n\n/**\n * parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)\n *\n * Generates an XML document from an XML string. This function also provides a work-around for XSLT's\n * lack of support for the document() function (at least on some browsers), by replacing every reference\n * tag (ie, a tag with a \"ref\" attribute) with the contents of the referenced file.\n *\n * @param {string} sXML\n * @param {string} sXMLFile\n * @param {string} idMachine\n * @param {string} sAppName\n * @param {string} sAppClass\n * @param {string} sParms (machine parameters, if any)\n * @param {string} sClass (an optional machine class name used to style the machine)\n * @param {boolean} fResolve is true to resolve any \"ref\" attributes; default is false\n * @param {function(string)} display\n * @param {function(string,Object)} done (string contains the unparsed XML string data, and Object contains a parsed XML object)\n */\nfunction parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)\n{\n    var buildXML = function(sXML, sError) {\n        if (sError) {\n            done(sError, null);\n            return;\n        }\n        if (idMachine) {\n\n            /*\n             * A more sensible place to record the machine XML would be embedMachine(), like we do for the\n             * XSL file, but since we're about to modify the original machine XML, it's best to record it now.\n             */\n            Component.addMachineResource(idMachine, sXMLFile, sXML);\n\n            var sURL = sXMLFile;\n            if (sURL && sURL.indexOf('/') < 0 && window.location.pathname.slice(-1) == '/') {\n                sURL = window.location.pathname + sURL;\n            }\n            /*\n             * We embed the URL of the XML file both as a separate \"xml\" attribute for easy access from the\n             * XSL file, and as part of the \"parms\" attribute for easy access from machines (see getMachineParm()).\n             */\n            if (!sParms) {\n                sParms = '{';\n            } else if (sParms.slice(-1) == '}') {\n                sParms = sParms.slice(0, -1);\n                if (sParms.length > 1) sParms += ',';\n            } else {            // sParms must just be a \"state\" file, so encode it as a \"state\" property\n                sParms = '{state:\"' + sParms + '\",';\n            }\n            sParms += 'url:\"' + sURL + '\"}';\n            /*\n             * Note that while we no longer generate a machine XML file with a \"state\" attribute (because it's\n             * encoded inside the \"parms\" attribute), the XSL file must still cope with \"state\" attributes inside\n             * other XML files; for example, manifest XML files like /apps/pcx86/1981/visicalc/manifest.xml contain\n             * machine elements with \"state\" attributes that must still be passed down to the computer element\n             * \"the old fashioned way\".\n             *\n             * Until/unless that changes, components.xsl cannot be simplified as much as I might have hoped.\n             */\n            if (typeof resources == 'object') sURL = null;      // turn off URL inclusion if we have embedded resources\n            sParms = sParms.replace(/\\$/g, \"$$$$\");\n            if (sClass) {\n                /*\n                 * If there's no hard-coded \"class\" attribute in the machine tag, then we can set one in the final\n                 * replacement below, just like we do for sParms and sURL.  However, if a \"class\" attribute already\n                 * exists, we need alter it and then zap the sClass variable.\n                 */\n                var match = sXML.match(/(<machine[^>]*\\sclass=)(['\"])(.*?)(\\2.*?>)/);\n                if (match) {\n                    sXML = sXML.replace(match[0], match[1] + match[2] + sClass + match[4]);\n                    sClass = \"\";\n                }\n            }\n            sXML = sXML.replace(/(<machine[^>]*\\sid=)(['\"]).*?\\2/, \"$1$2\" + idMachine + \"$2\" + (sClass? ' class=\"' + sClass + '\"' : '') + (sParms? \" parms='\" + sParms + \"'\" : \"\") + (sURL? ' url=\"' + sURL + '\"' : ''));\n        }\n\n        if (!fResolve) {\n            /*\n             * I'm trying to switch to a shared components.xsl (at least for all PC-class machines),\n             * but in the interim, that means hacking the XSL file on the fly to reflect the actual class.\n             */\n            sXML = sXML.replace(/(<xsl:variable name=\"APPNAME\">).*?(<\\/xsl:variable>)/, \"$1\" + sAppName + \"$2\");\n            sXML = sXML.replace(/(<xsl:variable name=\"APPCLASS\">).*?(<\\/xsl:variable>)/, \"$1\" + sAppClass + \"$2\");\n\n            /*\n             * Non-COMPILED kludge to replace the version number template in the XSL file (which we assume we're reading,\n             * since fResolve is false) with whatever XMLVERSION we extracted from the XML file (see corresponding kludge below).\n             *\n             * ES6 ALERT: Template strings.\n             */\n            if (!COMPILED && XMLVERSION) {\n                sXML = sXML.replace(/<xsl:variable name=\"APPVERSION\"\\/>/, `<xsl:variable name=\"APPVERSION\">${XMLVERSION}</xsl:variable>`);\n            }\n        }\n\n        /*\n         * If the resource we requested is not really an XML file (or the file didn't exist and the server simply returned\n         * a message like \"Cannot GET /devices/pc/machine/5150/cga/64kb/donkey/machine.xml\"), we'd like to display a more\n         * meaningful message, because the XML DOM parsers will blithely return a document that contains nothing useful; eg:\n         *\n         *      This page contains the following errors:error on line 1 at column 1:\n         *      Document is empty Below is a rendering of the page up to the first error.\n         *\n         * Supposedly, the IE XML DOM parser will throw an exception, but I haven't tested that, and unless all other\n         * browsers do that, that's not helpful.\n         *\n         * The best I can do at this stage (assuming Web.getResource() didn't drop any error information on the floor)\n         * is verify that the requested resource \"looks like\" valid XML (in other words, it begins with a '<').\n         */\n        var xmlDoc = null;\n        if (sXML.charAt(0) == '<') {\n            try {\n                /*\n                 * Another hack for MSIE, which fails to load XSL documents containing a <!DOCTYPE [...]> tag.\n                 *\n                 * This is also why the XSLTProcessor 'transformToFragment' method in Microsoft Edge silently failed,\n                 * so I had pull this hack out of the \"ActiveXObject\" code.  And rather than add yet-another Microsoft\n                 * browser check, I'm going to try doing this across the board, and hope that none of the other XSLT\n                 * processors fail *without* the DOCTYPE tag.\n                 */\n                if (!fResolve) {\n                    sXML = sXML.replace(/<!DOCTYPE(.|[\\r\\n])*]>\\s*/g, \"\");\n                }\n                /*\n                 * Beginning with Microsoft Edge and the corresponding release of Windows 10, all the\n                 * 'ActiveXObject' crud has gone away; but of course, this code must remain in place if\n                 * we want to continue supporting older Internet Explorer browsers (ie, back to IE9).\n                 */\n                /** @namespace window.ActiveXObject */\n                if (window.ActiveXObject || 'ActiveXObject' in window) {        // second test is required for IE11 on Windows 8.1\n                    xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n                    xmlDoc.async = false;\n                    xmlDoc['loadXML'](sXML);\n                } else {\n                    /** @namespace window.DOMParser */\n                    xmlDoc = (new window.DOMParser()).parseFromString(sXML, \"text/xml\");\n                }\n            } catch(e) {\n                xmlDoc = null;\n                sXML = e.message;\n            }\n        } else {\n            sXML = \"unrecognized XML: \" + (sXML.length > 255? sXML.substr(0, 255) + \"...\" : sXML);\n        }\n        done(sXML, xmlDoc);\n    };\n    if (sXML) {\n        if (PRIVATE) sXML = sXML.replace(/\\/library.xml/, \"/private/library.xml\");\n        if (fResolve) {\n            resolveXML(sXML, display, buildXML);\n            return;\n        }\n        buildXML(sXML, \"\");\n        return;\n    }\n    done(\"no data\" + (sXMLFile? \" for file: \" + sXMLFile : \"\"), null);\n}\n\n/**\n * resolveXML(sXML, display, done)\n *\n * Replaces every tag with a \"ref\" attribute with the contents of the corresponding file.\n *\n * TODO: Fix some of the limitations of this code, such as: 1) requiring the \"ref\" attribute\n * to appear as the tag's first attribute, 2) requiring the \"ref\" attribute to be double-quoted,\n * and 3) requiring the \"ref\" tag to be self-closing.\n *\n * @param {string} sXML\n * @param {function(string)} display\n * @param {function(string,string)} done (the first string contains the resolved XML data, the second is for any error message)\n */\nfunction resolveXML(sXML, display, done)\n{\n    var matchRef;\n    var reRef = /<([a-z]+)\\s+ref=\"(.*?)\"(.*?)\\/>/g;\n\n    if ((matchRef = reRef.exec(sXML))) {\n\n        var sRefFile = matchRef[2];\n\n        var doneReadXML = function(sURLName, sXMLRef, nErrorCode) {\n            if (nErrorCode || !sXMLRef) {\n                done(sXML, \"unable to resolve XML reference: \" + matchRef[0] + \" (\" + nErrorCode + \")\");\n                return;\n            }\n            /*\n             * If there are additional attributes in the \"referring\" XML tag, we want to insert them\n             * into the \"referred\" XML tag; attributes that don't exist in the referred tag should be\n             * appended, and attributes that DO exist should be overwritten.\n             */\n            var sRefAttrs = matchRef[3];\n            if (sRefAttrs) {\n                var aXMLRefTag = sXMLRef.match(new RegExp(\"<\" + matchRef[1] + \"[^>]*>\"));\n                if (aXMLRefTag) {\n                    var sXMLNewTag = aXMLRefTag[0];\n                    /*\n                     * Iterate over all the attributes in the \"referring\" XML tag (sRefAttrs)\n                     */\n                    var matchAttr;\n                    var reAttr = /( [a-z]+=)(['\"])(.*?)\\2/gi;\n                    while ((matchAttr = reAttr.exec(sRefAttrs))) {\n                        if (sXMLNewTag.toLowerCase().indexOf(matchAttr[1].toLowerCase()) < 0) {\n                            /*\n                             * This is the append case....\n                             */\n                            sXMLNewTag = sXMLNewTag.replace(\">\", matchAttr[0] + \">\");\n                        } else {\n                            /*\n                             * This is the overwrite case....\n                             */\n                            sXMLNewTag = sXMLNewTag.replace(new RegExp(matchAttr[1] + \"(['\\\"])(.*?)\\\\1\"), matchAttr[0]);\n                        }\n                    }\n                    if (aXMLRefTag[0] != sXMLNewTag) {\n                        sXMLRef = sXMLRef.replace(aXMLRefTag[0], sXMLNewTag);\n                    }\n                } else {\n                    done(sXML, \"missing <\" + matchRef[1] + \"> in \" + sRefFile);\n                    return;\n                }\n            }\n\n            /*\n             * Apparently when a Windows Azure server delivers one of my XML files, it may modify the first line:\n             *\n             *      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n\n             *\n             * I didn't determine exactly what it was doing at this point (probably just changing the \\n to \\r\\n),\n             * but in any case, relaxing the following replace() solved it.\n             */\n            sXMLRef = sXMLRef.replace(/<\\?xml[^>]*>[\\r\\n]*/, \"\");\n\n            sXML = sXML.replace(matchRef[0], sXMLRef);\n\n            resolveXML(sXML, display, done);\n        };\n\n        display(\"Loading \" + sRefFile + \"...\");\n        Web.getResource(sRefFile, null, fAsync, doneReadXML);\n        return;\n    }\n    done(sXML, \"\");\n}\n\n/**\n * embedMachine(sAppName, sAppClass, sVersion, idMachine, sXMLFile, sXSLFile, sParms, sClass)\n *\n * This allows to you embed a machine on a web page, by transforming the machine XML into HTML.\n *\n * @param {string} sAppName is the app name (eg, \"PCx86\")\n * @param {string} sAppClass is the app class (eg, \"pcx86\"); also known as the machine class\n * @param {string} sVersion is the app version (eg, \"1.15.7\")\n * @param {string} idMachine\n * @param {string} [sXMLFile]\n * @param {string} [sXSLFile]\n * @param {string} [sParms] (machine parameters, if any)\n * @param {string} [sClass] (an optional machine class name used to style the machine)\n * @return {boolean} true if successful, false if error\n */\nfunction embedMachine(sAppName, sAppClass, sVersion, idMachine, sXMLFile, sXSLFile, sParms, sClass)\n{\n    var eMachine, eWarning, fSuccess = true;\n\n    if (!sXMLFile) {\n        sXMLFile = \"machine.xml\";\n        if (!sXSLFile) sXSLFile = \"components.xsl\";\n    }\n    \n    cAsyncMachines++;\n    Component.addMachine(idMachine);\n\n    var doneMachine = function() {\n\n        if (!--cAsyncMachines) {\n            if (fAsync) Web.enablePageEvents(true);\n        }\n    };\n\n    var displayError = function(sError) {\n        Component.log(sError);\n        displayMessage(\"Error: \" + sError);\n        if (fSuccess) doneMachine();\n        fSuccess = false;\n    };\n\n    var displayMessage = function(sMessage) {\n        if (eWarning === undefined) {\n            /*\n             * Our MarkOut module (in convertMDMachineLinks()) creates machine containers that look like:\n             *\n             *      <div id=\"' + sMachineID + '\" class=\"machine-placeholder\"><p>Embedded PC</p><p class=\"machine-warning\">...</p></div>\n             *\n             * with the \"machine-warning\" paragraph pre-populated with a warning message that the user will\n             * see if nothing at all happens.  But hopefully, in the normal case (and especially the error case),\n             * *something* will have happened.\n             *\n             * Note that it is the HTMLOut module (in processMachines()) that ultimately decides which scripts to\n             * include and then generates the embedXXX() call.\n             */\n            var aeWarning = (eMachine && Component.getElementsByClass(eMachine, \"machine-warning\"));\n            eWarning = (aeWarning && aeWarning[0]) || eMachine;\n        }\n        if (eWarning) eWarning.innerHTML = Str.escapeHTML(sMessage);\n    };\n\n    try {\n        eMachine = document.getElementById(idMachine);\n        if (eMachine) {\n\n            /*\n             * If we have a 'css' resource, add it to the page first.\n             */\n            var css;\n            if (typeof resources == \"object\" && (css = resources['css'])) {\n                var head = document.head || document.getElementsByTagName('head')[0];\n                var style = document.createElement('style');\n                style.type = 'text/css';\n                // noinspection JSDeprecatedSymbols\n                if (style.styleSheet) {\n                    // noinspection JSDeprecatedSymbols\n                    style.styleSheet.cssText = css;\n                } else {\n                    style.appendChild(document.createTextNode(css));\n                }\n                head.appendChild(style);\n            }\n\n            if (!sXSLFile) {\n                /*\n                 * Now that PCjs is an open-source project, we can make the following test more flexible,\n                 * and revert to the internal template if DEBUG *or* internal version (instead of *and*).\n                 *\n                 * Third-party sites that don't use the PCjs server will ALWAYS want to specify a fully-qualified\n                 * path to the XSL file, unless they choose to mirror our folder structure.\n                 */\n                var sAppFolder = sAppClass;\n                if (DEBUG || !sVersion) {\n                    if (sAppClass != \"c1pjs\") sAppFolder = \"shared\";\n                    sXSLFile = \"/modules/\" + sAppFolder + \"/templates/components.xsl\";\n                } else {\n                    if (sAppClass.substr(0, 3) == \"pdp\") sAppFolder = \"pdpjs\";\n                    sXSLFile = \"/versions/\" + sAppFolder + \"/\" + sVersion + \"/components.xsl\";\n                }\n            }\n\n            var processXML = function(sXML, xml) {\n                if (!xml) {\n                    displayError(sXML);\n                    return;\n                }\n\n                /*\n                 * Non-COMPILED kludge to extract the version number from the stylesheet path in the machine XML file;\n                 * we don't need this code in COMPILED (non-DEBUG) releases, because APPVERSION is hard-coded into them.\n                 */\n                if (!COMPILED) {\n                    var aMatch = sXML.match(/<\\?xml-stylesheet[^>]* href=(['\"])[^'\"]*?\\/([0-9.]*)\\/([^'\"]*)\\1/);\n                    if (aMatch) {\n                        XMLVERSION = aMatch[2];\n                    }\n                }\n\n                var transformXML = function(sXSL, xsl) {\n                    if (!xsl) {\n                        displayError(sXSL);\n                        return;\n                    }\n\n                    /*\n                     * Record the XSL file, in case someone wants to save the entire machine later.\n                     * \n                     * NOTE: sXSLFile will never be undefined by this point, but apparently the Closure Compiler doesn't realize that.  \n                     */\n                    Component.addMachineResource(idMachine, sXSLFile || \"\", sXSL);\n\n                    /*\n                     * The <machine> template in components.xsl now generates a \"machine div\" that makes\n                     * the div we required the caller of embedMachine() to provide redundant, so instead\n                     * of appending this fragment to the caller's node, we REPLACE the caller's node.\n                     * This works only because because we ALSO inject the caller's \"machine div\" ID into\n                     * the fragment's ID during parseXML().\n                     *\n                     *      eMachine.innerHTML = sFragment;\n                     *\n                     * Also, if the transform function fails, make sure you're using the appropriate\n                     * \"components.xsl\" and not a \"machine.xsl\", because the latter will not produce valid\n                     * embeddable HTML (and is the most common cause of failure at this final stage).\n                     */\n                    displayMessage(\"Processing \" + sXMLFile + \"...\");\n\n                    /*\n                     * Beginning with Microsoft Edge and the corresponding release of Windows 10, all the\n                     * 'ActiveXObject' crud has gone away; but of course, this code must remain in place if\n                     * we want to continue supporting older Internet Explorer browsers (ie, back to IE9).\n                     */\n                    if (window.ActiveXObject || 'ActiveXObject' in window) {        // second test is required for IE11 on Windows 8.1\n                        var sFragment = xml['transformNode'](xsl);\n                        if (sFragment) {\n                            eMachine.outerHTML = sFragment;\n                            doneMachine();\n                        } else {\n                            displayError(\"transformNodeToObject failed\");\n                        }\n                    }\n                    else if (document.implementation && document.implementation.createDocument) {\n                        var xsltProcessor = new XSLTProcessor();\n                        xsltProcessor['importStylesheet'](xsl);\n                        var eFragment = xsltProcessor['transformToFragment'](xml, document);\n                        if (eFragment) {\n                            /*\n                             * This fails in Microsoft Edge...\n                             *\n                            var machine = eFragment.getElementById(idMachine);\n                            if (!machine) {\n                                displayError(\"machine generation failed: \" + idMachine);\n                            } else\n                            */\n                            if (eMachine.parentNode) {\n                                eMachine.parentNode.replaceChild(eFragment, eMachine);\n                                doneMachine();\n                            } else {\n                                /*\n                                 * NOTE: This error can occur if our Node web server, when processing a folder with\n                                 * both a manifest.xml with a machine.xml reference AND a README.md containing a\n                                 * machine link, generates duplicate embedXXX() calls for the same machine; if the\n                                 * first embedXXX() call finds its target, subsequent calls for the same target will\n                                 * fail.\n                                 *\n                                 * Technically, such a folder is in a misconfigured state, but it happens, in part\n                                 * because when we switched to the Jekyll web server, we had to add machine links to\n                                 * all README.md files where we had previously relied on manifest.xml or machine.xml\n                                 * processing.  This is because the Jekyll web server currently doesn't process XML\n                                 * files, nor is support for that likely to be added any time soon; it was a nice\n                                 * feature of the Node web server, but it's not clear that it's worth doing for Jekyll.\n                                 */\n                                displayError(\"invalid machine element: \" + idMachine);\n                            }\n                        } else {\n                            displayError(\"transformToFragment failed\");\n                        }\n                    } else {\n                        /*\n                         * Perhaps I should have performed this test at the outset; on the other hand, I'm\n                         * not aware of any browsers don't support one or both of the above XSLT transformation\n                         * methods, so treat this as a bug.\n                         */\n                        displayError(\"unable to transform XML: unsupported browser\");\n                    }\n                };\n                /*\n                 * NOTE: sXSLFile will never be undefined by this point, but apparently the Closure Compiler doesn't realize that.  \n                 */\n                loadXML(sXSLFile || \"\", \"\", sAppName, sAppClass, \"\", \"\", false, displayMessage, transformXML);\n            };\n\n            if (sXMLFile.charAt(0) != '<') {\n                loadXML(sXMLFile, idMachine, sAppName, sAppClass, sParms || \"\", sClass || \"\", true, displayMessage, processXML);\n            } else {\n                parseXML(sXMLFile, \"\", idMachine, sAppName, sAppClass, sParms || \"\", sClass || \"\", false, displayMessage, processXML);\n            }\n        } else {\n            displayError(\"missing machine element: \" + idMachine);\n        }\n    } catch(e) {\n        displayError(e.message);\n    }\n    return fSuccess;\n}\n\n/**\n * embedC1P(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n *\n * @param {string} idMachine\n * @param {string} [sXMLFile]\n * @param {string} [sXSLFile]\n * @param {string} [sParms]\n * @param {string} [sClass]\n * @return {boolean} true if successful, false if error\n */\nfunction embedC1P(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"C1Pjs\", \"c1pjs\", APPVERSION, idMachine, sXMLFile, sXSLFile, undefined, sClass);\n}\n\n/**\n * embedPCx86(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n *\n * @param {string} idMachine\n * @param {string} [sXMLFile]\n * @param {string} [sXSLFile]\n * @param {string} [sParms]\n * @param {string} [sClass]\n * @return {boolean} true if successful, false if error\n */\nfunction embedPCx86(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"PCx86\", \"pcx86\", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms, sClass);\n}\n\n/**\n * embedPC8080(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n *\n * @param {string} idMachine\n * @param {string} [sXMLFile]\n * @param {string} [sXSLFile]\n * @param {string} [sParms]\n * @param {string} [sClass]\n * @return {boolean} true if successful, false if error\n */\nfunction embedPC8080(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"PC8080\", \"pc8080\", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms, sClass);\n}\n\n/**\n * embedPDP10(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n *\n * @param {string} idMachine\n * @param {string} [sXMLFile]\n * @param {string} [sXSLFile]\n * @param {string} [sParms]\n * @param {string} [sClass]\n * @return {boolean} true if successful, false if error\n */\nfunction embedPDP10(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"PDPjs\", \"pdp10\", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms, sClass);\n}\n\n/**\n * embedPDP11(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n *\n * @param {string} idMachine\n * @param {string} [sXMLFile]\n * @param {string} [sXSLFile]\n * @param {string} [sParms]\n * @param {string} [sClass]\n * @return {boolean} true if successful, false if error\n */\nfunction embedPDP11(idMachine, sXMLFile, sXSLFile, sParms, sClass)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"PDPjs\", \"pdp11\", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms, sClass);\n}\n\n/**\n * findMachineComponent(idMachine, sType)\n *\n * @param {string} idMachine\n * @param {string} sType\n * @return {Component|null}\n */\nfunction findMachineComponent(idMachine, sType)\n{\n    return Component.getComponentByType(sType, idMachine + \".machine\");\n}\n\n/**\n * commandMachine(control, fSingle, idMachine, sComponent, sCommand, sValue)\n *\n * Use Component methods to find the requested component for a specific machine, and if the component is found,\n * then check its 'exports' table for an entry matching the specified command string, and if an entry is found, then\n * the corresponding function is called with the specified data.\n *\n * @param {Object} control\n * @param {boolean} fSingle\n * @param {string} idMachine\n * @param {string} sComponent\n * @param {string} sCommand\n * @param {string} [sValue]\n * @return {boolean}\n */\nfunction commandMachine(control, fSingle, idMachine, sComponent, sCommand, sValue)\n{\n    if (sCommand == \"script\") {\n        if (Component.processScript(idMachine, sValue)) {\n            if (fSingle) control.disabled = true;\n            return true;\n        }\n        return false;\n    }\n    if (sComponent) {\n        var component = Component.getComponentByType(sComponent, idMachine + \".machine\");\n        if (component) {\n            var exports = component['exports'];\n            if (exports) {\n                var fnCommand = exports[sCommand];\n                if (fnCommand) {\n                    if (fnCommand.call(component, sValue)) {\n                        if (fSingle) control.disabled = true;\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }\n    }\n    console.log(\"unimplemented: commandMachine('\" + idMachine + \"','\" + sComponent + \"','\" + sCommand + \"','\" + sValue + \"')\");\n    return false;\n}\n\n/**\n * Prevent the Closure Compiler from renaming functions we want to export, by adding them as global properties.\n *\n * TODO: Consider making all these functions properties on a single global object (eg, 'PCjs'), to minimize global\n * pollution and risk of name collision.\n */\nif (APPNAME == \"C1Pjs\") {\n    window['embedC1P']    = embedC1P;\n}\nif (APPNAME == \"PCx86\") {\n    window['embedPC']     = embedPCx86;         // WARNING: embedPC() deprecated as of v1.23.0\n    window['embedPCx86']  = embedPCx86;\n}\nif (APPNAME == \"PC8080\") {\n    window['embedPC8080'] = embedPC8080;\n}\nif (APPNAME == \"PDPjs\") {\n    window['embedPDP10']  = embedPDP10;\n    window['embedPDP11']  = embedPDP11;\n}\n\nwindow['commandMachine'] = commandMachine;\n\nwindow['enableEvents'] = Web.enablePageEvents;\nwindow['sendEvent']    = Web.sendPageEvent;\n"]}