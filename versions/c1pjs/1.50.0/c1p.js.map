{"version":3,"file":"c1p.js","lineCount":201,"mappings":"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","sources":["versions/c1pjs/1.50.0/c1p-uncompiled.js"," [synthetic:util/objectcreate] "," [synthetic:es6/util/setprototypeof] "," [synthetic:es6/util/inherits] "," [synthetic:util/polyfill] "," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:es6/math/trunc] "],"names":["$jscomp.objectCreate","$jscomp.setPrototypeOf","$jscomp.defineProperty","$jscomp.global","toHex","n","cch","fPrefix","v","Math","abs","nGrouping","s","isNaN","pow","radix","ceil","log","g","d","String","fromCharCode","trunc","sPrefix","toHexByte","b","Str.toHex","toHexWord","w","getBaseName","sFileName","sBaseName","i","lastIndexOf","substr","indexOf","getExtension","sExtension","toLowerCase","escapeHTML","sHTML","replace","m","Str.HTMLEscapeMap","Usr.getTime","Date","now","getResource","sURL","done","fAsync","nErrorCode","sResource","resources","xmlHTTP","window","XMLHttpRequest","ActiveXObject","onreadystatechange","xmlHTTP.onreadystatechange","readyState","responseText","status","length","location","protocol","open","send","isUserAgent","userAgent","navigator","match","onCountRepeat","fnRepeat","fnComplete","fnTimeout","doCountRepeat","setTimeout","onClickRepeat","e","fn","doClickRepeat","msRepeat","ms","timer","fIgnoreMouseEvents","onmousedown","e.onmousedown","msDelay","ontouchstart","e.ontouchstart","onmouseup","onmouseout","e.onmouseout","clearTimeout","ontouchend","ontouchcancel","e.ontouchcancel","onPageEvent","sFunc","fnPrev","onInit","Web.aPageEventHandlers","push","doPageEvent","afn","Web.fPageEventsEnabled","Component.alertUser","message","enablePageEvents","fEnable","Web.fPageLoaded","Web.sendPageEvent","Web.fPageShowed","sendPageEvent","sEvent","Web.doPageEvent","Web.parmsURL","Web.onPageEvent","onPageLoad","onPageShow","Web.isUserAgent","onPageUnload","constructor","Component","type","parms","bitsMessage","id","name","bindings","idMachine","flags","ready","busy","busyCancel","initDone","powered","unloading","error","fnReady","clearError","dbg","cpu","cmp","Component.components.push","component","alertUser","sMessage","alert","appendControl","control","sText","value","scrollTop","scrollHeight","bindComponentControls","element","aeControls","Component.getElementsByClass","parentNode","iControl","aeChildNodes","childNodes","iNode","nodeType","sClass","getAttribute","aClasses","split","iClass","Component.getComponentParms","setBinding","getComponentByID","idRelated","undefined","Component.components.length","Component.components","getComponentByType","sType","componentPrev","getComponentParms","sParms","eval","getElementsByClass","sObjClass","getElementsByClassName","j","ae","aeAll","getElementsByTagName","re","RegExp","test","className","processCommands","fSuccess","aCommands","Component.commands","aTokens","splice","sCommand","fnCallReady","Component.asyncCommands.indexOf","processNextCommand","Component.processCommands","fnCommand","Component.globalCommands","Component.getComponentByType","Component.componentCommands","exports","call","Component.prototype","?.prototype","toString","sHTMLType","sBinding","onclick","clearControl","notice","this.notice","println","print","printControl","Component.appendControl","printlnControl","Component.PRINT.PROGRESS","slice","fPrintOnly","computer","console","setError","isReady","setReady","isBusy","fCancel","setBusy","fBusy","messageEnabled","bitsEnabled","bitsWarning","PROGRESS","Component.machines","Component.asyncCommands","scriptAlert","scriptSleep","fnCallback","sDelay","scriptSelect","sValue","aBindings","options","textContent","selectedIndex","Array","prototype","Array.prototype.indexOf","obj","start","isArray","Array.isArray","arg","Object","Function","bind","Function.prototype.bind","fnBound","fToBind","apply","fnNOP","args","concat","arguments","TypeError","C1PPanel","parmsPanel","$jscomp.inherits","kbd","setPower","fOn","C1PPanel.init","init","fReady","aePanels","document","APPCLASS","iPanel","ePanel","panel","Component.getComponentByID","Component.bindComponentControls","Web.onInit","C1PCPU","parmsCPU","clearRegs","running","fAutoStart","SPEED_SLOW","SPEED_FAST","SPEED_MAX","speed","nVideoUpdatesPerSecond","nStatusUpdatesPerSecond","mhzFast","aSpeeds","aSpeedDescs","aReadNotify","aWriteNotify","addrReadLower","addrReadUpper","addrWriteLower","addrWriteUpper","OP_JSR","OP_SIM","SIMOP_MSG","aOpcodeFuncs","opBRK","opORAindx","opSim","opUndefined","opORAzp","opASLzp","opPHP","opORAimm","opASLacc","opORAabs","opASLabs","opBPL","opORAindy","opORAzpx","opASLzpx","opCLC","opORAabsy","opORAabsx","opASLabsx","opJSRabs","opANDindx","opBITzp","opANDzp","opROLzp","opPLP","opANDimm","opROLacc","opBITabs","opANDabs","opROLabs","opBMI","opANDindy","opANDzpx","opROLzpx","opSEC","opANDabsy","opANDabsx","opROLabsx","opRTI","opEORindx","opEORzp","opLSRzp","opPHA","opEORimm","opLSRacc","opJMPimm16","opEORabs","opLSRabs","opBVC","opEORindy","opEORzpx","opLSRzpx","opCLI","opEORabsy","opEORabsx","opLSRabsx","opRTS","opADCindx","opADCzp","opRORzp","opPLA","opADCimm","opRORacc","opJMPabs16","opADCabs","opRORabs","opBVS","opADCindy","opADCzpx","opRORzpx","opSEI","opADCabsy","opADCabsx","opRORabsx","opSTAindx","opSTYzp","opSTAzp","opSTXzp","opDEY","opTXA","opSTYabs","opSTAabs","opSTXabs","opBCC","opSTAindy","opSTYzpx","opSTAzpx","opSTXzpy","opTYA","opSTAabsy","opTXS","opSTAabsx","opLDYimm","opLDAindx","opLDXimm","opLDYzp","opLDAzp","opLDXzp","opTAY","opLDAimm","opTAX","opLDYabs","opLDAabs","opLDXabs","opBCS","opLDAindy","opLDYzpx","opLDAzpx","opLDXzpy","opCLV","opLDAabsy","opTSX","opLDYabsx","opLDAabsx","opLDXabsy","opCPYimm","opCMPindx","opCPYzp","opCMPzp","opDECzp","opINY","opCMPimm","opDEX","opCPYabs","opCMPabs","opDECabs","opBNE","opCMPindy","opCMPzpx","opDECzpx","opCLD","opCMPabsy","opCMPabsx","opDECabsx","opCPXimm","opSBCindx","opCPXzp","opSBCzp","opINCzp","opINX","opSBCimm","opNOP","opCPXabs","opSBCabs","opINCabs","opBEQ","opSBCindy","opSBCzpx","opINCzpx","opSED","opSBCabsy","opSBCabsx","opINCabsx","aOpcodeCycles","C1PCPU.prototype","reset","fPowerOn","halt","regPC","getWord","abMem","VECTOR_RESET","run","fBound","setSpeed","setBuffer","abMemory","end","offMem","cbMem","offLimit","video","displayVideo","updateScreen","setFocus","update","addReadNotify","findNotify","checkReadNotify","addrRead","addrFrom","addWriteNotify","checkWriteNotify","addrWrite","aNotify","fOnClick","innerHTML","nRunCycles","msRunStart","calcCycles","displayReg","sReg","vReg","len","toUpperCase","displayStatus","regA","regX","regY","regP","getRegP","BIT_PC","BIT_PZ","BIT_PI","BIT_PD","BIT_PB","BIT_PV","BIT_PN","regS","mhz","toFixed","fRecalc","nMostUpdatesPerSecond","nYieldsPerSecond","vMultiplier","msPerYield","round","nCyclesPerBurst","floor","nCyclesPerSecond","nCyclesPerYield","nCyclesPerVideoUpdate","nCyclesPerStatusUpdate","nCyclesNextYield","nCyclesNextVideoUpdate","nCyclesNextStatusUpdate","nRecalcCycles","calcRemainingTime","msCurrent","msYield","nCyclesThisRun","msRemainsThisRun","msStartThisRun","msElapsed","calcSpeed","calcStartTime","step","nCycles","nBurstCycles","nStepCycles","stack","stop","nMinCycles","fCompleted","regEA","regEAWrite","aExecBreak","aReadBreak","aWriteBreak","bOpCode","fDebugCheck","fBreak","checkBreakpoint","addr","cIns","aaOpcodeFreqs","aStepHistory","iStepHistory","Str.toHexWord","yieldCPU","getCycles","getByte","regRC","regRZ","regRV","regRU","regRN","setBCD","opADCindxBCD","opADCzpBCD","opADCimmBCD","opADCabsBCD","opADCindyBCD","opADCzpxBCD","opADCabsyBCD","opADCabsxBCD","opSBCindxBCD","opSBCzpBCD","opSBCimmBCD","opSBCabsBCD","opSBCindyBCD","opSBCzpxBCD","opSBCabsyBCD","opSBCabsxBCD","clearBCD","addBCD","reg","mem","carry","r","subBCD","notcarry","bSimOp","SIMOP_HLT","Str.toHexByte","aeCPUs","iCPU","eCPU","C1PROM","parmsROM","abImage","cbROM","sImage","sFileURL","sFileExt","Str.getExtension","FORMAT","host","SITEHOST","rom","Web.getResource","sResponse","convertImage","offROM","setByte","copyImage","messageIO","MESSAGE_PORT","offset","sImageName","sImageData","charAt","ab","asData","sData","parseInt","cbImage","aeROM","iROM","eROM","C1PRAM","parmsRAM","aeRAM","iRAM","eRAM","ram","C1PKeyboard","parmsKbd","nDefaultModel","KEYCODE_DELETE","KEYCODE_LF","KEYCODE_CR","KEYCODE_ESC","CHARCODE_DELETE","CHARCODE_LF","CHARCODE_CR","CHARCODE_ESC","CHARCODE_CTRL","CHARCODE_BREAK","CHARCODE_CTRLC","CHARCODE_CTRLO","BIT_SHIFTLOCK","aButtonCodeMap","aCharCodeMap","CHARCODE_LSHIFT","CHARCODE_RSHIFT","CHARCODE_SHIFTLOCK","C1PKeyboard.prototype","setModel","bitsShift","bKbdRows","abKbdCols","aKbdStates","aKeyTimers","prevKeyDown","prevCharDown","bWriteLast","abKbdColsLast","nCyclesSinceLastEvent","nWritesSinceLastEvent","sInjectBuffer","onkeydown","event","keyEvent","onkeypress","fPass","charCode","which","keyCode","BIT_COMMAND","keyPressSimulate","MESSAGE_KBD","onkeyup","sButton","offKbd","cbKbd","offKbdLimit","nModel","bInvert","fMobile","iOS","calcReleaseDelay","fRepeat","msReleaseRepeat","msReleaseDelay","autoClear","notCharCode","keyEventSimulate","SIMCODE_AUTOCLEAR","injectKeys","sKeyCodes","injectKeysFromBuffer","msInjectDelay","ch","charCodeAt","fDown","fAutoClear","BIT_LSHIFT","PSEUDO_CHARCODE","BIT_RSHIFT","BIT_CTRL","KEYCODE_COMMAND","KEYCODE_TAB","SIMCODE_KEYEVENT","fSimulated","SIMCODE_KEYPRESS","SIMCODE_KEYRELEASE","SIMCODE_KEYTIMEOUT","simCode","bShift","bCode","iRow","iCol","BITS_SIMULATE","fPropagate","updateMemory","C1PKeyboard_prototype$setByte","nCycleDelta","nCyclesThreshold","shift","aeKbd","iKbd","eKbd","C1PVideo","parmsVideo","canvas","context","imgChars","nDefaultCols","nDefaultRows","cxScreen","cyScreen","cxChar","cyChar","setDimensions","canvasScreen","contextScreen","asWebPrefixes","fSmoothing","aParms","search","pl","exec","decodeURIComponent","sSmoothing","C1PVideo.prototype","offVideo","offVideoLimit","random","initScreen","cbVideo","addrVideoPort","nCols","nRows","iRowTop","nRowsVisible","cbScreen","setDrawingDimensions","cxCharDst","cyCharDst","focus","addrGuard","tripGuard","width","height","MESSAGE_VIDEO","nCyclesHigh","C1PVideo_prototype$setByte","aBounds","addrLower","addrUpper","abScreen","row","writeByte","xChar","drawImage","aeVideo","iVideo","eVideo","eCanvas","createElement","getContext","setAttribute","style","backgroundColor","clientWidth","onresize","eParent","eChild","cx","cy","appendChild","imgCharSet","Image","eContext","onload","src","C1PSerialPort","parmsSerial","fDemo","C1PSerialPort.prototype","fHard","autoLoad","C1PSerialPort.AUTOLOAD_6502","bInput","iInput","sInput","nMachine","getMachineNum","aDigits","fConvertLF","C1PSerialPort.AUTOLOAD_NONE","serial","C1PSerialPort.AUTOLOAD_BASIC","control.onclick","loadFile","onchange","control.onchange","fieldset","children","submit","disabled","files","onsubmit","control.onsubmit","file","currentTarget","reader","FileReader","reader.onload","result","readAsText","removeChild","offPort","cbPort","offPortLimit","sFileData","nResponse","sSuffix","data","advanceInput","C1PSerialPort_prototype$setByte","MESSAGE_SERIAL","C1PSerialPort.STATUS_DATA","C1PSerialPort.STATUS_NONE","aeSerial","iSerial","eSerial","C1PDiskController","parmsDC","C1PDiskController.prototype","resetRegs","iDriveSelect","aDrives","resetDrive","iDrive","iType","DRIVETYPE_5INCH","nTracks","MAXTRACKS_5INCH","fProtected","nIndexPulse","iTrackSelect","iTrackOffset","aTracks","regDDA","bits","PDA_SD2","read","controller","regCRA","CR_PD_SEL","writePort","PORT_DDA","regPDA","bPDA","setSelectedDrive","regPDB","drive","stopDriveData","advanceDriveData","PORT_PDA","PORT_CRA","regDDB","regCRB","PORT_DDB","bPDB","PDB_ST","PDB_STI","MESSAGE_DISK","PDA_IHD","PORT_PDB","PORT_CRB","regCTRL","CTRL_CDIV","regSTAT","bSTAT","STAT_RDRF","PORT_STAT","regDATA","PORT_DATA","regUnknown","sFilePath","Str.getBaseName","loadDisk","addrController","sDiskName","sDiskData","aHeads","iTrack","iTrackNum","track","sectors","Error","trackData","pushSig","pushBCD","pushBin","iSector","sector","sectorData","a","o","k","cb","getReg","port","fWrite","PORT_CTRL","sName","C1PDiskController_prototype$setByte","aBitIDs","bTest","bChanged","PDB_SD1","aeDC","iDC","eDC","C1PDebugger","parmsDbg","nextAddr","prevCmd","fAssemble","addrAssembleNext","clearBreakpoints","MESSAGE_NONE","aMessageCategories","aOpCodes","aOpSimCodes","setOpModes","aaOperations","OP_BRK","OP_ORA","MODE_INDX","MODE_ZP","OP_ASL","OP_PHP","MODE_IMM","MODE_ACC","MODE_ABS","OP_BPL","MODE_DISP","MODE_INDY","MODE_ZPX","OP_CLC","MODE_ABSY","MODE_ABSX","MODE_IMM16","OP_AND","OP_BIT","OP_ROL","OP_PLP","OP_BMI","OP_SEC","OP_RTI","OP_EOR","OP_LSR","OP_PHA","OP_JMP","OP_BVC","OP_CLI","OP_RTS","OP_ADC","OP_ROR","OP_PLA","MODE_ABS16","OP_BVS","OP_SEI","OP_STA","OP_STY","OP_STX","OP_DEY","OP_TXA","OP_BCC","MODE_ZPY","OP_TYA","OP_TXS","OP_LDY","OP_LDA","OP_LDX","OP_TAY","OP_TAX","OP_BCS","OP_CLV","OP_TSX","OP_CPY","OP_CMP","OP_DEC","OP_INY","OP_DEX","OP_BNE","OP_CLD","OP_CPX","OP_SBC","OP_INC","OP_INX","OP_NOP","OP_BEQ","OP_SED","C1PDebugger.prototype","eDebug","C1PDebugger.input","Web.onClickRepeat","fClassic","sRegEx","aOpModes","iMode","sMode","regexOpModes","aImm16Codes","isCPUOK","fStep","fStepOver","doUnassemble","doRegisters","msStart","msTotal","clearTempBreakpoint","addSignedByte","addExecBreakpoint","findBreakpoint","findExecBreakpoint","fRemove","aBreak","fMatch","setTempBreakpoint","addrTempBP","aBreakpoints","getInstruction","nIns","sLine","aOpDesc","abOperand","OP_DB","sOperand","bOpMode","pop","nextIns","getUserAddr","sAddr","nBase","doFreqs","sParm","cData","aaSortedOpcodeFreqs","sort","p","q","bOpcode","cFreq","sAddrEnd","addrEnd","sIns","asArgs","fIns","getRegs","doTrace","sCount","c","Web.onCountRepeat","input","sCmd","aOpBytes","sCode","iCode","aModeMatch","cModes","asHex","nHex","cBreaks","aAddrs","cLines","sLen","line","sChars","sBytes","addrLine","sOption","sCategory","iHistory","aHistory","nextHistory","nInsHistory","aeDbg","iDbg","eDbg","C1PComputer","parmsComputer","modules","power","C1PComputer.power","aeComputers","iComputer","eComputer","addrStart","iAddr","addrInfo","controlPrint","aComponents","iComponent","cAsyncMachines","loadXML","sXMLFile","fResolve","display","doneLoadXML","sURLName","sXML","parseXML","buildXML","sError","pathname","xmlDoc","async","parseFromString","DOMParser","resolveXML","matchRef","reRef","sRefFile","doneReadXML","sXMLRef","sRefAttrs","aXMLRefTag","sXMLNewTag","matchAttr","reAttr","embedMachine","sXSLFile","displayMessage","eWarning","aeWarning","eMachine","Str.escapeHTML","displayError","Web.enablePageEvents","getElementById","css","head","styleSheet","cssText","createTextNode","processXML","xml","transformXML","sXSL","xsl","sFragment","outerHTML","implementation","createDocument","xsltProcessor","XSLTProcessor","eFragment","replaceChild","embedC1P","commandMachine","fSingle","sComponent","sToken","chQuote"],"sourcesContent":["\"use strict\";\n\n/**\n * @copyright http://pcjs.org/modules/shared/lib/defines.js (C) Jeff Parsons 2012-2017\n */\n\n/**\n * @define {string}\n */\nvar APPVERSION = \"1.x.x\";       // this @define is overridden by the Closure Compiler with the version in package.json\n\nvar XMLVERSION = null;          // this is set in non-COMPILED builds by embedMachine() if a version number was found in the machine XML\n\nvar COPYRIGHT = \"Copyright  2012-2017 Jeff Parsons <Jeff@pcjs.org>\";\n\nvar LICENSE = \"License: GPL version 3 or later <http://gnu.org/licenses/gpl.html>\";\n\nvar CSSCLASS = \"pcjs\";\n\n/**\n * @define {string}\n */\nvar SITEHOST = \"localhost:8088\";// this @define is overridden by the Closure Compiler with \"www.pcjs.org\"\n\n/**\n * @define {boolean}\n */\nvar COMPILED = false;           // this @define is overridden by the Closure Compiler (to true)\n\n/**\n * @define {boolean}\n */\nvar DEBUG = true;               // this @define is overridden by the Closure Compiler (to false) to remove DEBUG-only code\n\n/**\n * @define {boolean}\n */\nvar MAXDEBUG = false;           // this @define is overridden by the Closure Compiler (to false) to remove MAXDEBUG-only code\n\n/**\n * @define {boolean}\n */\nvar PRIVATE = false;            // this @define is overridden by the Closure Compiler (to false) to enable PRIVATE code\n\n/*\n * RS-232 DB-25 Pin Definitions, mapped to bits 1-25 in a 32-bit status value.\n *\n * SerialPorts in PCjs machines are considered DTE (Data Terminal Equipment), which means they should be \"virtually\"\n * connected to each other via a null-modem cable, which assumes the following cross-wiring:\n *\n *     G       1  <->  1        G       (Ground)\n *     TD      2  <->  3        RD      (Received Data)\n *     RD      3  <->  2        TD      (Transmitted Data)\n *     RTS     4  <->  5        CTS     (Clear To Send)\n *     CTS     5  <->  4        RTS     (Request To Send)\n *     DSR   6+8  <->  20       DTR     (Data Terminal Ready)\n *     SG      7  <->  7        SG      (Signal Ground)\n *     DTR    20  <->  6+8      DSR     (Data Set Ready + Carrier Detect)\n *     RI     22  <->  22       RI      (Ring Indicator)\n *\n * TODO: Move these definitions to a more appropriate shared file at some point.\n */\nvar RS232 = {\n    RTS: {\n        PIN:  4,\n        MASK: 0x00000010\n    },\n    CTS: {\n        PIN:  5,\n        MASK: 0x00000020\n    },\n    DSR: {\n        PIN:  6,\n        MASK: 0x00000040\n    },\n    CD: {\n        PIN:  8,\n        MASK: 0x00000100\n    },\n    DTR: {\n        PIN:  20,\n        MASK: 0x00100000\n    },\n    RI: {\n        PIN:  22,\n        MASK: 0x00400000\n    }\n};\n\n/*\n * NODE should be true if we're running under NodeJS (eg, command-line), false if not (eg, web browser)\n */\nvar NODE = false;\n\n\n/**\n * @copyright http://pcjs.org/modules/shared/lib/dumpapi.js (C) Jeff Parsons 2012-2017\n */\n\n/*\n * Our \"DiskDump API\", such as it was, used to look like:\n *\n *      http://jsmachines.net/bin/convdisk.php?disk=/disks/pc/dos/ibm/2.00/PCDOS200-DISK1.json&format=img\n *\n * To make it (a bit) more \"REST-like\", the above request now looks like:\n *\n *      http://www.pcjs.org/api/v1/dump?disk=/disks/pc/dos/ibm/2.00/PCDOS200-DISK1.json&format=img\n *\n * Similarly, our \"FileDump API\" used to look like:\n *\n *      http://jsmachines.net/bin/convrom.php?rom=/devices/pc/rom/5150/1981-04-24/PCBIOS-REV1.rom&format=json\n *\n * and that request now looks like:\n *\n *      http://www.pcjs.org/api/v1/dump?file=/devices/pc/rom/5150/1981-04-24/PCBIOS-REV1.rom&format=json\n *\n * I don't think it makes sense to avoid \"query\" parameters, because blending the path of a disk image with the\n * the rest of the URL would be (a) confusing, and (b) more work to parse.\n */\nvar DumpAPI = {\n    ENDPOINT:       \"/api/v1/dump\",\n    QUERY: {\n        DIR:        \"dir\",      // value is path of a directory (DiskDump only)\n        DISK:       \"disk\",     // value is path of a disk image (DiskDump only)\n        FILE:       \"file\",     // value is path of a ROM image file (FileDump only)\n        IMG:        \"img\",      // alias for DISK\n        PATH:       \"path\",     // value is path of a one or more files (DiskDump only)\n        FORMAT:     \"format\",   // value is one of FORMAT values below\n        COMMENTS:   \"comments\", // value is either \"true\" or \"false\"\n        DECIMAL:    \"decimal\",  // value is either \"true\" to force all numbers to decimal, \"false\" or undefined otherwise\n        MBHD:       \"mbhd\",     // value is hard drive size in Mb (formerly \"mbsize\") (DiskDump only) (DEPRECATED)\n        SIZE:       \"size\"      // value is target disk size in Kb (supersedes \"mbhd\") (DiskDump only)\n    },\n    FORMAT: {\n        JSON:       \"json\",     // default\n        JSON_GZ:    \"gz\",       // gzip is currently used ONLY for compressed JSON\n        DATA:       \"data\",     // same as \"json\", but built without JSON.stringify() (DiskDump only)\n        HEX:        \"hex\",      // deprecated\n        OCTAL:      \"octal\",    // displays data as octal words\n        BYTES:      \"bytes\",    // displays data as hex bytes; normally used only when comments are enabled\n        WORDS:      \"words\",    // displays data as hex words; normally used only when comments are enabled\n        LONGS:      \"longs\",    // displays data as dwords\n        IMG:        \"img\",      // returns the raw disk data (ie, using a Buffer object) (DiskDump only)\n        ROM:        \"rom\"       // returns the raw file data (ie, using a Buffer object) (FileDump only)\n    }\n};\n\n/*\n * Because we use an overloaded API endpoint (ie, one that's shared with the FileDump module), we must\n * also provide a list of commands which, when combined with the endpoint, define a unique request.\n */\nDumpAPI.asDiskCommands = [DumpAPI.QUERY.DIR, DumpAPI.QUERY.DISK, DumpAPI.QUERY.PATH];\nDumpAPI.asFileCommands = [DumpAPI.QUERY.FILE];\n\n\n\n/**\n * @copyright http://pcjs.org/modules/shared/lib/reportapi.js (C) Jeff Parsons 2012-2017\n */\n\nvar ReportAPI = {\n    ENDPOINT:       \"/api/v1/report\",\n    QUERY: {\n        APP:        \"app\",\n        VER:        \"ver\",\n        URL:        \"url\",\n        USER:       \"user\",\n        TYPE:       \"type\",\n        DATA:       \"data\"\n    },\n    TYPE: {\n        BUG:        \"bug\"\n    },\n    RES: {\n        OK:         \"Thank you\"\n    }\n};\n\n\n\n/**\n * @copyright http://pcjs.org/modules/shared/lib/strlib.js (C) Jeff Parsons 2012-2017\n */\n\nclass Str {\n    /**\n     * isValidInt(s, base)\n     *\n     * The built-in parseInt() function has the annoying feature of returning a partial value (ie,\n     * up to the point where it encounters an invalid character); eg, parseInt(\"foo\", 16) returns 0xf.\n     *\n     * So it's best to use our own Str.parseInt() function, which will in turn use this function to\n     * validate the entire string.\n     *\n     * @param {string} s is the string representation of some number\n     * @param {number} [base] is the radix to use (default is 10); only 2, 8, 10 and 16 are supported\n     * @return {boolean} true if valid, false if invalid (or the specified base isn't supported)\n     */\n    static isValidInt(s, base)\n    {\n        if (!base || base == 10) return s.match(/^-?[0-9]+$/) !== null;\n        if (base == 16) return s.match(/^-?[0-9a-f]+$/i) !== null;\n        if (base == 8) return s.match(/^-?[0-7]+$/) !== null;\n        if (base == 2) return s.match(/^-?[01]+$/) !== null;\n        return false;\n    }\n\n    /**\n     * parseInt(s, base)\n     *\n     * This is a wrapper around the built-in parseInt() function.  Our wrapper recognizes certain prefixes\n     * ('$' or \"0x\" for hex, '#' or \"0o\" for octal) and suffixes ('.' for decimal, 'h' for hex, 'y' for\n     * binary), and then calls isValidInt() to ensure we don't convert strings that contain partial values;\n     * see isValidInt() for details.\n     *\n     * The use of multiple prefix/suffix combinations is undefined (although for the record, we process\n     * prefixes first).  We do NOT support the \"0b\" prefix to indicate binary UNLESS one or more commas are\n     * also present (because \"0b\" is also a valid hex sequence), and we do NOT support a single leading zero\n     * to indicate octal (because such a number could also be decimal or hex).  Any number of commas are\n     * allowed; we remove them all before calling the built-in parseInt().\n     *\n     * More recently, we've added support for \"^D\", \"^O\", and \"^B\" prefixes to accommodate the base overrides\n     * that the PDP-10's MACRO-10 assembly language supports (decimal, octal, and binary, respectively).\n     * If this support turns out to adversely affect other debuggers, then it will have to be \"conditionalized\".\n     * Similarly, we've added support for \"K\", \"M\", and \"G\" MACRO-10-style suffixes that add 3, 6, or 9 zeros\n     * to the value to be parsed, respectively.\n     *\n     * @param {string} s is the string representation of some number\n     * @param {number} [base] is the radix to use (default is 10); can be overridden by prefixes/suffixes\n     * @return {number|undefined} corresponding value, or undefined if invalid\n     */\n    static parseInt(s, base)\n    {\n        var value;\n\n        if (s) {\n            if (!base) base = 10;\n\n            var ch, chPrefix, chSuffix;\n            var fCommas = (s.indexOf(',') > 0);\n            if (fCommas) s = s.replace(/,/g, '');\n\n            ch = chPrefix = s.charAt(0);\n            if (chPrefix == '#') {\n                base = 8;\n                chPrefix = '';\n            }\n            else if (chPrefix == '$') {\n                base = 16;\n                chPrefix = '';\n            }\n            if (ch != chPrefix) {\n                s = s.substr(1);\n            }\n            else {\n                ch = chPrefix = s.substr(0, 2);\n                if (chPrefix == '0b' && fCommas || chPrefix == '^B') {\n                    base = 2;\n                    chPrefix = '';\n                }\n                else if (chPrefix == '0o' || chPrefix == '^O') {\n                    base = 8;\n                    chPrefix = '';\n                }\n                else if (chPrefix == '^D') {\n                    base = 10;\n                    chPrefix = '';\n                }\n                else if (chPrefix == '0x') {\n                    base = 16;\n                    chPrefix = '';\n                }\n                if (ch != chPrefix) s = s.substr(2);\n            }\n            ch = chSuffix = s.slice(-1);\n            if (chSuffix == 'Y' || chSuffix == 'y') {\n                base = 2;\n                chSuffix = '';\n            }\n            else if (chSuffix == '.') {\n                base = 10;\n                chSuffix = '';\n            }\n            else if (chSuffix == 'H' || chSuffix == 'h') {\n                base = 16;\n                chSuffix = '';\n            }\n            else if (chSuffix == 'K') {\n                chSuffix = '000';\n            }\n            else if (chSuffix == 'M') {\n                chSuffix = '000000';\n            }\n            else if (chSuffix == 'G') {\n                chSuffix = '000000000';\n            }\n            if (ch != chSuffix) s = s.slice(0, -1) + chSuffix;\n            /*\n             * This adds support for the MACRO-10 binary shifting (Bn) suffix, which must be stripped from the\n             * number before parsing, and then applied to the value after parsing.  If n is omitted, 35 is assumed,\n             * which is a net shift of zero.  If n < 35, then a left shift of (35 - n) is required; if n > 35, then\n             * a right shift of -(35 - n) is required.\n             */\n            var v, shift = 0;\n            if (base <= 10) {\n                var match = s.match(/(-?[0-9]+)B([0-9]*)/);\n                if (match) {\n                    s = match[1];\n                    shift = 35 - ((match[2] || 35) & 0xff);\n                }\n            }\n            if (Str.isValidInt(s, base) && !isNaN(v = parseInt(s, base))) {\n                /*\n                 * With the need to support larger (eg, 36-bit) integers, truncating to 32 bits is no longer helpful.\n                 *\n                 *      value = v|0;\n                 */\n                if (shift) {\n                    /*\n                     * Since binary shifting is a logical operation, and since shifting by division only works properly\n                     * with positive numbers, we must convert a negative value to a positive value, by computing the two's\n                     * complement.\n                     */\n                    if (v < 0) v += Math.pow(2, 36);\n                    if (shift > 0) {\n                        v *= Math.pow(2, shift);\n                    } else {\n                        v = Math.trunc(v / Math.pow(2, -shift));\n                    }\n                }\n                value = v;\n            }\n        }\n        return value;\n    }\n\n    /**\n     * toBase(n, radix, cch, sPrefix, nGrouping)\n     *\n     * Displays the given number as an unsigned integer using the specified radix and number of digits.\n     *\n     * @param {number|null|undefined} n\n     * @param {number} radix (ie, the base)\n     * @param {number} cch (the desired number of digits)\n     * @param {string} [sPrefix] (default is none)\n     * @param {number} [nGrouping]\n     * @return {string}\n     */\n    static toBase(n, radix, cch, sPrefix = \"\", nGrouping = 0)\n    {\n        /*\n         * An initial \"falsey\" check for null takes care of both null and undefined;\n         * we can't rely entirely on isNaN(), because isNaN(null) returns false, oddly enough.\n         *\n         * Alternatively, we could mask and shift n regardless of whether it's null/undefined/NaN,\n         * since JavaScript coerces such operands to zero, but I think there's \"value\" in seeing those\n         * values displayed differently.\n         */\n        var s = \"\";\n        if (isNaN(n)) {\n            n = null;\n        } else if (n != null) {\n            /*\n             * Callers that produced an input by dividing by a power of two rather than shifting (in order\n             * to access more than 32 bits) may produce a fractional result, which ordinarily we would simply\n             * ignore, but if the integer portion is zero and the sign is negative, we should probably treat\n             * this value as a sign-extension.\n             */\n            if (n < 0 && n > -1) n = -1;\n            /*\n             * Negative values should be two's complemented according to the number of digits; for example,\n             * 12 octal digits implies an upper limit 8^12.\n             */\n            if (n < 0) {\n                n += Math.pow(radix, cch);\n            }\n            if (n >= Math.pow(radix, cch)) {\n                cch = Math.ceil(Math.log(n) / Math.log(radix));\n            }\n        }\n        var g = nGrouping || -1;\n        while (cch-- > 0) {\n            if (!g) {\n                s = ',' + s;\n                g = nGrouping;\n            }\n            if (n == null) {\n                s = '?' + s;\n            } else {\n                var d = n % radix;\n                d += (d >= 0 && d <= 9? 0x30 : 0x41 - 10);\n                s = String.fromCharCode(d) + s;\n                n = Math.trunc(n / radix);\n            }\n            g--;\n        }\n        return sPrefix + s;\n    }\n\n    /**\n     * toBin(n, cch, nGrouping)\n     *\n     * Converts an integer to binary, with the specified number of digits (up to a maximum of 36).\n     *\n     * @param {number|null|undefined} n (supports integers up to 36 bits now)\n     * @param {number} [cch] is the desired number of binary digits (0 or undefined for default of either 8, 18, or 36)\n     * @param {number} [nGrouping]\n     * @return {string} the binary representation of n\n     */\n    static toBin(n, cch, nGrouping)\n    {\n        if (!cch) {\n            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.LN2) || 1;\n            var v = Math.abs(n);\n            if (v <= 0b11111111) {\n                cch = 8;\n            } else if (v <= 0b111111111111111111) {\n                cch = 18;\n            } else {\n                cch = 36;\n            }\n        } else if (cch > 36) cch = 36;\n        return Str.toBase(n, 2, cch, \"\", nGrouping);\n    }\n\n    /**\n     * toBinBytes(n, cb, fPrefix)\n     *\n     * Converts an integer to binary, with the specified number of bytes (up to the default of 4).\n     *\n     * @param {number|null|undefined} n (interpreted as a 32-bit value)\n     * @param {number} [cb] is the desired number of binary bytes (4 is both the default and the maximum)\n     * @param {boolean} [fPrefix]\n     * @return {string} the binary representation of n\n     */\n    static toBinBytes(n, cb, fPrefix)\n    {\n        var s = \"\";\n        if (!cb || cb > 4) cb = 4;\n        for (var i = 0; i < cb; i++) {\n            if (s) s = ',' + s;\n            s = Str.toBin(n & 0xff, 8) + s;\n            n >>= 8;\n        }\n        return (fPrefix? \"0b\" : \"\") + s;\n    }\n\n    /**\n     * toOct(n, cch, fPrefix)\n     *\n     * Converts an integer to octal, with the specified number of digits (default of 6; max of 12)\n     *\n     * You might be tempted to use the built-in n.toString(8) instead, but it doesn't zero-pad and it\n     * doesn't properly convert negative values.  Moreover, if n is undefined, n.toString() will throw\n     * an exception, whereas this function will return '?' characters.\n     *\n     * @param {number|null|undefined} n (supports integers up to 36 bits now)\n     * @param {number} [cch] is the desired number of octal digits (0 or undefined for default of either 6, 8, or 12)\n     * @param {boolean} [fPrefix]\n     * @return {string} the octal representation of n\n     */\n    static toOct(n, cch, fPrefix)\n    {\n        if (!cch) {\n            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.log(8)) || 1;\n            var v = Math.abs(n);\n            if (v <= 0o777777) {\n                cch = 6;\n            } else if (v <= 0o77777777) {\n                cch = 8;\n            } else {\n                cch = 12;\n            }\n        } else if (cch > 12) cch = 12;\n        return Str.toBase(n, 8, cch, fPrefix? \"0o\" : \"\");\n    }\n\n    /**\n     * toDec(n, cch)\n     *\n     * Converts an integer to decimal, with the specified number of digits (default of 5; max of 11)\n     *\n     * You might be tempted to use the built-in n.toString(10) instead, but it doesn't zero-pad and it\n     * doesn't properly convert negative values.  Moreover, if n is undefined, n.toString() will throw\n     * an exception, whereas this function will return '?' characters.\n     *\n     * @param {number|null|undefined} n (supports integers up to 36 bits now)\n     * @param {number} [cch] is the desired number of decimal digits (0 or undefined for default of either 5 or 11)\n     * @return {string} the decimal representation of n\n     */\n    static toDec(n, cch)\n    {\n        if (!cch) {\n            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.LN10) || 1;\n            var v = Math.abs(n);\n            if (v <= 99999) {\n                cch = 5;\n            } else {\n                cch = 11;\n            }\n        } else if (cch > 11) cch = 11;\n        return Str.toBase(n, 10, cch);\n    }\n\n    /**\n     * toHex(n, cch, fPrefix)\n     *\n     * Converts an integer to hex, with the specified number of digits (default of 4 or 8, max of 9).\n     *\n     * You might be tempted to use the built-in n.toString(16) instead, but it doesn't zero-pad and it\n     * doesn't properly convert negative values; for example, if n is -2147483647, then n.toString(16)\n     * will return \"-7fffffff\" instead of \"80000001\".  Moreover, if n is undefined, n.toString() will\n     * throw an exception, whereas this function will return '?' characters.\n     *\n     * NOTE: The following work-around (adapted from code found on StackOverflow) would be another solution,\n     * taking care of negative values, zero-padding, and upper-casing, but not null/undefined/NaN values:\n     *\n     *      s = (n < 0? n + 0x100000000 : n).toString(16);\n     *      s = \"00000000\".substr(0, 8 - s.length) + s;\n     *      s = s.substr(0, cch).toUpperCase();\n     *\n     * @param {number|null|undefined} n (supports integers up to 36 bits now)\n     * @param {number} [cch] is the desired number of hex digits (0 or undefined for default of either 4, 8, or 9)\n     * @param {boolean} [fPrefix]\n     * @return {string} the hex representation of n\n     */\n    static toHex(n, cch, fPrefix)\n    {\n        if (!cch) {\n            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.log(16)) || 1;\n            var v = Math.abs(n);\n            if (v <= 0xffff) {\n                cch = 4;\n            } else if (v <= 0xffffffff) {\n                cch = 8;\n            } else {\n                cch = 9;\n            }\n        } else if (cch > 9) cch = 9;\n        return Str.toBase(n, 16, cch, fPrefix? \"0x\" : \"\");\n    }\n\n    /**\n     * toHexByte(b)\n     *\n     * Alias for Str.toHex(b, 2, true)\n     *\n     * @param {number|null|undefined} b is a byte value\n     * @return {string} the hex representation of b\n     */\n    static toHexByte(b)\n    {\n        return Str.toHex(b, 2, true);\n    }\n\n    /**\n     * toHexWord(w)\n     *\n     * Alias for Str.toHex(w, 4, true)\n     *\n     * @param {number|null|undefined} w is a word (16-bit) value\n     * @return {string} the hex representation of w\n     */\n    static toHexWord(w)\n    {\n        return Str.toHex(w, 4, true);\n    }\n\n    /**\n     * toHexLong(l)\n     *\n     * Alias for Str.toHex(l, 8, true)\n     *\n     * @param {number|null|undefined} l is a dword (32-bit) value\n     * @return {string} the hex representation of w\n     */\n    static toHexLong(l)\n    {\n        return Str.toHex(l, 8, true);\n    }\n\n    /**\n     * getBaseName(sFileName, fStripExt)\n     *\n     * This is a poor-man's version of Node's path.basename(), which Node-only components should use instead.\n     *\n     * Note that if fStripExt is true, this strips ANY extension, whereas path.basename() strips the extension only\n     * if it matches the second parameter (eg, path.basename(\"/foo/bar/baz/asdf/quux.html\", \".html\") returns \"quux\").\n     *\n     * @param {string} sFileName\n     * @param {boolean} [fStripExt]\n     * @return {string}\n     */\n    static getBaseName(sFileName, fStripExt)\n    {\n        var sBaseName = sFileName;\n\n        var i = sFileName.lastIndexOf('/');\n        if (i >= 0) sBaseName = sFileName.substr(i + 1);\n\n        /*\n         * This next bit is a kludge to clean up names that are part of a URL that includes unsightly query parameters.\n         */\n        i = sBaseName.indexOf('&');\n        if (i > 0) sBaseName = sBaseName.substr(0, i);\n\n        if (fStripExt) {\n            i = sBaseName.lastIndexOf(\".\");\n            if (i > 0) {\n                sBaseName = sBaseName.substring(0, i);\n            }\n        }\n        return sBaseName;\n    }\n\n    /**\n     * getExtension(sFileName)\n     *\n     * This is a poor-man's version of Node's path.extname(), which Node-only components should use instead.\n     *\n     * Note that we EXCLUDE the period from the returned extension, whereas path.extname() includes it.\n     *\n     * @param {string} sFileName\n     * @return {string} the filename's extension (in lower-case and EXCLUDING the \".\"), or an empty string\n     */\n    static getExtension(sFileName)\n    {\n        var sExtension = \"\";\n        var i = sFileName.lastIndexOf(\".\");\n        if (i >= 0) {\n            sExtension = sFileName.substr(i + 1).toLowerCase();\n        }\n        return sExtension;\n    }\n\n    /**\n     * endsWith(s, sSuffix)\n     *\n     * @param {string} s\n     * @param {string} sSuffix\n     * @return {boolean} true if s ends with sSuffix, false if not\n     */\n    static endsWith(s, sSuffix)\n    {\n        return s.indexOf(sSuffix, s.length - sSuffix.length) !== -1;\n    }\n\n    /**\n     * escapeHTML(sHTML)\n     *\n     * @param {string} sHTML\n     * @return {string} with HTML entities \"escaped\", similar to PHP's htmlspecialchars()\n     */\n    static escapeHTML(sHTML)\n    {\n        return sHTML.replace(/[&<>\"']/g, function(m)\n        {\n            return Str.HTMLEscapeMap[m];\n        });\n    }\n\n    /**\n     * replace(sSearch, sReplace, s)\n     *\n     * The JavaScript replace() function ALWAYS interprets \"$\" specially in replacement strings, even when\n     * the search string is NOT a RegExp; specifically:\n     *\n     *      $$  Inserts a \"$\"\n     *      $&  Inserts the matched substring\n     *      $`  Inserts the portion of the string that precedes the matched substring\n     *      $'  Inserts the portion of the string that follows the matched substring\n     *      $n  Where n is a positive integer less than 100, inserts the nth parenthesized sub-match string,\n     *          provided the first argument was a RegExp object\n     *\n     * So, if a replacement string containing dollar signs passes through a series of replace() calls, untold\n     * problems could result.  Hence, this function, which simply uses the replacement string as-is.\n     *\n     * Similar to the JavaScript replace() method (when sSearch is a string), this replaces only ONE occurrence\n     * (ie, the FIRST occurrence); it might be nice to add options to replace the LAST occurrence and/or ALL\n     * occurrences, but we'll revisit that later.\n     *\n     * @param {string} sSearch\n     * @param {string} sReplace\n     * @param {string} s\n     * @return {string}\n     */\n    static replace(sSearch, sReplace, s)\n    {\n        var i = s.indexOf(sSearch);\n        if (i >= 0) {\n            s = s.substr(0, i) + sReplace + s.substr(i + sSearch.length);\n        }\n        return s;\n    }\n\n    /**\n     * replaceAll(sSearch, sReplace, s)\n     *\n     * @param {string} sSearch\n     * @param {string} sReplace\n     * @param {string} s\n     * @return {string}\n     */\n    static replaceAll(sSearch, sReplace, s)\n    {\n        var a = {};\n        a[sSearch] = sReplace;\n        return Str.replaceArray(a, s);\n    }\n\n    /**\n     * replaceArray(a, s)\n     *\n     * @param {Object} a\n     * @param {string} s\n     * @return {string}\n     */\n    static replaceArray(a, s)\n    {\n        var sMatch = \"\";\n        for (var k in a) {\n            /*\n             * As noted in:\n             *\n             *      http://www.regexguru.com/2008/04/escape-characters-only-when-necessary/\n             *\n             * inside character classes, only backslash, caret, hyphen and the closing bracket need to be\n             * escaped.  And in fact, if you ensure that the closing bracket is first, the caret is not first,\n             * and the hyphen is last, you can avoid escaping those as well.\n             */\n            k = k.replace(/([\\\\[\\]*{}().+?|$])/g, \"\\\\$1\");\n            sMatch += (sMatch? '|' : '') + k;\n        }\n        return s.replace(new RegExp('(' + sMatch + ')', \"g\"), function(m)\n        {\n            return a[m];\n        });\n    }\n\n    /**\n     * pad(s, cch, fPadLeft)\n     *\n     * NOTE: the maximum amount of padding currently supported is 40 spaces.\n     *\n     * @param {string} s is a string\n     * @param {number} cch is desired length\n     * @param {boolean} [fPadLeft] (default is padding on the right)\n     * @return {string} the original string (s) with spaces padding it to the specified length\n     */\n    static pad(s, cch, fPadLeft)\n    {\n        var sPadding = \"                                        \";\n        return fPadLeft? (sPadding + s).slice(-cch) : (s + sPadding).slice(0, cch);\n    }\n\n    /**\n     * sprintf(format, ...args)\n     *\n     * Copied from the CCjs project (/ccjs/lib/stdio.js) and extended.  Far from complete let alone sprintf-compatible,\n     * but it's a start.\n     *\n     * @param {string} format\n     * @param {...} args\n     * @return {string}\n     */\n    static sprintf(format, ...args)\n    {\n        var parts = format.split(/%([-+ 0#]?)([0-9]*)(\\.?)([0-9]*)([hlL]?)([A-Za-z%])/);\n        var buffer = \"\";\n        var partIndex = 0;\n        for (var i = 0; i < args.length; i++) {\n\n            var arg = args[i], d, s;\n            buffer += parts[partIndex++];\n            var flags = parts[partIndex];\n            var minimum = +parts[partIndex+1] || 0;\n            var precision = +parts[partIndex+3] || 0;\n            var conversion = parts[partIndex+5];\n\n            switch(conversion) {\n            case 'd':\n            case 'f':\n                d = Math.trunc(arg);\n                s = d + \"\";\n                if (precision) {\n                    minimum -= (precision + 1);\n                }\n                if (s.length < minimum) {\n                    if (flags == '0') {\n                        if (d < 0) minimum--;\n                        s = (\"0000000000\" + Math.abs(d)).slice(-minimum);\n                        if (d < 0) s = '-' + s;\n                    } else {\n                        s = (\"          \" + s).slice(-minimum);\n                    }\n                }\n                if (precision) {\n                    d = Math.trunc((arg - Math.trunc(arg)) * Math.pow(10, precision));\n                    s += '.' + (\"0000000000\" + Math.abs(d)).slice(-precision);\n                }\n                buffer += s;\n                break;\n            case 's':\n                buffer += arg;\n                break;\n            default:\n                /*\n                 * The supported ANSI C set of conversions: \"dioxXucsfeEgGpn%\"\n                 */\n                buffer += \"(unrecognized printf conversion %\" + conversion + \")\";\n                break;\n            }\n\n            partIndex += 6;\n        }\n        buffer += parts[partIndex];\n        return buffer;\n    }\n\n    /**\n     * stripLeadingZeros(s, fPad)\n     *\n     * @param {string} s\n     * @param {boolean} [fPad]\n     * @return {string}\n     */\n    static stripLeadingZeros(s, fPad)\n    {\n        var cch = s.length;\n        s = s.replace(/^0+([0-9A-F]+)$/i, \"$1\");\n        if (fPad) s = Str.pad(s, cch, true);\n        return s;\n    }\n\n    /**\n     * trim(s)\n     *\n     * @param {string} s\n     * @return {string}\n     */\n    static trim(s)\n    {\n        if (String.prototype.trim) {\n            return s.trim();\n        }\n        return s.replace(/^\\s+|\\s+$/g, \"\");\n    }\n\n    /**\n     * toASCIICode(b)\n     *\n     * @param {number} b\n     * @return {string}\n     */\n    static toASCIICode(b)\n    {\n        var s;\n        if (b != Str.ASCII.CR && b != Str.ASCII.LF) {\n            s = Str.ASCIICodeMap[b];\n        }\n        if (s) {\n            s = '<' + s + '>';\n        } else {\n            s = String.fromCharCode(b);\n        }\n        return s;\n    }\n}\n\n/*\n * Map special characters to their HTML escape sequences.\n */\nStr.HTMLEscapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n};\n\n/*\n * Map \"unprintable\" ASCII codes to mnemonics, to more clearly see what's being printed.\n */\nStr.ASCIICodeMap = {\n    0x00:   \"NUL\",\n    0x01:   \"SOH\",      // (CTRL_A) Start of Heading\n    0x02:   \"STX\",      // (CTRL_B) Start of Text\n    0x03:   \"ETX\",      // (CTRL_C) End of Text\n    0x04:   \"EOT\",      // (CTRL_D) End of Transmission\n    0x05:   \"ENQ\",      // (CTRL_E) Enquiry\n    0x06:   \"ACK\",      // (CTRL_F) Acknowledge\n    0x07:   \"BEL\",      // (CTRL_G) Bell\n    0x08:   \"BS\",       // (CTRL_H) Backspace\n    0x09:   \"TAB\",      // (CTRL_I) Horizontal Tab (aka HT)\n    0x0A:   \"LF\",       // (CTRL_J) Line Feed (New Line)\n    0x0B:   \"VT\",       // (CTRL_K) Vertical Tab\n    0x0C:   \"FF\",       // (CTRL_L) Form Feed (New Page)\n    0x0D:   \"CR\",       // (CTRL_M) Carriage Return\n    0x0E:   \"SO\",       // (CTRL_N) Shift Out\n    0x0F:   \"SI\",       // (CTRL_O) Shift In\n    0x10:   \"DLE\",      // (CTRL_P) Data Link Escape\n    0x11:   \"XON\",      // (CTRL_Q) Device Control 1 (aka DC1)\n    0x12:   \"DC2\",      // (CTRL_R) Device Control 2\n    0x13:   \"XOFF\",     // (CTRL_S) Device Control 3 (aka DC3)\n    0x14:   \"DC4\",      // (CTRL_T) Device Control 4\n    0x15:   \"NAK\",      // (CTRL_U) Negative Acknowledge\n    0x16:   \"SYN\",      // (CTRL_V) Synchronous Idle\n    0x17:   \"ETB\",      // (CTRL_W) End of Transmission Block\n    0x18:   \"CAN\",      // (CTRL_X) Cancel\n    0x19:   \"EM\",       // (CTRL_Y) End of Medium\n    0x1A:   \"SUB\",      // (CTRL_Z) Substitute\n    0x1B:   \"ESC\",      // Escape\n    0x1C:   \"FS\",       // File Separator\n    0x1D:   \"GS\",       // Group Separator\n    0x1E:   \"RS\",       // Record Separator\n    0x1F:   \"US\",       // Unit Separator\n    0x7F:   \"DEL\"\n};\n\n/*\n * Refer to: https://en.wikipedia.org/wiki/Code_page_437\n */\nStr.CP437ToUnicode = [\n    '\\u0000', '\\u263A', '\\u263B', '\\u2665', '\\u2666', '\\u2663', '\\u2660', '\\u2022',\n    '\\u25D8', '\\u25CB', '\\u25D9', '\\u2642', '\\u2640', '\\u266A', '\\u266B', '\\u263C',\n    '\\u25BA', '\\u25C4', '\\u2195', '\\u203C', '\\u00B6', '\\u00A7', '\\u25AC', '\\u21A8',\n    '\\u2191', '\\u2193', '\\u2192', '\\u2190', '\\u221F', '\\u2194', '\\u25B2', '\\u25BC',\n    '\\u0020', '\\u0021', '\\u0022', '\\u0023', '\\u0024', '\\u0025', '\\u0026', '\\u0027',\n    '\\u0028', '\\u0029', '\\u002A', '\\u002B', '\\u002C', '\\u002D', '\\u002E', '\\u002F',\n    '\\u0030', '\\u0031', '\\u0032', '\\u0033', '\\u0034', '\\u0035', '\\u0036', '\\u0037',\n    '\\u0038', '\\u0039', '\\u003A', '\\u003B', '\\u003C', '\\u003D', '\\u003E', '\\u003F',\n    '\\u0040', '\\u0041', '\\u0042', '\\u0043', '\\u0044', '\\u0045', '\\u0046', '\\u0047',\n    '\\u0048', '\\u0049', '\\u004A', '\\u004B', '\\u004C', '\\u004D', '\\u004E', '\\u004F',\n    '\\u0050', '\\u0051', '\\u0052', '\\u0053', '\\u0054', '\\u0055', '\\u0056', '\\u0057',\n    '\\u0058', '\\u0059', '\\u005A', '\\u005B', '\\u005C', '\\u005D', '\\u005E', '\\u005F',\n    '\\u0060', '\\u0061', '\\u0062', '\\u0063', '\\u0064', '\\u0065', '\\u0066', '\\u0067',\n    '\\u0068', '\\u0069', '\\u006A', '\\u006B', '\\u006C', '\\u006D', '\\u006E', '\\u006F',\n    '\\u0070', '\\u0071', '\\u0072', '\\u0073', '\\u0074', '\\u0075', '\\u0076', '\\u0077',\n    '\\u0078', '\\u0079', '\\u007A', '\\u007B', '\\u007C', '\\u007D', '\\u007E', '\\u2302',\n    '\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4', '\\u00E0', '\\u00E5', '\\u00E7',\n    '\\u00EA', '\\u00EB', '\\u00E8', '\\u00EF', '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5',\n    '\\u00C9', '\\u00E6', '\\u00C6', '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9',\n    '\\u00FF', '\\u00D6', '\\u00DC', '\\u00A2', '\\u00A3', '\\u00A5', '\\u20A7', '\\u0192',\n    '\\u00E1', '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1', '\\u00AA', '\\u00BA',\n    '\\u00BF', '\\u2310', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB', '\\u00BB',\n    '\\u2591', '\\u2592', '\\u2593', '\\u2502', '\\u2524', '\\u2561', '\\u2562', '\\u2556',\n    '\\u2555', '\\u2563', '\\u2551', '\\u2557', '\\u255D', '\\u255C', '\\u255B', '\\u2510',\n    '\\u2514', '\\u2534', '\\u252C', '\\u251C', '\\u2500', '\\u253C', '\\u255E', '\\u255F',\n    '\\u255A', '\\u2554', '\\u2569', '\\u2566', '\\u2560', '\\u2550', '\\u256C', '\\u2567',\n    '\\u2568', '\\u2564', '\\u2565', '\\u2559', '\\u2558', '\\u2552', '\\u2553', '\\u256B',\n    '\\u256A', '\\u2518', '\\u250C', '\\u2588', '\\u2584', '\\u258C', '\\u2590', '\\u2580',\n    '\\u03B1', '\\u00DF', '\\u0393', '\\u03C0', '\\u03A3', '\\u03C3', '\\u00B5', '\\u03C4',\n    '\\u03A6', '\\u0398', '\\u03A9', '\\u03B4', '\\u221E', '\\u03C6', '\\u03B5', '\\u2229',\n    '\\u2261', '\\u00B1', '\\u2265', '\\u2264', '\\u2320', '\\u2321', '\\u00F7', '\\u2248',\n    '\\u00B0', '\\u2219', '\\u00B7', '\\u221A', '\\u207F', '\\u00B2', '\\u25A0', '\\u00A0'\n];\n\n/*\n * TODO: Future home of a complete ASCII table.\n */\nStr.ASCII = {\n    LF:     0x0A,\n    CR:     0x0D\n};\n\nStr.TYPES = {\n    NULL:       0,\n    BYTE:       1,\n    WORD:       2,\n    DWORD:      3,\n    NUMBER:     4,\n    STRING:     5,\n    BOOLEAN:    6,\n    OBJECT:     7,\n    ARRAY:      8\n};\n\n\n\n/**\n * @copyright http://pcjs.org/modules/shared/lib/usrlib.js (C) Jeff Parsons 2012-2017\n */\n\n/**\n * @typedef {{\n *  mask:       number,\n *  shift:      number\n * }}\n */\nvar BitField;\n\n/**\n * @typedef {Object.<BitField>}\n */\nvar BitFields;\n\nclass Usr {\n    /**\n     * binarySearch(a, v, fnCompare)\n     *\n     * @param {Array} a is an array\n     * @param {number|string|Array|Object} v\n     * @param {function((number|string|Array|Object), (number|string|Array|Object))} [fnCompare]\n     * @return {number} the index of matching entry if non-negative, otherwise the index of the insertion point\n     */\n    static binarySearch(a, v, fnCompare)\n    {\n        var left = 0;\n        var right = a.length;\n        var found = 0;\n        if (fnCompare === undefined) {\n            fnCompare = function(a, b)\n            {\n                return a > b ? 1 : a < b ? -1 : 0;\n            };\n        }\n        while (left < right) {\n            var middle = (left + right) >> 1;\n            var compareResult;\n            compareResult = fnCompare(v, a[middle]);\n            if (compareResult > 0) {\n                left = middle + 1;\n            } else {\n                right = middle;\n                found = !compareResult;\n            }\n        }\n        return found ? left : ~left;\n    }\n\n    /**\n     * binaryInsert(a, v, fnCompare)\n     *\n     * If element v already exists in array a, the array is unchanged (we don't allow duplicates); otherwise, the\n     * element is inserted into the array at the appropriate index.\n     *\n     * @param {Array} a is an array\n     * @param {number|string|Array|Object} v is the value to insert\n     * @param {function((number|string|Array|Object), (number|string|Array|Object))} [fnCompare]\n     */\n    static binaryInsert(a, v, fnCompare)\n    {\n        var index = Usr.binarySearch(a, v, fnCompare);\n        if (index < 0) {\n            a.splice(-(index + 1), 0, v);\n        }\n    }\n\n    /**\n     * getTimestamp()\n     *\n     * @return {string} timestamp containing the current date and time (\"yyyy-mm-dd hh:mm:ss\")\n     */\n    static getTimestamp()\n    {\n        return Usr.formatDate(\"Y-m-d H:i:s\");\n    }\n\n    /**\n     * getMonthDays(nMonth, nYear)\n     *\n     * Note that if we're being called on behalf of the RTC, its year is always truncated to two digits (mod 100),\n     * so we have no idea what century the year 0 might refer to.  When using the normal leap-year formula, 0 fails\n     * the mod 100 test but passes the mod 400 test, so as far as the RTC is concerned, every century year is a leap\n     * year.  Since we're most likely dealing with the year 2000, that's fine, since 2000 was also a leap year.\n     *\n     * TODO: There IS a separate CMOS byte that's supposed to be set to CMOS_ADDR.CENTURY_DATE; it's always BCD,\n     * so theoretically it will contain values like 0x19 or 0x20 (for the 20th and 21st centuries, respectively), and\n     * we could add that as another parameter to this function, to improve the accuracy, but that would go beyond what\n     * a real RTC actually does.\n     *\n     * @param {number} nMonth (1-12)\n     * @param {number} nYear (normally a 4-digit year, but it may also be mod 100)\n     * @return {number} the maximum (1-based) day allowed for the specified month and year\n     */\n    static getMonthDays(nMonth, nYear)\n    {\n        var nDays = Usr.aMonthDays[nMonth - 1];\n        if (nDays == 28) {\n            if ((nYear % 4) === 0 && ((nYear % 100) || (nYear % 400) === 0)) {\n                nDays++;\n            }\n        }\n        return nDays;\n    }\n\n    /**\n     * formatDate(sFormat, date)\n     *\n     * @param {string} sFormat (eg, \"F j, Y\", \"Y-m-d H:i:s\")\n     * @param {Date} [date] (default is the current time)\n     * @return {string}\n     *\n     * Supported identifiers in sFormat include:\n     *\n     *      a:  lowercase ante meridiem and post meridiem (am or pm)\n     *      d:  day of the month, 2 digits with leading zeros (01,02,...,31)\n     *      D:  3-letter day of the week (\"Sun\",\"Mon\",...,\"Sat\")\n     *      F:  month (\"January\",\"February\",...,\"December\")\n     *      g:  hour in 12-hour format, without leading zeros (1,2,...,12)\n     *      h:  hour in 24-hour format, without leading zeros (0,1,...,23)\n     *      H:  hour in 24-hour format, with leading zeros (00,01,...,23)\n     *      i:  minutes, with leading zeros (00,01,...,59)\n     *      j:  day of the month, without leading zeros (1,2,...,31)\n     *      l:  day of the week (\"Sunday\",\"Monday\",...,\"Saturday\")\n     *      m:  month, with leading zeros (01,02,...,12)\n     *      M:  3-letter month (\"Jan\",\"Feb\",...,\"Dec\")\n     *      n:  month, without leading zeros (1,2,...,12)\n     *      s:  seconds, with leading zeros (00,01,...,59)\n     *      y:  2-digit year (eg, 14)\n     *      Y:  4-digit year (eg, 2014)\n     *\n     * For more inspiration, see: http://php.net/manual/en/function.date.php (of which we support ONLY a subset).\n     */\n    static formatDate(sFormat, date)\n    {\n        var sDate = \"\";\n        if (!date) date = new Date();\n        var iHour = date.getHours();\n        var iDay = date.getDate();\n        var iMonth = date.getMonth() + 1;\n        for (var i = 0; i < sFormat.length; i++) {\n            var ch;\n            switch ((ch = sFormat.charAt(i))) {\n            case 'a':\n                sDate += (iHour < 12 ? \"am\" : \"pm\");\n                break;\n            case 'd':\n                sDate += ('0' + iDay).slice(-2);\n                break;\n            case 'D':\n                sDate += Usr.asDays[date.getDay()].substr(0, 3);\n                break;\n            case 'F':\n                sDate += Usr.asMonths[iMonth - 1];\n                break;\n            case 'g':\n                sDate += (!iHour ? 12 : (iHour > 12 ? iHour - 12 : iHour));\n                break;\n            case 'h':\n                sDate += iHour;\n                break;\n            case 'H':\n                sDate += ('0' + iHour).slice(-2);\n                break;\n            case 'i':\n                sDate += ('0' + date.getMinutes()).slice(-2);\n                break;\n            case 'j':\n                sDate += iDay;\n                break;\n            case 'l':\n                sDate += Usr.asDays[date.getDay()];\n                break;\n            case 'm':\n                sDate += ('0' + iMonth).slice(-2);\n                break;\n            case 'M':\n                sDate += Usr.asMonths[iMonth - 1].substr(0, 3);\n                break;\n            case 'n':\n                sDate += iMonth;\n                break;\n            case 's':\n                sDate += ('0' + date.getSeconds()).slice(-2);\n                break;\n            case 'y':\n                sDate += (\"\" + date.getFullYear()).slice(-2);\n                break;\n            case 'Y':\n                sDate += date.getFullYear();\n                break;\n            default:\n                sDate += ch;\n                break;\n            }\n        }\n        return sDate;\n    }\n\n    /**\n     * defineBitFields(bfs)\n     *\n     * Prepares a bit field definition for use with getBitField() and setBitField(); eg:\n     *\n     *      var bfs = Usr.defineBitFields({num:20, count:8, btmod:1, type:3});\n     *\n     * The above defines a set of bit fields containing four fields: num (bits 0-19), count (bits 20-27), btmod (bit 28), and type (bits 29-31).\n     *\n     *      Usr.setBitField(bfs.num, n, 1);\n     *\n     * The above set bit field \"bfs.num\" in numeric variable \"n\" to the value 1.\n     *\n     * @param {Object} bfs\n     * @return {BitFields}\n     */\n    static defineBitFields(bfs)\n    {\n        var bit = 0;\n        for (var f in bfs) {\n            var width = bfs[f];\n            var mask = ((1 << width) - 1) << bit;\n            bfs[f] = {mask: mask, shift: bit};\n            bit += width;\n        }\n        return bfs;\n    }\n\n    /**\n     * initBitFields(bfs, ...)\n     *\n     * @param {BitFields} bfs\n     * @param {...number} var_args\n     * @return {number} a value containing all supplied bit fields\n     */\n    static initBitFields(bfs, var_args)\n    {\n        var v = 0, i = 1;\n        for (var f in bfs) {\n            if (i >= arguments.length) break;\n            v = Usr.setBitField(bfs[f], v, arguments[i++]);\n        }\n        return v;\n    }\n\n    /**\n     * getBitField(bf, v)\n     *\n     * @param {BitField} bf\n     * @param {number} v is a value containing bit fields\n     * @return {number} the value of the bit field in v defined by bf\n     */\n    static getBitField(bf, v)\n    {\n        return (v & bf.mask) >> bf.shift;\n    }\n\n    /**\n     * setBitField(bf, v, n)\n     *\n     * @param {BitField} bf\n     * @param {number} v is a value containing bit fields\n     * @param {number} n is a value to store in v in the bit field defined by bf\n     * @return {number} updated v\n     */\n    static setBitField(bf, v, n)\n    {\n        return (v & ~bf.mask) | ((n << bf.shift) & bf.mask);\n    }\n\n    /**\n     * indexOf(a, t, i)\n     *\n     * Use this instead of Array.prototype.indexOf() if you can't be sure the browser supports it.\n     *\n     * @param {Array} a\n     * @param {*} t\n     * @param {number} [i]\n     * @returns {number}\n     */\n    static indexOf(a, t, i)\n    {\n        if (Array.prototype.indexOf) {\n            return a.indexOf(t, i);\n        }\n        i = i || 0;\n        if (i < 0) i += a.length;\n        if (i < 0) i = 0;\n        for (var n = a.length; i < n; i++) {\n            if (i in a && a[i] === t) return i;\n        }\n        return -1;\n    }\n}\n\nUsr.asDays = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\nUsr.asMonths = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\nUsr.aMonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n/**\n * getTime()\n *\n * @return {number} the current time, in milliseconds\n */\nUsr.getTime = Date.now || function() { return +new Date(); };\n\n\n\n/**\n * @copyright http://pcjs.org/modules/shared/lib/weblib.js (C) Jeff Parsons 2012-2017\n */\n\n\n/*\n * According to http://www.w3schools.com/jsref/jsref_obj_global.asp, these are the *global* properties\n * and functions of JavaScript-in-the-Browser:\n *\n * Property             Description\n * ---\n * Infinity             A numeric value that represents positive/negative infinity\n * NaN                  \"Not-a-Number\" value\n * undefined            Indicates that a variable has not been assigned a value\n *\n * Function             Description\n * ---\n * decodeURI()          Decodes a URI\n * decodeURIComponent() Decodes a URI component\n * encodeURI()          Encodes a URI\n * encodeURIComponent() Encodes a URI component\n * escape()             Deprecated in version 1.5. Use encodeURI() or encodeURIComponent() instead\n * eval()               Evaluates a string and executes it as if it was script code\n * isFinite()           Determines whether a value is a finite, legal number\n * isNaN()              Determines whether a value is an illegal number\n * Number()             Converts an object's value to a number\n * parseFloat()         Parses a string and returns a floating point number\n * parseInt()           Parses a string and returns an integer\n * String()             Converts an object's value to a string\n * unescape()           Deprecated in version 1.5. Use decodeURI() or decodeURIComponent() instead\n *\n * And according to http://www.w3schools.com/jsref/obj_window.asp, these are the properties and functions\n * of the *window* object.\n *\n * Property             Description\n * ---\n * closed               Returns a Boolean value indicating whether a window has been closed or not\n * defaultStatus        Sets or returns the default text in the statusbar of a window\n * document             Returns the Document object for the window (See Document object)\n * frames               Returns an array of all the frames (including iframes) in the current window\n * history              Returns the History object for the window (See History object)\n * innerHeight          Returns the inner height of a window's content area\n * innerWidth           Returns the inner width of a window's content area\n * length               Returns the number of frames (including iframes) in a window\n * location             Returns the Location object for the window (See Location object)\n * name                 Sets or returns the name of a window\n * navigator            Returns the Navigator object for the window (See Navigator object)\n * opener               Returns a reference to the window that created the window\n * outerHeight          Returns the outer height of a window, including toolbars/scrollbars\n * outerWidth           Returns the outer width of a window, including toolbars/scrollbars\n * pageXOffset          Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window\n * pageYOffset          Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window\n * parent               Returns the parent window of the current window\n * screen               Returns the Screen object for the window (See Screen object)\n * screenLeft           Returns the x coordinate of the window relative to the screen\n * screenTop            Returns the y coordinate of the window relative to the screen\n * screenX              Returns the x coordinate of the window relative to the screen\n * screenY              Returns the y coordinate of the window relative to the screen\n * self                 Returns the current window\n * status               Sets or returns the text in the statusbar of a window\n * top                  Returns the topmost browser window\n *\n * Method               Description\n * ---\n * alert()              Displays an alert box with a message and an OK button\n * atob()               Decodes a base-64 encoded string\n * blur()               Removes focus from the current window\n * btoa()               Encodes a string in base-64\n * clearInterval()      Clears a timer set with setInterval()\n * clearTimeout()       Clears a timer set with setTimeout()\n * close()              Closes the current window\n * confirm()            Displays a dialog box with a message and an OK and a Cancel button\n * createPopup()        Creates a pop-up window\n * focus()              Sets focus to the current window\n * moveBy()             Moves a window relative to its current position\n * moveTo()             Moves a window to the specified position\n * open()               Opens a new browser window\n * print()              Prints the content of the current window\n * prompt()             Displays a dialog box that prompts the visitor for input\n * resizeBy()           Resizes the window by the specified pixels\n * resizeTo()           Resizes the window to the specified width and height\n * scroll()             This method has been replaced by the scrollTo() method.\n * scrollBy()           Scrolls the content by the specified number of pixels\n * scrollTo()           Scrolls the content to the specified coordinates\n * setInterval()        Calls a function or evaluates an expression at specified intervals (in milliseconds)\n * setTimeout()         Calls a function or evaluates an expression after a specified number of milliseconds\n * stop()               Stops the window from loading\n */\n\nclass Web {\n    /**\n     * log(s, type)\n     *\n     * For diagnostic output only.  DEBUG must be true (or \"--debug\" specified via the command-line)\n     * for Component.log() to display anything.\n     *\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     */\n    static log(s, type)\n    {\n        Component.log(s, type);\n    }\n\n    /**\n     * notice(s, fPrintOnly, id)\n     *\n     * @param {string} s is the message text\n     * @param {boolean} [fPrintOnly]\n     * @param {string} [id] is the caller's ID, if any\n     */\n    static notice(s, fPrintOnly, id)\n    {\n        Component.notice(s, fPrintOnly, id);\n    }\n\n    /**\n     * getResource(sURL, dataPost, fAsync, done, progress)\n     *\n     * Request the specified resource (sURL), and once the request is complete, notify done().\n     *\n     * If fAsync is true, a done() callback should ALWAYS be supplied; otherwise, you'll have no\n     * idea when the request is complete or what the response was.  done() is passed three parameters:\n     *\n     *      done(sURL, sResource, nErrorCode)\n     *\n     * If nErrorCode is zero, sResource should contain the requested data; otherwise, an error occurred.\n     *\n     * If dataPost is set to a string, that string can be used to control the response format;\n     * by default, the response format is plain text, but you can specify \"bytes\" to request arbitrary\n     * binary data, which should come back as a string of bytes.\n     *\n     * TODO: The \"bytes\" option works by calling overrideMimeType(), which was never a best practice.\n     * Instead, we should implement supported response types (\"text\" and \"arraybuffer\", at a minimum)\n     * by setting xmlHTTP.responseType to one of those values before calling xmlHTTP.send().\n     *\n     * @param {string} sURL\n     * @param {string|Object|null} [dataPost] for a POST request (default is a GET request)\n     * @param {boolean} [fAsync] is true for an asynchronous request\n     * @param {function(string,string,number)} [done]\n     * @param {function(number)} [progress]\n     * @return {Array|null} Array containing [sResource, nErrorCode], or null if no response yet\n     */\n    static getResource(sURL, dataPost, fAsync = false, done, progress)\n    {\n        var nErrorCode = 0, sResource = null, response = null;\n\n        if (typeof resources == 'object' && (sResource = resources[sURL])) {\n            if (done) done(sURL, sResource, nErrorCode);\n            return [sResource, nErrorCode];\n        }\n        else if (fAsync && typeof resources == 'function') {\n            resources(sURL, function(sResource, nErrorCode)\n            {\n                if (done) done(sURL, sResource, nErrorCode);\n            });\n            return response;\n        }\n\n        if (DEBUG) {\n            /*\n             * The larger resources we put on archive.pcjs.org should also be available locally.\n             *\n             * NOTE: \"http://archive.pcjs.org\" is now \"https://s3-us-west-2.amazonaws.com/archive.pcjs.org\"\n             */\n            sURL = sURL.replace(/^(http:\\/\\/archive\\.pcjs\\.org|https:\\/\\/s3-us-west-2\\.amazonaws\\.com\\/archive\\.pcjs\\.org)(\\/.*)\\/([^\\/]*)$/, \"$2/archive/$3\");\n        }\n\n\n        var xmlHTTP = (window.XMLHttpRequest? new window.XMLHttpRequest() : new window.ActiveXObject(\"Microsoft.XMLHTTP\"));\n        if (fAsync) {\n            xmlHTTP.onreadystatechange = function()\n            {\n                if (xmlHTTP.readyState !== 4) {\n                    if (progress) progress(1);\n                    return;\n                }\n                /*\n                 * The following line was recommended for WebKit, as a work-around to prevent the handler firing multiple\n                 * times when debugging.  Unfortunately, that's not the only XMLHttpRequest problem that occurs when\n                 * debugging, so I think the WebKit problem is deeper than that.  When we have multiple XMLHttpRequests\n                 * pending, any debugging activity means most of them simply get dropped on floor, so what may actually be\n                 * happening are mis-notifications rather than redundant notifications.\n                 *\n                 *      xmlHTTP.onreadystatechange = undefined;\n                 */\n                sResource = xmlHTTP.responseText;\n                /*\n                 * The normal \"success\" case is an HTTP status code of 200, but when testing with files loaded\n                 * from the local file system (ie, when using the \"file:\" protocol), we have to be a bit more \"flexible\".\n                 */\n                if (xmlHTTP.status == 200 || !xmlHTTP.status && sResource.length && Web.getHostProtocol() == \"file:\") {\n                    if (MAXDEBUG) Web.log(\"xmlHTTP.onreadystatechange(\" + sURL + \"): returned \" + sResource.length + \" bytes\");\n                }\n                else {\n                    nErrorCode = xmlHTTP.status || -1;\n                    Web.log(\"xmlHTTP.onreadystatechange(\" + sURL + \"): error code \" + nErrorCode);\n                }\n                if (progress) progress(2);\n                if (done) done(sURL, sResource, nErrorCode);\n            };\n        }\n\n        if (progress) progress(0);\n\n        if (dataPost && typeof dataPost == \"object\") {\n            var sDataPost = \"\";\n            for (var p in dataPost) {\n                if (!dataPost.hasOwnProperty(p)) continue;\n                if (sDataPost) sDataPost += \"&\";\n                sDataPost += p + '=' + encodeURIComponent(dataPost[p]);\n            }\n            sDataPost = sDataPost.replace(/%20/g, '+');\n            if (MAXDEBUG) Web.log(\"Web.getResource(POST \" + sURL + \"): \" + sDataPost.length + \" bytes\");\n            xmlHTTP.open(\"POST\", sURL, fAsync);     // ensure that fAsync is a valid boolean (Internet Explorer xmlHTTP functions insist on it)\n            xmlHTTP.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n            xmlHTTP.send(sDataPost);\n        } else {\n            if (MAXDEBUG) Web.log(\"Web.getResource(GET \" + sURL + \")\");\n            xmlHTTP.open(\"GET\", sURL, fAsync);      // ensure that fAsync is a valid boolean (Internet Explorer xmlHTTP functions insist on it)\n            if (dataPost == \"bytes\") {\n                xmlHTTP.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n            xmlHTTP.send();\n        }\n\n        if (!fAsync) {\n            sResource = xmlHTTP.responseText;\n            if (xmlHTTP.status == 200) {\n                if (MAXDEBUG) Web.log(\"Web.getResource(\" + sURL + \"): returned \" + sResource.length + \" bytes\");\n            } else {\n                nErrorCode = xmlHTTP.status || -1;\n                Web.log(\"Web.getResource(\" + sURL + \"): error code \" + nErrorCode);\n            }\n            if (done) done(sURL, sResource, nErrorCode);\n            response = [sResource, nErrorCode];\n        }\n        return response;\n    }\n\n    /**\n     * parseMemoryResource(sURL, sData)\n     *\n     * This converts a variety of JSON-style data streams into an Object with the following properties:\n     *\n     *      aBytes\n     *      aSymbols\n     *      addrLoad\n     *      addrExec\n     *\n     * If the source data contains a 'bytes' array, it's passed through to 'aBytes'; alternatively, if\n     * it contains a 'words' array, the values are converted from 16-bit to 8-bit and stored in 'aBytes',\n     * and if it contains a 'longs' array, the values are converted from 32-bit longs into bytes and\n     * stored in 'aBytes'.\n     *\n     * Alternatively, if the source data contains a 'data' array, we simply pass that through to the output\n     * object as:\n     *\n     *      aData\n     *\n     * @param {string} sURL\n     * @param {string} sData\n     * @return {Object|null} (resource)\n     */\n    static parseMemoryResource(sURL, sData)\n    {\n        var i;\n        var resource = {\n            aBytes: null,\n            aSymbols: null,\n            addrLoad: null,\n            addrExec: null\n        };\n\n        if (sData.charAt(0) == \"[\" || sData.charAt(0) == \"{\") {\n            try {\n                var a, ib, data;\n\n                if (sData.substr(0, 1) == \"<\") {    // if the \"data\" begins with a \"<\"...\n                    /*\n                     * Early server configs reported an error (via the nErrorCode parameter) if a tape URL was invalid,\n                     * but more recent server configs now display a somewhat friendlier HTML error page.  The downside,\n                     * however, is that the original error has been buried, and we've received \"data\" that isn't actually\n                     * tape data.  So if the data we've received appears to be \"HTML-like\", we treat it as an error message.\n                     */\n                    throw new Error(sData);\n                }\n\n                /*\n                 * TODO: IE9 is rather unfriendly and restrictive with regard to how much data it's willing to\n                 * eval().  In particular, the 10Mb disk image we use for the Windows 1.01 demo config fails in\n                 * IE9 with an \"Out of memory\" exception.  One work-around would be to chop the data into chunks\n                 * (perhaps one track per chunk, using regular expressions) and then manually re-assemble it.\n                 *\n                 * However, it turns out that using JSON.parse(sDiskData) instead of eval(\"(\" + sDiskData + \")\")\n                 * is a much easier fix. The only drawback is that we must first quote any unquoted property names\n                 * and remove any comments, because while eval() was cool with them, JSON.parse() is more particular;\n                 * the following RegExp replacements take care of those requirements.\n                 *\n                 * The use of hex values is something else that eval() was OK with, but JSON.parse() is not, and\n                 * while I've stopped using hex values in DumpAPI responses (at least when \"format=json\" is specified),\n                 * I can't guarantee they won't show up in \"legacy\" images, and there's no simple RegExp replacement\n                 * for transforming hex values into decimal values, so I cop out and fall back to eval() if I detect\n                 * any hex prefixes (\"0x\") in the sequence.  Ditto for error messages, which appear like so:\n                 *\n                 *      [\"unrecognized disk path: test.img\"]\n                 */\n                if (sData.indexOf(\"0x\") < 0 && sData.indexOf(\"0o\") < 0 && sData.substr(0, 2) != '[\"') {\n                    data = JSON.parse(sData.replace(/([a-z]+):/gm, '\"$1\":').replace(/\\/\\/[^\\n]*/gm, \"\"));\n                } else {\n                    data = eval(\"(\" + sData + \")\");\n                }\n\n                resource.addrLoad = data['load'];\n                resource.addrExec = data['exec'];\n\n                if (a = data['bytes']) {\n                    resource.aBytes = a;\n                }\n                else if (a = data['words']) {\n                    /*\n                     * Convert all words into bytes\n                     */\n                    resource.aBytes = new Array(a.length * 2);\n                    for (i = 0, ib = 0; i < a.length; i++) {\n                        resource.aBytes[ib++] = a[i] & 0xff;\n                        resource.aBytes[ib++] = (a[i] >> 8) & 0xff;\n\n                    }\n                }\n                else if (a = data['longs']) {\n                    /*\n                     * Convert all dwords (longs) into bytes\n                     */\n                    resource.aBytes = new Array(a.length * 4);\n                    for (i = 0, ib = 0; i < a.length; i++) {\n                        resource.aBytes[ib++] = a[i] & 0xff;\n                        resource.aBytes[ib++] = (a[i] >> 8) & 0xff;\n                        resource.aBytes[ib++] = (a[i] >> 16) & 0xff;\n                        resource.aBytes[ib++] = (a[i] >> 24) & 0xff;\n                    }\n                }\n                else if (a = data['data']) {\n                    resource.aData = a;\n                }\n                else {\n                    resource.aBytes = data;\n                }\n\n                if (resource.aBytes) {\n                    if (!resource.aBytes.length) {\n                        Component.error(\"Empty resource: \" + sURL);\n                        resource = null;\n                    }\n                    else if (resource.aBytes.length == 1) {\n                        Component.error(resource.aBytes[0]);\n                        resource = null;\n                    }\n                }\n                resource.aSymbols = data['symbols'];\n\n            } catch (e) {\n                Component.error(\"Resource data error (\" + sURL + \"): \" + e.message);\n                resource = null;\n            }\n        }\n        else {\n            /*\n             * Parse the data manually; we assume it's a series of hex byte-values separated by whitespace.\n             */\n            var ab = [];\n            var sHexData = sData.replace(/\\n/gm, \" \").replace(/ +$/, \"\");\n            var asHexData = sHexData.split(\" \");\n            for (i = 0; i < asHexData.length; i++) {\n                var n = parseInt(asHexData[i], 16);\n                if (isNaN(n)) {\n                    Component.error(\"Resource data error (\" + sURL + \"): invalid hex byte (\" + asHexData[i] + \")\");\n                    break;\n                }\n                ab.push(n & 0xff);\n            }\n            if (i == asHexData.length) resource.aBytes = ab;\n        }\n        return resource;\n    }\n\n    /**\n     * sendReport(sApp, sVer, sURL, sUser, sType, sReport, sHostName)\n     *\n     * Send a report (eg, bug report) to the server.\n     *\n     * @param {string} sApp (eg, \"PCjs\")\n     * @param {string} sVer (eg, \"1.02\")\n     * @param {string} sURL (eg, \"/devices/pc/machine/5150/mda/64kb/machine.xml\")\n     * @param {string} sUser (ie, the user key, if any)\n     * @param {string} sType (eg, \"bug\"); one of ReportAPI.TYPE.*\n     * @param {string} sReport (eg, unparsed state data)\n     * @param {string} [sHostName] (default is http://SITEHOST)\n     */\n    static sendReport(sApp, sVer, sURL, sUser, sType, sReport, sHostName)\n    {\n        var dataPost = {};\n        dataPost[ReportAPI.QUERY.APP] = sApp;\n        dataPost[ReportAPI.QUERY.VER] = sVer;\n        dataPost[ReportAPI.QUERY.URL] = sURL;\n        dataPost[ReportAPI.QUERY.USER] = sUser;\n        dataPost[ReportAPI.QUERY.TYPE] = sType;\n        dataPost[ReportAPI.QUERY.DATA] = sReport;\n        var sReportURL = (sHostName? sHostName : \"http://\" + SITEHOST) + ReportAPI.ENDPOINT;\n        Web.getResource(sReportURL, dataPost, true);\n    }\n\n    /**\n     * getHost()\n     *\n     * @return {string}\n     */\n    static getHost()\n    {\n        return (\"http://\" + (window? window.location.host : SITEHOST));\n    }\n\n    /**\n     * getHostURL()\n     *\n     * @return {string|null}\n     */\n    static getHostURL()\n    {\n        return (window? window.location.href : null);\n    }\n\n    /**\n     * getHostProtocol()\n     *\n     * @return {string}\n     */\n    static getHostProtocol()\n    {\n        return (window? window.location.protocol : \"file:\");\n    }\n\n    /**\n     * getUserAgent()\n     *\n     * @return {string}\n     */\n    static getUserAgent()\n    {\n        return (window? window.navigator.userAgent : \"\");\n    }\n\n    /**\n     * hasLocalStorage\n     *\n     * true if localStorage support exists, is enabled, and works; false otherwise\n     *\n     * @return {boolean}\n     */\n    static hasLocalStorage()\n    {\n        if (Web.fLocalStorage == null) {\n            var f = false;\n            if (window) {\n                try {\n                    window.localStorage.setItem(Web.sLocalStorageTest, Web.sLocalStorageTest);\n                    f = (window.localStorage.getItem(Web.sLocalStorageTest) == Web.sLocalStorageTest);\n                    window.localStorage.removeItem(Web.sLocalStorageTest);\n                } catch (e) {\n                    Web.logLocalStorageError(e);\n                    f = false;\n                }\n            }\n            Web.fLocalStorage = f;\n        }\n        return Web.fLocalStorage;\n    }\n\n    /**\n     * logLocalStorageError(e)\n     *\n     * @param {Error} e is an exception\n     */\n    static logLocalStorageError(e)\n    {\n        Web.log(e.message, \"localStorage error\");\n    }\n\n    /**\n     * getLocalStorageItem(sKey)\n     *\n     * Returns the requested key value, or null if the key does not exist, or undefined if localStorage is not available\n     *\n     * @param {string} sKey\n     * @return {string|null|undefined} sValue\n     */\n    static getLocalStorageItem(sKey)\n    {\n        var sValue;\n        if (window) {\n            try {\n                sValue = window.localStorage.getItem(sKey);\n            } catch (e) {\n                Web.logLocalStorageError(e);\n            }\n        }\n        return sValue;\n    }\n\n    /**\n     * setLocalStorageItem(sKey, sValue)\n     *\n     * @param {string} sKey\n     * @param {string} sValue\n     * @return {boolean} true if localStorage is available, false if not\n     */\n    static setLocalStorageItem(sKey, sValue)\n    {\n        try {\n            window.localStorage.setItem(sKey, sValue);\n            return true;\n        } catch (e) {\n            Web.logLocalStorageError(e);\n        }\n        return false;\n    }\n\n    /**\n     * removeLocalStorageItem(sKey)\n     *\n     * @param {string} sKey\n     */\n    static removeLocalStorageItem(sKey)\n    {\n        try {\n            window.localStorage.removeItem(sKey);\n        } catch (e) {\n            Web.logLocalStorageError(e);\n        }\n    }\n\n    /**\n     * getLocalStorageKeys()\n     *\n     * @return {Array}\n     */\n    static getLocalStorageKeys()\n    {\n        var a = [];\n        try {\n            for (var i = 0, c = window.localStorage.length; i < c; i++) {\n                a.push(window.localStorage.key(i));\n            }\n        } catch (e) {\n            Web.logLocalStorageError(e);\n        }\n        return a;\n    }\n\n    /**\n     * reloadPage()\n     */\n    static reloadPage()\n    {\n        if (window) window.location.reload();\n    }\n\n    /**\n     * isUserAgent(s)\n     *\n     * Check the browser's user-agent string for the given substring; \"iOS\" and \"MSIE\" are special values you can\n     * use that will match any iOS or MSIE browser, respectively (even IE11, in the case of \"MSIE\").\n     *\n     * 2013-11-06: In a questionable move, MSFT changed the user-agent reported by IE11 on Windows 8.1, eliminating\n     * the \"MSIE\" string (which MSDN calls a \"version token\"; see http://msdn.microsoft.com/library/ms537503.aspx);\n     * they say \"public websites should rely on feature detection, rather than browser detection, in order to design\n     * their sites for browsers that don't support the features used by the website.\" So, in IE11, we get a user-agent\n     * that tries to fool apps into thinking the browser is more like WebKit or Gecko:\n     *\n     *      Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\n     *\n     * That's a nice idea, but in the meantime, they hosed the XSL transform code in embed.js, which contained\n     * some very critical browser-specific code; turning on IE's \"Compatibility Mode\" didn't help either, because\n     * that's a sledgehammer solution which restores the old user-agent string but also disables other features like\n     * HTML5 canvas support. As an interim solution, I'm treating any \"MSIE\" check as a check for either \"MSIE\" or\n     * \"Trident\".\n     *\n     * UPDATE: I've since found ways to make the code in embed.js more browser-agnostic, so for now, there's isn't\n     * any code that cares about \"MSIE\", but I've left the change in place, because I wouldn't be surprised if I'll\n     * need more IE-specific code in the future, perhaps for things like copy/paste functionality, or mouse capture.\n     *\n     * @param {string} s is a substring to search for in the user-agent; as noted above, \"iOS\" and \"MSIE\" are special values\n     * @return {boolean} is true if the string was found, false if not\n     */\n    static isUserAgent(s)\n    {\n        if (window) {\n            var userAgent = Web.getUserAgent();\n            /*\n             * Here's one case where we have to be careful with Component, because when isUserAgent() is called by\n             * the init code below, component.js hasn't been loaded yet.  The simple solution for now is to remove the call.\n             *\n             *      Web.log(\"agent: \" + userAgent);\n             *\n             * And yes, it would be pointless to use the conditional (?) operator below, if not for the Google Closure\n             * Compiler (v20130823) failing to detect the entire expression as a boolean.\n             */\n            return s == \"iOS\" && !!userAgent.match(/(iPod|iPhone|iPad)/) && !!userAgent.match(/AppleWebKit/) || s == \"MSIE\" && !!userAgent.match(/(MSIE|Trident)/) || (userAgent.indexOf(s) >= 0);\n        }\n        return false;\n    }\n\n    /**\n     * isMobile()\n     *\n     * Check the browser's user-agent string for the substring \"Mobi\", as per Mozilla recommendation:\n     *\n     *      https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent\n     *\n     * @return {boolean} is true if the browser appears to be a mobile (ie, non-desktop) web browser, false if not\n     */\n    static isMobile()\n    {\n        return Web.isUserAgent(\"Mobi\");\n    }\n\n    /**\n     * findProperty(obj, sProp, sSuffix)\n     *\n     * If both sProp and sSuffix are set, then any browser-specific prefixes are inserted between sProp and sSuffix,\n     * and if a match is found, it is returned without sProp.\n     *\n     * For example, if findProperty(document, 'on', 'fullscreenchange') discovers that 'onwebkitfullscreenchange' exists,\n     * it will return 'webkitfullscreenchange', in preparation for an addEventListener() call.\n     *\n     * More commonly, sSuffix is not used, so whatever property is found is returned as-is.\n     *\n     * @param {Object|null|undefined} obj\n     * @param {string} sProp\n     * @param {string} [sSuffix]\n     * @return {string|null}\n     */\n    static findProperty(obj, sProp, sSuffix)\n    {\n        if (obj) {\n            for (var i = 0; i < Web.asBrowserPrefixes.length; i++) {\n                var sName = Web.asBrowserPrefixes[i];\n                if (sSuffix) {\n                    sName += sSuffix;\n                    var sEvent = sProp + sName;\n                    if (sEvent in obj) return sName;\n                } else {\n                    if (!sName) {\n                        sName = sProp[0];\n                    } else {\n                        sName += sProp[0].toUpperCase();\n                    }\n                    sName += sProp.substr(1);\n                    if (sName in obj) return sName;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * getURLParm(sParm)\n     *\n     * First looks for sParm exactly as specified, then looks for the lower-case version.\n     *\n     * @param {string} sParm\n     * @return {string|undefined}\n     */\n    static getURLParm(sParm)\n    {\n        if (!Web.parmsURL) {\n            Web.parmsURL = Web.parseURLParms();\n        }\n        return Web.parmsURL[sParm] || Web.parmsURL[sParm.toLowerCase()];\n    }\n\n    /**\n     * parseURLParms(sParms)\n     *\n     * @param {string} [sParms] containing the parameter portion of a URL (ie, after the '?')\n     * @return {Object} containing properties for each parameter found\n     */\n    static parseURLParms(sParms)\n    {\n        var aParms = {};\n        if (window) {       // an alternative to \"if (typeof module === 'undefined')\" if require(\"defines\") was used\n            if (!sParms) {\n                /*\n                 * Note that window.location.href returns the entire URL, whereas window.location.search\n                 * returns only the parameters, if any (starting with the '?', which we skip over with a substr() call).\n                 */\n                sParms = window.location.search.substr(1);\n            }\n            var match;\n            var pl = /\\+/g; // RegExp for replacing addition symbol with a space\n            var search = /([^&=]+)=?([^&]*)/g;\n            var decode = function(s)\n            {\n                return decodeURIComponent(s.replace(pl, \" \"));\n            };\n\n            while ((match = search.exec(sParms))) {\n                aParms[decode(match[1])] = decode(match[2]);\n            }\n        }\n        return aParms;\n    }\n\n    /**\n     * downloadFile(sData, sType, fBase64, sFileName)\n     *\n     * @param {string} sData\n     * @param {string} sType\n     * @param {boolean} [fBase64]\n     * @param {string} [sFileName]\n     */\n    static downloadFile(sData, sType, fBase64, sFileName)\n    {\n        var link = null, sAlert;\n        var sURI = \"data:application/\" + sType + (fBase64? \";base64\" : \"\") + \",\";\n\n        if (!Web.isUserAgent(\"Firefox\")) {\n            sURI += (fBase64? sData : encodeURI(sData));\n        } else {\n            sURI += (fBase64? sData : encodeURIComponent(sData));\n        }\n        if (sFileName) {\n            link = document.createElement('a');\n            if (typeof link.download != 'string') link = null;\n        }\n        if (link) {\n            link.href = sURI;\n            link.download = sFileName;\n            document.body.appendChild(link);    // Firefox allegedly requires the link to be in the body\n            link.click();\n            document.body.removeChild(link);\n            sAlert = 'Check your Downloads folder for ' + sFileName + '.';\n        } else {\n            window.open(sURI);\n            sAlert = 'Check your browser for a new window/tab containing the requested data' + (sFileName? (' (' + sFileName + ')') : '') + '.';\n        }\n        return sAlert;\n    }\n\n    /**\n     * onCountRepeat(n, fnRepeat, fnComplete, msDelay)\n     *\n     * Call fnRepeat() n times with an msDelay millisecond delay between calls,\n     * then call fnComplete() when n has been exhausted OR fnRepeat() returns false.\n     *\n     * @param {number} n\n     * @param {function()} fnRepeat\n     * @param {function()} fnComplete\n     * @param {number} [msDelay]\n     */\n    static onCountRepeat(n, fnRepeat, fnComplete, msDelay)\n    {\n        var fnTimeout = function doCountRepeat()\n        {\n            n -= 1;\n            if (n >= 0) {\n                if (!fnRepeat()) n = 0;\n            }\n            if (n > 0) {\n                setTimeout(fnTimeout, msDelay || 0);\n                return;\n            }\n            fnComplete();\n        };\n        fnTimeout();\n    }\n\n    /**\n     * onClickRepeat(e, msDelay, msRepeat, fn)\n     *\n     * Repeatedly call fn() with an initial msDelay, and an msRepeat delay thereafter,\n     * as long as HTML control Object e has an active \"down\" event and fn() returns true.\n     *\n     * @param {Object} e\n     * @param {number} msDelay\n     * @param {number} msRepeat\n     * @param {function(boolean)} fn is passed false on the first call, true on all repeated calls\n     */\n    static onClickRepeat(e, msDelay, msRepeat, fn)\n    {\n        var ms = 0, timer = null, fIgnoreMouseEvents = false;\n\n        var fnRepeat = function doClickRepeat()\n        {\n            if (fn(ms === msRepeat)) {\n                timer = setTimeout(fnRepeat, ms);\n                ms = msRepeat;\n            }\n        };\n        e.onmousedown = function()\n        {\n            // Web.log(\"onMouseDown()\");\n            if (!fIgnoreMouseEvents) {\n                if (!timer) {\n                    ms = msDelay;\n                    fnRepeat();\n                }\n            }\n        };\n        e.ontouchstart = function()\n        {\n            // Web.log(\"onTouchStart()\");\n            if (!timer) {\n                ms = msDelay;\n                fnRepeat();\n            }\n        };\n        e.onmouseup = e.onmouseout = function()\n        {\n            // Web.log(\"onMouseUp()/onMouseOut()\");\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n        e.ontouchend = e.ontouchcancel = function()\n        {\n            // Web.log(\"onTouchEnd()/onTouchCancel()\");\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            /*\n             * Devices that generate ontouch* events ALSO generate onmouse* events,\n             * and generally do so immediately after all the touch events are complete,\n             * so unless we want double the action, we need to ignore mouse events.\n             */\n            fIgnoreMouseEvents = true;\n        };\n    }\n\n    /**\n     * onPageEvent(sName, fn)\n     *\n     * For 'onload', 'onunload', and 'onpageshow' events, most callers should NOT use this function, but\n     * instead use Web.onInit(), Web.onShow(), and Web.onExit(), respectively.\n     *\n     * The only components that should still use onPageEvent() are THIS component (see the bottom of this file)\n     * and components that need to capture other events (eg, the 'onresize' event in the Video component).\n     *\n     * This function creates a chain of callbacks, allowing multiple JavaScript modules to define handlers\n     * for the same event, which wouldn't be possible if everyone modified window['onload'], window['onunload'],\n     * etc, themselves.  However, that's less of a concern now, because assuming everyone else is now using\n     * onInit(), onExit(), etc, then there really IS only one component setting the window callback: this one.\n     *\n     * NOTE: It's risky to refer to obscure event handlers with \"dot\" names, because the Closure Compiler may\n     * erroneously replace them (eg, window.onpageshow is a good example).\n     *\n     * @param {string} sFunc\n     * @param {function()} fn\n     */\n    static onPageEvent(sFunc, fn)\n    {\n        if (window) {\n            var fnPrev = window[sFunc];\n            if (typeof fnPrev !== 'function') {\n                window[sFunc] = fn;\n            } else {\n                /*\n                 * TODO: Determine whether there's any value in receiving/sending the Event object that the\n                 * browser provides when it generates the original event.\n                 */\n                window[sFunc] = function onWindowEvent()\n                {\n                    if (fnPrev) fnPrev();\n                    fn();\n                };\n            }\n        }\n    };\n\n    /**\n     * onInit(fn)\n     *\n     * Use this instead of setting window.onload.  Allows multiple JavaScript modules to define their own 'onload' event handler.\n     *\n     * @param {function()} fn\n     */\n    static onInit(fn)\n    {\n        Web.aPageEventHandlers['init'].push(fn);\n    };\n\n    /**\n     * onShow(fn)\n     *\n     * @param {function()} fn\n     *\n     * Use this instead of setting window.onpageshow.  Allows multiple JavaScript modules to define their own 'onpageshow' event handler.\n     */\n    static onShow(fn)\n    {\n        Web.aPageEventHandlers['show'].push(fn);\n    };\n\n    /**\n     * onExit(fn)\n     *\n     * @param {function()} fn\n     *\n     * Use this instead of setting window.onunload.  Allows multiple JavaScript modules to define their own 'onunload' event handler.\n     */\n    static onExit(fn)\n    {\n        Web.aPageEventHandlers['exit'].push(fn);\n    };\n\n    /**\n     * doPageEvent(afn)\n     *\n     * @param {Array.<function()>} afn\n     */\n    static doPageEvent(afn)\n    {\n        if (Web.fPageEventsEnabled) {\n            try {\n                for (var i = 0; i < afn.length; i++) {\n                    afn[i]();\n                }\n            } catch (e) {\n                Web.notice(\"An unexpected error occurred: \" + e.message + \"\\n\\nIf it happens again, please send this information to support@pcjs.org. Thanks.\");\n            }\n        }\n    };\n\n    /**\n     * enablePageEvents(fEnable)\n     *\n     * @param {boolean} fEnable is true to enable page events, false to disable (they're enabled by default)\n     */\n    static enablePageEvents(fEnable)\n    {\n        if (!Web.fPageEventsEnabled && fEnable) {\n            Web.fPageEventsEnabled = true;\n            if (Web.fPageLoaded) Web.sendPageEvent('init');\n            if (Web.fPageShowed) Web.sendPageEvent('show');\n            return;\n        }\n        Web.fPageEventsEnabled = fEnable;\n    }\n\n    /**\n     * sendPageEvent(sEvent)\n     *\n     * This allows us to manually trigger page events.\n     *\n     * @param {string} sEvent (one of 'init', 'show' or 'exit')\n     */\n    static sendPageEvent(sEvent)\n    {\n        if (Web.aPageEventHandlers[sEvent]) {\n            Web.doPageEvent(Web.aPageEventHandlers[sEvent]);\n        }\n    }\n}\n\nWeb.parmsURL = null;            // initialized on first call to parseURLParms()\n\nWeb.aPageEventHandlers = {\n    'init': [],                 // list of window 'onload' handlers\n    'show': [],                 // list of window 'onpageshow' handlers\n    'exit': []                  // list of window 'onunload' handlers (although we prefer to use 'onbeforeunload' if possible)\n};\n\nWeb.asBrowserPrefixes = ['', 'moz', 'ms', 'webkit'];\n\nWeb.fPageLoaded = false;        // set once the page's first 'onload' event has occurred\nWeb.fPageShowed = false;        // set once the page's first 'onpageshow' event has occurred\nWeb.fPageEventsEnabled = true;  // default is true, set to false (or true) by enablePageEvents()\n\n/**\n * fLocalStorage\n *\n * true if localStorage support exists, is enabled, and works; \"falsey\" otherwise\n *\n * @type {boolean|null}\n */\nWeb.fLocalStorage = null;\n\n/**\n * TODO: Is there any way to get the Closure Compiler to stop inlining this string?  This isn't cutting it.\n *\n * @const {string}\n */\nWeb.sLocalStorageTest = \"PCjs.localStorage\";\n\nWeb.onPageEvent('onload', function onPageLoad() {\n    Web.fPageLoaded = true;\n    Web.doPageEvent(Web.aPageEventHandlers['init']);\n});\n\nWeb.onPageEvent('onpageshow', function onPageShow() {\n    Web.fPageShowed = true;\n    Web.doPageEvent(Web.aPageEventHandlers['show']);\n});\n\nWeb.onPageEvent(Web.isUserAgent(\"iOS\")? 'onpagehide' : (Web.isUserAgent(\"Opera\")? 'onunload' : 'onbeforeunload'), function onPageUnload() {\n    Web.doPageEvent(Web.aPageEventHandlers['exit']);\n});\n\n\n\n/**\n * @copyright http://pcjs.org/modules/shared/lib/component.js (C) Jeff Parsons 2012-2017\n */\n\n/*\n * All PCjs components now use JSDoc types, primarily so that Google's Closure Compiler will compile\n * everything with zero warnings when ADVANCED_OPTIMIZATIONS are enabled.  For more information about\n * the JSDoc types supported by the Closure Compiler:\n *\n *      https://developers.google.com/closure/compiler/docs/js-for-compiler#types\n *\n * I also attempted to validate this code with JSLint, but it complained too much; eg, it didn't like\n * \"while (true)\", a tried and \"true\" programming convention for decades, and it wanted me to replace\n * all \"++\" and \"--\" operators with \"+= 1\" and \"-= 1\", use \"(s || '')\" instead of \"(s? s : '')\", etc.\n *\n * I prefer sticking with traditional C-style idioms, in part because they are more portable.  That\n * does NOT mean I'm trying to write \"portable JavaScript,\" but some of this code was ported from C code\n * I'd written long ago, so portability is good, and I'm not going to throw that away if there's no need.\n *\n * UPDATE: I've since switched from JSLint to JSHint, which seems to have more reasonable defaults.\n * And for new code, I have adopted some popular JavaScript idioms, like \"(s || '')\", although the need\n * for those kinds of expressions will be reduced as I also start adopting some ES6 features, like\n * default parameters.\n */\n\n\n/**\n * Since the Closure Compiler treats ES6 classes as @struct rather than @dict by default,\n * it deters us from defining named properties on our components; eg:\n *\n *      this['exports'] = {...}\n *\n * results in an error:\n *\n *      Cannot do '[]' access on a struct\n *\n * So, in order to define 'exports', we must override the @struct assumption by annotating\n * the class as @unrestricted (or @dict).  Note that this must be done both here and in the\n * subclass (eg, SerialPort), because otherwise the Compiler won't allow us to *reference*\n * the named property either.\n *\n * TODO: Consider marking ALL our classes unrestricted, because otherwise it forces us to\n * define every single property the class uses in its constructor, which results in a fair\n * bit of redundant initialization, since many properties aren't (and don't need to be) fully\n * initialized until the appropriate init(), reset(), restore(), etc. function is called.\n *\n * The upside, however, may be that since the structure of the class is completely defined by\n * the constructor, JavaScript engines may be able to optimize and run more efficiently.\n *\n * @unrestricted\n */\nclass Component {\n    /**\n     * Component(type, parms, bitsMessage)\n     *\n     * A Component object requires:\n     *\n     *      type: a user-defined type name (eg, \"CPU\")\n     *\n     * and accepts any or all of the following (parms) properties:\n     *\n     *      id: component ID (default is \"\")\n     *      name: component name (default is \"\"; if blank, toString() will use the type name only)\n     *      comment: component comment string (default is undefined)\n     *\n     * Component subclasses will usually have additional (parms) properties.\n     *\n     * @param {string} type\n     * @param {Object} [parms]\n     * @param {number} [bitsMessage] selects message(s) that the component wants to enable (default is 0)\n     */\n    constructor(type, parms, bitsMessage)\n    {\n        this.type = type;\n\n        if (!parms) parms = {'id': \"\", 'name': \"\"};\n\n        this.id = parms['id'] || \"\";\n        this.name = parms['name'];\n        this.comment = parms['comment'];\n        this.parms = parms;\n\n        /*\n         * The following Component properties need to be accessible by other machines and/or command scripts;\n         * well, OK, or we could have exported some new functions to walk the contents of these properties, as we\n         * did with findMachineComponent(), but this works just as well.\n         *\n         * Also, while the double-assignment looks silly (ie, using both dot and bracket property notation), it\n         * resolves a complaint from the Closure Compiler, because if we use ONLY bracket notation here, then the\n         * Compiler wants us to change all the other references to bracket notation as well.\n         */\n        this.exports = this['exports'] = {};\n        this.bindings = this['bindings'] = {};\n\n        var i = this.id.indexOf('.');\n        if (i < 0) {\n            this.idComponent = this.id;\n        } else {\n            this.idMachine = this.id.substr(0, i);\n            this.idComponent = this.id.substr(i + 1);\n        }\n\n        /*\n         * Gather all the various component flags (booleans) into a single \"flags\" object, and encourage\n         * subclasses to do the same, to reduce the property clutter we have to wade through while debugging.\n         */\n        this.flags = {\n            ready:      false,\n            busy:       false,\n            busyCancel: false,\n            initDone:   false,\n            powered:    false,\n            unloading:  false,\n            error:      false\n        };\n\n        this.fnReady = null;\n        this.clearError();\n        this.bitsMessage = bitsMessage || 0;\n\n        this.cmp = null;\n        this.bus = null;\n        this.cpu = null;\n        this.dbg = null;\n\n        /*\n         * TODO: Consider adding another parameter to the Component() constructor that allows components to tell\n         * us if they support single or multiple instances per machine.  For example, there can be multiple SerialPort\n         * components per machine, but only one CPU component (some machines also support an FPU, but that component\n         * is considered separate from the CPU).\n         *\n         * It's not critical, but it would help catch machine configuration errors; for example, a machine that mistakenly\n         * includes two CPU components may, aside from wasting memory, end up with odd side-effects, like unresponsive\n         * CPU controls.\n         */\n        Component.add(this);\n    }\n\n    /**\n     * Component.add(component)\n     *\n     * @param {Component} component\n     */\n    static add(component)\n    {\n        /*\n         * This just generates a lot of useless noise, handy in the early days, not so much these days....\n         *\n         *      if (DEBUG) Component.log(\"Component.add(\" + component.type + \",\" + component.id + \")\");\n         */\n        Component.components.push(component);\n    }\n\n    /**\n     * Component.addMachine(idMachine)\n     *\n     * @param {string} idMachine\n     */\n    static addMachine(idMachine)\n    {\n        Component.machines[idMachine] = {};\n    }\n\n    /**\n     * Component.addMachineResource(idMachine, sName, data)\n     *\n     * @param {string} idMachine\n     * @param {string|null} sName (name of the resource)\n     * @param {*} data\n     */\n    static addMachineResource(idMachine, sName, data)\n    {\n        /*\n         * I used to assert(Component.machines[idMachine]), but when we're running as a Node app, embed.js is not used,\n         * so addMachine() is never called, so resources do not need to be recorded.\n         */\n        if (Component.machines[idMachine] && sName) {\n            Component.machines[idMachine][sName] = data;\n        }\n    }\n\n    /**\n     * Component.getMachineResources(idMachine)\n     *\n     * @param {string} idMachine\n     * @return {Object|undefined}\n     */\n    static getMachineResources(idMachine)\n    {\n        return Component.machines[idMachine];\n    }\n\n    /**\n     * Component.getTime()\n     *\n     * @return {number} the current time, in milliseconds\n     */\n    static getTime()\n    {\n        return Date.now() || +new Date();\n    }\n\n    /**\n     * Component.log(s, type)\n     *\n     * For diagnostic output only.\n     *\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     */\n    static log(s, type)\n    {\n        if (!COMPILED) {\n            if (s) {\n                var sElapsed = \"\", sMsg = (type? (type + \": \") : \"\") + s;\n                if (typeof Usr != \"undefined\") {\n                    if (Component.msStart === undefined) {\n                        Component.msStart = Component.getTime();\n                    }\n                    sElapsed = (Component.getTime() - Component.msStart) + \"ms: \";\n                }\n                sMsg = sMsg.replace(/\\r/g, '\\\\r').replace(/\\n/g, ' ');\n                if (window && window.console) console.log(sElapsed + sMsg);\n            }\n        }\n    }\n\n    /**\n     * Component.assert(f, s)\n     *\n     * Verifies conditions that must be true (for DEBUG builds only).\n     *\n     * The Closure Compiler should automatically remove all references to Component.assert() in non-DEBUG builds.\n     * TODO: Add a task to the build process that \"asserts\" there are no instances of \"assertion failure\" in RELEASE builds.\n     *\n     * @param {boolean} f is the expression we are asserting to be true\n     * @param {string} [s] is description of the assertion on failure\n     */\n    static assert(f, s)\n    {\n        if (DEBUG) {\n            if (!f) {\n                if (!s) s = \"assertion failure\";\n                Component.log(s);\n                throw new Error(s);\n            }\n        }\n    }\n\n    /**\n     * Component.print(s)\n     *\n     * Components that inherit from this class should use this.print(), rather than Component.print(), because\n     * if a Control Panel is loaded, it will override only the instance method, not the class method (overriding the\n     * class method would improperly affect any other machines loaded on the same page).\n     *\n     * @this {Component}\n     * @param {string} s\n     */\n    static print(s)\n    {\n        if (!COMPILED) {\n            var i = s.lastIndexOf('\\n');\n            if (i >= 0) {\n                Component.println(s.substr(0, i));\n                s = s.substr(i + 1);\n            }\n            Component.printBuffer += s;\n        }\n    }\n\n    /**\n     * Component.println(s, type, id)\n     *\n     * Components that inherit from this class should use this.println(), rather than Component.println(), because\n     * if a Control Panel is loaded, it will override only the instance method, not the class method (overriding the\n     * class method would improperly affect any other machines loaded on the same page).\n     *\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     * @param {string} [id] is the caller's ID, if any\n     */\n    static println(s, type, id)\n    {\n        if (!COMPILED) {\n            s = Component.printBuffer + (s || \"\");\n            Component.log((id? (id + \": \") : \"\") + (s? (\"\\\"\" + s + \"\\\"\") : \"\"), type);\n            Component.printBuffer = \"\";\n        }\n    }\n\n    /**\n     * Component.notice(s, fPrintOnly, id)\n     *\n     * notice() is like println() but implies a need for user notification, so we alert() as well.\n     *\n     * @param {string} s is the message text\n     * @param {boolean} [fPrintOnly]\n     * @param {string} [id] is the caller's ID, if any\n     * @return {boolean}\n     */\n    static notice(s, fPrintOnly, id)\n    {\n        if (!COMPILED) {\n            Component.println(s, Component.PRINT.NOTICE, id);\n        }\n        if (!fPrintOnly) Component.alertUser((id? (id + \": \") : \"\") + s);\n        return true;\n    }\n\n    /**\n     * Component.warning(s)\n     *\n     * @param {string} s describes the warning\n     */\n    static warning(s)\n    {\n        if (!COMPILED) {\n            Component.println(s, Component.PRINT.WARNING);\n        }\n        Component.alertUser(s);\n    }\n\n    /**\n     * Component.error(s)\n     *\n     * @param {string} s describes the error; an alert() is displayed as well\n     */\n    static error(s)\n    {\n        if (!COMPILED) {\n            Component.println(s, Component.PRINT.ERROR);\n        }\n        Component.alertUser(s);\n    }\n\n    /**\n     * Component.alertUser(sMessage)\n     *\n     * @param {string} sMessage\n     */\n    static alertUser(sMessage)\n    {\n        if (window) {\n            window.alert(sMessage);\n        } else {\n            Component.log(sMessage);\n        }\n    };\n\n    /**\n     * Component.confirmUser(sPrompt)\n     *\n     * @param {string} sPrompt\n     * @returns {boolean} true if the user clicked OK, false if Cancel/Close\n     */\n    static confirmUser(sPrompt)\n    {\n        var fResponse = false;\n        if (window) {\n            fResponse = window.confirm(sPrompt);\n        }\n        return fResponse;\n    }\n\n    /**\n     * Component.promptUser()\n     *\n     * @param {string} sPrompt\n     * @param {string} [sDefault]\n     * @returns {string|null}\n     */\n    static promptUser(sPrompt, sDefault)\n    {\n        var sResponse = null;\n        if (window) {\n            sResponse = window.prompt(sPrompt, sDefault === undefined? \"\" : sDefault);\n        }\n        return sResponse;\n    }\n\n    /**\n     * Component.appendControl(control, sText)\n     *\n     * @param {Object} control\n     * @param {string} sText\n     */\n    static appendControl(control, sText)\n    {\n        control.value += sText;\n        /*\n         * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.\n         */\n        if (COMPILED) {\n            sText = control.value;\n            if (sText.length > 8192) control.value = sText.substr(sText.length - 4096);\n        }\n        control.scrollTop = control.scrollHeight;\n    }\n\n    /**\n     * Component.replaceControl(control, sSearch, sReplace)\n     *\n     * @param {Object} control\n     * @param {string} sSearch\n     * @param {string} sReplace\n     */\n    static replaceControl(control, sSearch, sReplace)\n    {\n        var sText = control.value;\n        var i = sText.lastIndexOf(sSearch);\n        if (i < 0) {\n            sText += sSearch + '\\n';\n        } else {\n            sText = sText.substr(0, i) + sReplace + sText.substr(i + sSearch.length);\n        }\n        /*\n         * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.\n         */\n        if (COMPILED && sText.length > 8192) sText = sText.substr(sText.length - 4096);\n        control.value = sText;\n        control.scrollTop = control.scrollHeight;\n    }\n\n    /**\n     * Component.bindExternalControl(component, sControl, sBinding, sType)\n     *\n     * @param {Component} component\n     * @param {string} sControl\n     * @param {string} sBinding\n     * @param {string} [sType] is the external component type\n     */\n    static bindExternalControl(component, sControl, sBinding, sType)\n    {\n        if (sControl) {\n            if (sType === undefined) sType = \"Panel\";\n            var target = Component.getComponentByType(sType, component.id);\n            if (target) {\n                var eBinding = target.bindings[sControl];\n                if (eBinding) {\n                    component.setBinding(null, sBinding, eBinding);\n                }\n            }\n        }\n    }\n\n    /**\n     * Component.bindComponentControls(component, element, sAppClass)\n     *\n     * @param {Component} component\n     * @param {HTMLElement} element from the DOM\n     * @param {string} sAppClass\n     */\n    static bindComponentControls(component, element, sAppClass)\n    {\n        var aeControls = Component.getElementsByClass(element.parentNode, sAppClass + \"-control\");\n\n        for (var iControl = 0; iControl < aeControls.length; iControl++) {\n\n            var aeChildNodes = aeControls[iControl].childNodes;\n\n            for (var iNode = 0; iNode < aeChildNodes.length; iNode++) {\n                var control = aeChildNodes[iNode];\n                if (control.nodeType !== 1 /* document.ELEMENT_NODE */) {\n                    continue;\n                }\n                var sClass = control.getAttribute(\"class\");\n                if (!sClass) continue;\n                var aClasses = sClass.split(\" \");\n                for (var iClass = 0; iClass < aClasses.length; iClass++) {\n                    var parms;\n                    sClass = aClasses[iClass];\n                    switch (sClass) {\n                        case sAppClass + \"-binding\":\n                            parms = Component.getComponentParms(control);\n                            if (parms && parms['binding']) {\n                                component.setBinding(parms['type'], parms['binding'], control, parms['value']);\n                            } else if (!parms || parms['type'] != \"description\") {\n                                Component.log(\"Component '\" + component.toString() + \"' missing binding\" + (parms? \" for \" + parms['type'] : \"\"), \"warning\");\n                            }\n                            iClass = aClasses.length;\n                            break;\n                        default:\n                            // if (DEBUG) Component.log(\"Component.bindComponentControls(\" + component.toString() + \"): unrecognized control class \\\"\" + sClass + \"\\\"\", \"warning\");\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Component.getComponents(idRelated)\n     *\n     * We could store components as properties, using the component's ID, and change\n     * this linear lookup into a property lookup, but some components may have no ID.\n     *\n     * @param {string} [idRelated] of related component\n     * @return {Array} of components\n     */\n    static getComponents(idRelated)\n    {\n        var i;\n        var aComponents = [];\n        /*\n         * getComponentByID(id, idRelated)\n         *\n         * If idRelated is provided, we check it for a machine prefix, and use any\n         * existing prefix to constrain matches to IDs with the same prefix, in order to\n         * avoid matching components belonging to other machines.\n         */\n        if (idRelated) {\n            if ((i = idRelated.indexOf('.')) > 0)\n                idRelated = idRelated.substr(0, i + 1);\n            else\n                idRelated = \"\";\n        }\n        for (i = 0; i < Component.components.length; i++) {\n            var component = Component.components[i];\n            if (!idRelated || !component.id.indexOf(idRelated)) {\n                aComponents.push(component);\n            }\n        }\n        return aComponents;\n    }\n\n    /**\n     * Component.getComponentByID(id, idRelated)\n     *\n     * We could store components as properties, using the component's ID, and change\n     * this linear lookup into a property lookup, but some components may have no ID.\n     *\n     * @param {string} id of the desired component\n     * @param {string} [idRelated] of related component\n     * @return {Component|null}\n     */\n    static getComponentByID(id, idRelated)\n    {\n        if (id !== undefined) {\n            var i;\n            /*\n             * If idRelated is provided, we check it for a machine prefix, and use any\n             * existing prefix to constrain matches to IDs with the same prefix, in order to\n             * avoid matching components belonging to other machines.\n             */\n            if (idRelated && (i = idRelated.indexOf('.')) > 0) {\n                id = idRelated.substr(0, i + 1) + id;\n            }\n            for (i = 0; i < Component.components.length; i++) {\n                if (Component.components[i].id === id) {\n                    return Component.components[i];\n                }\n            }\n            if (Component.components.length) {\n                Component.log(\"Component ID '\" + id + \"' not found\", \"warning\");\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Component.getComponentByType(sType, idRelated, componentPrev)\n     *\n     * @param {string} sType of the desired component\n     * @param {string} [idRelated] of related component\n     * @param {Component|null} [componentPrev] of previously returned component, if any\n     * @return {Component|null}\n     */\n    static getComponentByType(sType, idRelated, componentPrev)\n    {\n        if (sType !== undefined) {\n            var i;\n            /*\n             * If idRelated is provided, we check it for a machine prefix, and use any\n             * existing prefix to constrain matches to IDs with the same prefix, in order to\n             * avoid matching components belonging to other machines.\n             */\n            if (idRelated) {\n                if ((i = idRelated.indexOf('.')) > 0) {\n                    idRelated = idRelated.substr(0, i + 1);\n                } else {\n                    idRelated = \"\";\n                }\n            }\n            for (i = 0; i < Component.components.length; i++) {\n                if (componentPrev) {\n                    if (componentPrev == Component.components[i]) componentPrev = null;\n                    continue;\n                }\n                if (sType == Component.components[i].type && (!idRelated || !Component.components[i].id.indexOf(idRelated))) {\n                    return Component.components[i];\n                }\n            }\n            Component.log(\"Component type '\" + sType + \"' not found\", \"warning\");\n        }\n        return null;\n    }\n\n    /**\n     * Component.getComponentParms(element)\n     *\n     * @param {HTMLElement} element from the DOM\n     */\n    static getComponentParms(element)\n    {\n        var parms = null;\n        var sParms = element.getAttribute(\"data-value\");\n        if (sParms) {\n            try {\n                parms = eval('(' + sParms + ')');   // jshint ignore:line\n                /*\n                 * We can no longer invoke removeAttribute() because some components (eg, Panel) need\n                 * to run their initXXX() code more than once, to avoid initialization-order dependencies.\n                 *\n                 *      if (!DEBUG) {\n                 *          element.removeAttribute(\"data-value\");\n                 *      }\n                 */\n            } catch(e) {\n                Component.error(e.message + \" (\" + sParms + \")\");\n            }\n        }\n        return parms;\n    }\n\n    /**\n     * Component.getElementsByClass(element, sClass, sObjClass)\n     *\n     * This is a cross-browser helper function, since not all browser's support getElementsByClassName()\n     *\n     * TODO: This should probably be moved into weblib.js at some point, along with the control binding functions above,\n     * to keep all the browser-related code together.\n     *\n     * @param {HTMLDocument|HTMLElement|Node} element from the DOM\n     * @param {string} sClass\n     * @param {string} [sObjClass]\n     * @return {Array|NodeList}\n     */\n    static getElementsByClass(element, sClass, sObjClass)\n    {\n        if (sObjClass) sClass += '-' + sObjClass + \"-object\";\n        /*\n         * Use the browser's built-in getElementsByClassName() if it appears to be available\n         * (for example, it's not available in IE8, but it should be available in IE9 and up)\n         */\n        if (element.getElementsByClassName) {\n            return element.getElementsByClassName(sClass);\n        }\n        var i, j, ae = [];\n        var aeAll = element.getElementsByTagName(\"*\");\n        var re = new RegExp('(^| )' + sClass + '( |$)');\n        for (i = 0, j = aeAll.length; i < j; i++) {\n            if (re.test(aeAll[i].className)) {\n                ae.push(aeAll[i]);\n            }\n        }\n        if (!ae.length) {\n            Component.log('No elements of class \"' + sClass + '\" found');\n        }\n        return ae;\n    }\n\n    /**\n     * Component.getScriptCommands(sScript)\n     *\n     * This is a simple parser that breaks sScript into an array of commands, where each command\n     * is an array of tokens, where tokens are sequences of characters separated by any of: tab, space,\n     * carriage-return (CR), line-feed (LF), semicolon, single-quote, or double-quote; if a quote is\n     * used, all characters up to the next matching quote become part of the token, allowing any of the\n     * other separators to be part of the token.  CR, LF and semicolon also serve to terminate a command,\n     * with semicolon being preferred, because it's 1) more visible, and 2) essential when the entire\n     * script is a multi-line string where all CR/LF were replaced by spaces (which is what Jekyll does,\n     * and since we can't change Jekyll, it's what our own MarkDown Front Matter parser does as well;\n     * see convertMD() in markout.js, where the aCommandDefs array is built).\n     *\n     * Backslash sequences like \\n, \\r, and \\\\ have already been converted to LF, CR and backslash\n     * characters, since the entire script string is injected into a JavaScript function call, so any\n     * backslash sequence that JavaScript supports is automatically converted:\n     *\n     *      \\0  \\'  \\\"  \\\\  \\n  \\r  \\v  \\t  \\b  \\f  \\uXXXX \\xXX\n     *                      ^J  ^M  ^K  ^I  ^H  ^L\n     *\n     * To support any other non-printable 8-bit character, such as ESC, you should use \\xXX, where XX\n     * is the ASCII code in hex.  For ESC, that would be \\x1B.\n     *\n     * @param {string} sScript\n     * @return {Array}\n     */\n    static getScriptCommands(sScript)\n    {\n        var cch = sScript.length;\n        var aCommands = [], aTokens = [], sToken = \"\", chQuote = null;\n        for (var i = 0; i < cch; i++) {\n            var ch = sScript[i];\n            if (ch == '\"' || ch == \"'\") {\n                if (chQuote && ch != chQuote) {\n                    sToken += ch;\n                    continue;\n                }\n                if (!chQuote) {\n                    chQuote = ch;\n                } else {\n                    chQuote = null;\n                }\n                if (sToken) {\n                    aTokens.push(sToken);\n                    sToken = \"\";\n                }\n                continue;\n            }\n            if (!chQuote) {\n                if (ch == '\\r' || ch == '\\n') {\n                    ch = ';';\n                }\n                if (ch == ' ' || ch == '\\t' || ch == ';') {\n                    if (sToken) {\n                        aTokens.push(sToken);\n                        sToken = \"\";\n                    }\n                    if (ch == ';' && aTokens.length) {\n                        aCommands.push(aTokens);\n                        aTokens = [];\n                    }\n                    continue;\n                }\n            }\n            sToken += ch;\n        }\n        if (sToken) {\n            aTokens.push(sToken);\n        }\n        if (aTokens.length) {\n            aCommands.push(aTokens);\n        }\n        return aCommands;\n    }\n\n    /**\n     * Component.processScript(idMachine, sScript)\n     *\n     * @param {string} idMachine\n     * @param {string} [sScript]\n     * @return {boolean}\n     */\n    static processScript(idMachine, sScript)\n    {\n        var fSuccess = false;\n        idMachine += \".machine\";\n        if (!sScript) {\n            delete Component.commands[idMachine];\n            fSuccess = true;\n        }\n        else if (typeof sScript == \"string\" && !Component.commands[idMachine]) {\n            fSuccess = true;\n            Component.commands[idMachine] = Component.getScriptCommands(sScript);\n            if (!Component.processCommands(idMachine)) {\n                fSuccess = false;\n            }\n        }\n        return fSuccess;\n    }\n\n    /**\n     * Component.processCommands(idMachine)\n     *\n     * @param {string} idMachine\n     * @return {boolean}\n     */\n    static processCommands(idMachine)\n    {\n        var fSuccess = true;\n        var aCommands = Component.commands[idMachine];\n\n     // var dbg = Component.getComponentByType(\"Debugger\", idMachine);\n\n        while (aCommands && aCommands.length) {\n\n            var aTokens = aCommands.splice(0, 1)[0];\n            var sCommand = aTokens[0];\n\n            /*\n             * It's possible to route this output to the Debugger window with dbg.println()\n             * instead, but it's a bit too confusing mingling script output in a window that\n             * already mingles Debugger and machine output.\n             */\n            Component.println(aTokens.join(' '), Component.PRINT.SCRIPT);\n\n            var fnCallReady = null;\n            if (Component.asyncCommands.indexOf(sCommand) >= 0) {\n                fnCallReady = function processNextCommand() {\n                    return function() {\n                        Component.processCommands(idMachine);\n                    }\n                }();\n            }\n\n            var fnCommand = Component.globalCommands[sCommand];\n            if (fnCommand) {\n                if (!fnCallReady) {\n                    fSuccess = fnCommand(aTokens[1], aTokens[2], aTokens[3]);\n                } else {\n                    if (!fnCommand(fnCallReady, aTokens[1], aTokens[2], aTokens[3])) break;\n                }\n            }\n            else {\n                fSuccess = false;\n                var component = Component.getComponentByType(aTokens[1], idMachine);\n                if (component) {\n                    fnCommand = Component.componentCommands[sCommand];\n                    if (fnCommand) {\n                        fSuccess = fnCommand(component, aTokens[2], aTokens[3]);\n                    }\n                    else {\n                        var exports = component['exports'];\n                        if (exports) {\n                            fnCommand = exports[sCommand];\n                            if (fnCommand) {\n                                fSuccess = true;\n                                if (!fnCallReady) {\n                                    fSuccess = fnCommand.call(component, aTokens[2], aTokens[3]);\n                                } else {\n                                    if (!fnCommand.call(component, fnCallReady, aTokens[2], aTokens[3])) break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!fSuccess) {\n                Component.alertUser(\"Script error: '\" + sCommand + (fnCommand? \" failed\" : \" unrecognized\"));\n                break;\n            }\n        }\n\n        if (aCommands && !aCommands.length) {\n            delete Component.commands[idMachine];\n        }\n\n        return fSuccess;\n    }\n\n    /**\n     * Component.scriptAlert(sMessage)\n     *\n     * @param {string} sMessage\n     * @return {boolean}\n     */\n    static scriptAlert(sMessage)\n    {\n        Component.alertUser(sMessage);\n        return true;\n    }\n\n    /**\n     * Component.scriptSelect(component, sBinding, sValue)\n     *\n     * @param {Component} component\n     * @param {string} sBinding\n     * @param {string} sValue\n     * @return {boolean}\n     */\n    static scriptSelect(component, sBinding, sValue)\n    {\n        var fSuccess = false;\n        var aBindings = component['bindings'];\n        var control = aBindings[sBinding];\n        if (control) {\n            for (var i = 0; i < control.options.length; i++) {\n                if (control.options[i].textContent == sValue) {\n                    if (control.selectedIndex != i) {\n                        control.selectedIndex = i;\n                    }\n                    fSuccess = true;\n                    break;\n                }\n            }\n        }\n        return fSuccess;\n    }\n\n    /**\n     * Component.scriptSleep(fnCallback, sDelay)\n     *\n     * @param {function()} fnCallback\n     * @param {string} sDelay (in milliseconds)\n     * @return {boolean}\n     */\n    static scriptSleep(fnCallback, sDelay)\n    {\n        setTimeout(fnCallback, +sDelay);\n        return false;\n    }\n\n    /**\n     * toString()\n     *\n     * @this {Component}\n     * @return {string}\n     */\n    toString()\n    {\n        return (this.name? this.name : (this.id || this.type));\n    }\n\n    /**\n     * getMachineNum()\n     *\n     * @this {Component}\n     * @return {number} unique machine number\n     */\n    getMachineNum()\n    {\n        var nMachine = 1;\n        if (this.idMachine) {\n            var aDigits = this.idMachine.match(/\\d+/);\n            if (aDigits !== null)\n                nMachine = parseInt(aDigits[0], 10);\n        }\n        return nMachine;\n    }\n\n    /**\n     * setBinding(sHTMLType, sBinding, control, sValue)\n     *\n     * Component's setBinding() method is intended to be overridden by subclasses.\n     *\n     * @this {Component}\n     * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\", \"canvas\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, 'print')\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        switch (sBinding) {\n        case 'clear':\n            if (!this.bindings[sBinding]) {\n                this.bindings[sBinding] = control;\n                control.onclick = (function(component) {\n                    return function clearControl() {\n                        if (component.bindings['print']) {\n                            component.bindings['print'].value = \"\";\n                        }\n                    };\n                }(this));\n            }\n            return true;\n        case 'print':\n            if (!this.bindings[sBinding]) {\n                var controlTextArea = /** @type {HTMLTextAreaElement} */ (control);\n                this.bindings[sBinding] = controlTextArea;\n                /**\n                 * Override this.notice() with a replacement function that eliminates the Component.alertUser() call.\n                 *\n                 * @this {Component}\n                 * @param {string} s\n                 * @param {boolean} [fPrintOnly]\n                 * @param {string} [id]\n                 * @return {boolean}\n                 */\n                this.notice = function noticeControl(s, fPrintOnly, id) {\n                    this.println(s, this.type);\n                    return true;\n                };\n                /*\n                 * This was added for Firefox (Safari will clear the <textarea> on a page reload, but Firefox does not).\n                 */\n                controlTextArea.value = \"\";\n                this.print = function(control) {\n                    return function printControl(s) {\n                        Component.appendControl(control, s);\n                    };\n                }(controlTextArea);\n                this.println = function(component, control) {\n                    return function printlnControl(s, type, id) {\n                        if (!s) s = \"\";\n                        if (type != Component.PRINT.PROGRESS || s.slice(-3) != \"...\") {\n                            if (type) s = type + \": \" + s;\n                            Component.appendControl(control, s + '\\n');\n                        } else {\n                            Component.replaceControl(control, s, s + '.');\n                        }\n                        if (!COMPILED && window && window.console) Component.println(s, type, id);\n                    };\n                }(this, controlTextArea);\n            }\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    /**\n     * log(s, type)\n     *\n     * For diagnostic output only.\n     *\n     * WARNING: Even though this function's body is completely wrapped in DEBUG, that won't prevent the Closure Compiler\n     * from including it, so all calls must still be prefixed with \"if (DEBUG) ....\".  For this reason, the class method,\n     * Component.log(), is preferred, because the compiler IS smart enough to remove those calls.\n     *\n     * @this {Component}\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     */\n    log(s, type)\n    {\n        if (!COMPILED) {\n            Component.log(s, type || this.id || this.type);\n        }\n    }\n\n    /**\n     * assert(f, s)\n     *\n     * Verifies conditions that must be true (for DEBUG builds only).\n     *\n     * WARNING: Make sure you preface all calls to this.assert() with \"if (DEBUG)\", because unlike Component.assert(),\n     * the Closure Compiler can't be sure that this instance method hasn't been overridden, so it refuses to treat it as\n     * dead code in non-DEBUG builds.\n     *\n     * TODO: Add a task to the build process that \"asserts\" there are no instances of \"assertion failure\" in RELEASE builds.\n     *\n     * @this {Component}\n     * @param {boolean|number} f is the expression asserted to be true\n     * @param {string} [s] is a description of the assertion to be displayed or logged on failure\n     */\n    assert(f, s)\n    {\n        if (DEBUG) {\n            if (!f) {\n                s = \"assertion failure in \" + (this.id || this.type) + (s? \": \" + s : \"\");\n                if (DEBUGGER && this.dbg) {\n                    this.dbg.stopCPU();\n                    /*\n                     * Why do we throw an Error only to immediately catch and ignore it?  Simply to give\n                     * any IDE the opportunity to inspect the application's state.  Even when the IDE has\n                     * control, you should still be able to invoke Debugger commands from the IDE's REPL,\n                     * using the global function that the Debugger constructor defines; eg:\n                     *\n                     *      pcx86('r')\n                     *      pcx86('dw 0:0')\n                     *      pcx86('h')\n                     *      ...\n                     *\n                     * If you have no desire to stop on assertions, consider this a no-op.  However, another\n                     * potential benefit of creating an Error object is that, for browsers like Chrome, we get\n                     * a stack trace, too.\n                     */\n                    try {\n                        throw new Error(s);\n                    } catch(e) {\n                        this.println(e.stack || e.message);\n                    }\n                    return;\n                }\n                this.log(s);\n                throw new Error(s);\n            }\n        }\n    }\n\n    /**\n     * print(s)\n     *\n     * Components using this.print() should wait until after their constructor has run to display any messages, because\n     * if a Control Panel has been loaded, its override will not take effect until its own constructor has run.\n     *\n     * @this {Component}\n     * @param {string} s\n     */\n    print(s)\n    {\n        Component.print(s);\n    }\n\n    /**\n     * println(s, type, id)\n     *\n     * Components using this.println() should wait until after their constructor has run to display any messages, because\n     * if a Control Panel has been loaded, its override will not take effect until its own constructor has run.\n     *\n     * @this {Component}\n     * @param {string} [s] is the message text\n     * @param {string} [type] is the message type\n     * @param {string} [id] is the caller's ID, if any\n     */\n    println(s, type, id)\n    {\n        Component.println(s, type, id || this.id);\n    }\n\n    /**\n     * status(s)\n     *\n     * status() is like println() but it also includes information about the component (ie, the component type),\n     * which is why there is no corresponding Component.status() function.\n     *\n     * @this {Component}\n     * @param {string} s is the message text\n     */\n    status(s)\n    {\n        this.println(this.type + \": \" + s);\n    }\n\n    /**\n     * notice(s, fPrintOnly, id)\n     *\n     * notice() is like println() but implies a need for user notification, so we alert() as well; however, if this.println()\n     * is overridden, this.notice will be replaced with a similar override, on the assumption that the override is taking care\n     * of alerting the user.\n     *\n     * @this {Component}\n     * @param {string} s is the message text\n     * @param {boolean} [fPrintOnly]\n     * @param {string} [id] is the caller's ID, if any\n     * @return {boolean}\n     */\n    notice(s, fPrintOnly, id)\n    {\n        if (!fPrintOnly) {\n            /*\n             * See if the associated computer, if any, is \"unloading\"....\n             */\n            var computer = Component.getComponentByType(\"Computer\", this.id);\n            if (computer && computer.flags.unloading) {\n                console.log(\"ignoring notice during unload: \" + s);\n                return false;\n            }\n        }\n        Component.notice(s, fPrintOnly, id || this.type);\n        return true;\n    }\n\n    /**\n     * setError(s)\n     *\n     * Set a fatal error condition\n     *\n     * @this {Component}\n     * @param {string} s describes a fatal error condition\n     */\n    setError(s)\n    {\n        this.flags.error = true;\n        this.notice(s);         // TODO: Any cases where we should still prefix this string with \"Fatal error: \"?\n    }\n\n    /**\n     * clearError()\n     *\n     * Clear any fatal error condition\n     *\n     * @this {Component}\n     */\n    clearError() {\n        this.flags.error = false;\n    }\n\n    /**\n     * isError()\n     *\n     * Report any fatal error condition\n     *\n     * @this {Component}\n     * @return {boolean} true if a fatal error condition exists, false if not\n     */\n    isError()\n    {\n        if (this.flags.error) {\n            this.println(this.toString() + \" error\");\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * isReady(fnReady)\n     *\n     * Return the \"ready\" state of the component; if the component is not ready, it will queue the optional\n     * notification function, otherwise it will immediately call the notification function, if any, without queuing it.\n     *\n     * NOTE: Since only the Computer component actually cares about the \"readiness\" of other components, the so-called\n     * \"queue\" of notification functions supports exactly one function.  This keeps things nice and simple.\n     *\n     * @this {Component}\n     * @param {function()} [fnReady]\n     * @return {boolean} true if the component is in a \"ready\" state, false if not\n     */\n    isReady(fnReady)\n    {\n        if (fnReady) {\n            if (this.flags.ready) {\n                fnReady();\n            } else {\n                if (MAXDEBUG) this.log(\"NOT ready\");\n                this.fnReady = fnReady;\n            }\n        }\n        return this.flags.ready;\n    }\n\n    /**\n     * setReady(fReady)\n     *\n     * Set the \"ready\" state of the component to true, and call any queued notification functions.\n     *\n     * @this {Component}\n     * @param {boolean} [fReady] is assumed to indicate \"ready\" unless EXPLICITLY set to false\n     */\n    setReady(fReady)\n    {\n        if (!this.flags.error) {\n            this.flags.ready = (fReady !== false);\n            if (this.flags.ready) {\n                if (MAXDEBUG /* || this.name */) this.log(\"ready\");\n                var fnReady = this.fnReady;\n                this.fnReady = null;\n                if (fnReady) fnReady();\n            }\n        }\n    }\n\n    /**\n     * isBusy(fCancel)\n     *\n     * Return the \"busy\" state of the component\n     *\n     * @this {Component}\n     * @param {boolean} [fCancel] is set to true to cancel a \"busy\" state\n     * @return {boolean} true if \"busy\", false if not\n     */\n    isBusy(fCancel)\n    {\n        if (this.flags.busy) {\n            if (fCancel) {\n                this.flags.busyCancel = true;\n            } else if (fCancel === undefined) {\n                this.println(this.toString() + \" busy\");\n            }\n        }\n        return this.flags.busy;\n    }\n\n    /**\n     * setBusy(fBusy)\n     *\n     * Update the current busy state; if a busyCancel request is pending, it will be honored now.\n     *\n     * @this {Component}\n     * @param {boolean} fBusy\n     * @return {boolean}\n     */\n    setBusy(fBusy)\n    {\n        if (this.flags.busyCancel) {\n            this.flags.busy = false;\n            this.flags.busyCancel = false;\n            return false;\n        }\n        if (this.flags.error) {\n            this.println(this.toString() + \" error\");\n            return false;\n        }\n        this.flags.busy = fBusy;\n        return this.flags.busy;\n    }\n\n    /**\n     * powerUp(fSave)\n     *\n     * @this {Component}\n     * @param {Object|null} data\n     * @param {boolean} [fRepower] is true if this is \"repower\" notification\n     * @return {boolean} true if successful, false if failure\n     */\n    powerUp(data, fRepower)\n    {\n        this.flags.powered = true;\n        return true;\n    }\n\n    /**\n     * powerDown(fSave, fShutdown)\n     *\n     * @this {Component}\n     * @param {boolean} fSave\n     * @param {boolean} [fShutdown]\n     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure\n     */\n    powerDown(fSave, fShutdown)\n    {\n        if (fShutdown) this.flags.powered = false;\n        return true;\n    }\n\n    /**\n     * messageEnabled(bitsMessage)\n     *\n     * If bitsMessage is not specified, the component's MESSAGE category is used.\n     *\n     * @this {Component}\n     * @param {number} [bitsMessage] is zero or more MESSAGE_* category flag(s)\n     * @return {boolean} true if all specified message enabled, false if not\n     */\n    messageEnabled(bitsMessage = 0)\n    {\n        if (DEBUGGER && this.dbg) {\n            if (this !== this.dbg) {\n                bitsMessage = bitsMessage || this.bitsMessage;\n            }\n            var bitsEnabled = this.dbg.bitsMessage & bitsMessage;\n            return (!!bitsMessage && bitsEnabled === bitsMessage || !!(bitsEnabled & this.dbg.bitsWarning));\n        }\n        return false;\n    }\n\n    /**\n     * printf(format, ...args)\n     *\n     * @this {Component} (imported from Device)\n     * @param {string} format\n     * @param {...} args\n     */\n    printf(format, ...args)\n    {\n        /*\n         * Callers often check messageEnabled() themselves, but for those that don't, check it now.\n         */\n        if (DEBUGGER && this.dbg && this.messageEnabled()) {\n            /*\n             * TODO: If/when dbg.message() is replaced with print(), remove the following linefeed removal.\n             */\n            this.dbg.message(this.sprintf(format, ...args).replace(/\\n$/,\"\"));\n        }\n    }\n\n    /**\n     * printMessage(sMessage, bitsMessage, fAddress)\n     *\n     * If bitsMessage is not specified, the component's MESSAGE category is used.\n     * If bitsMessage is true, the message is displayed regardless.\n     *\n     * @this {Component}\n     * @param {string} sMessage is any caller-defined message string\n     * @param {number|boolean} [bitsMessage] is zero or more MESSAGE_* category flag(s)\n     * @param {boolean} [fAddress] is true to display the current address\n     */\n    printMessage(sMessage, bitsMessage, fAddress)\n    {\n        if (DEBUGGER && this.dbg) {\n            if (bitsMessage === true || this.messageEnabled(bitsMessage | 0)) {\n                this.dbg.message(sMessage, fAddress);\n            }\n        }\n    }\n\n    /**\n     * printMessageIO(port, bOut, addrFrom, name, bIn, bitsMessage)\n     *\n     * If bitsMessage is not specified, the component's MESSAGE category is used.\n     * If bitsMessage is true, the message is displayed as long as MESSAGE.PORT is enabled.\n     *\n     * @this {Component}\n     * @param {number} port\n     * @param {number|null} bOut if an output operation\n     * @param {number|null} [addrFrom]\n     * @param {string|null} [name] of the port, if any\n     * @param {number|null} [bIn] is the input value, if known, on an input operation\n     * @param {number|boolean} [bitsMessage] is zero or more MESSAGE_* category flag(s)\n     */\n    printMessageIO(port, bOut, addrFrom, name, bIn, bitsMessage)\n    {\n        if (DEBUGGER && this.dbg) {\n            if (bitsMessage === true) {\n                bitsMessage = 0;\n            } else if (bitsMessage == null) {\n                bitsMessage = this.bitsMessage;\n            }\n            this.dbg.messageIO(this, port, bOut, addrFrom, name, bIn, bitsMessage);\n        }\n    }\n\n    /**\n     * sprintf(format, ...args)\n     *\n     * Copied from the CCjs project (https://github.com/jeffpar/ccjs/blob/master/lib/stdio.js) and extended.\n     *\n     * Far from complete, let alone sprintf-compatible, but it's adequate for the handful of sprintf-style format\n     * specifiers that I use.\n     *\n     * @this {Component} (imported from Device)\n     * @param {string} format\n     * @param {...} args\n     * @returns {string}\n     */\n    sprintf(format, ...args)\n    {\n        let buffer = \"\";\n        let aParts = format.split(/%([-+ 0#]?)([0-9]*)(\\.?)([0-9]*)([hlL]?)([A-Za-z%])/);\n\n        let iArg = 0, iPart;\n        for (iPart = 0; iPart < aParts.length - 7; iPart += 7) {\n\n            buffer += aParts[iPart];\n\n            let arg = args[iArg++];\n            let flags = aParts[iPart+1];\n            let minimum = +aParts[iPart+2] || 0;\n            let precision = +aParts[iPart+4] || 0;\n            let conversion = aParts[iPart+6];\n            let ach = null, s;\n\n            switch(conversion) {\n            case 'd':\n                /*\n                 * We could use \"arg |= 0\", but there may be some value to supporting integers > 32 bits.\n                 */\n                arg = Math.trunc(arg);\n                /* falls through */\n\n            case 'f':\n                s = Math.trunc(arg) + \"\";\n                if (precision) {\n                    minimum -= (precision + 1);\n                }\n                if (s.length < minimum) {\n                    if (flags == '0') {\n                        if (arg < 0) minimum--;\n                        s = (\"0000000000\" + Math.abs(arg)).slice(-minimum);\n                        if (arg < 0) s = '-' + s;\n                    } else {\n                        s = (\"          \" + s).slice(-minimum);\n                    }\n                }\n                if (precision) {\n                    arg = Math.trunc((arg - Math.trunc(arg)) * Math.pow(10, precision));\n                    s += '.' + (\"0000000000\" + Math.abs(arg)).slice(-precision);\n                }\n                buffer += s;\n                break;\n\n            case 'c':\n                arg = String.fromCharCode(arg);\n                /* falls through */\n\n            case 's':\n                while (arg.length < minimum) {\n                    if (flags == '-') {\n                        arg += ' ';\n                    } else {\n                        arg = ' ' + arg;\n                    }\n                }\n                buffer += arg;\n                break;\n\n            case 'X':\n                ach = \"0123456789ABCDEF\";\n                /* falls through */\n\n            case 'x':\n                if (!ach) ach = \"0123456789abcdef\";\n                s = \"\";\n                do {\n                    s = ach[arg & 0xf] + s;\n                    arg >>>= 4;\n                } while (--minimum > 0 || arg);\n                buffer += s;\n                break;\n\n            default:\n                /*\n                 * The supported ANSI C set of conversions: \"dioxXucsfeEgGpn%\"\n                 */\n                buffer += \"(unrecognized printf conversion %\" + conversion + \")\";\n                break;\n            }\n        }\n\n        buffer += aParts[iPart];\n        return buffer;\n    }\n}\n\n/*\n * Types recognized and supported by selected functions (eg, Computer.getMachineParm())\n */\nComponent.TYPE = {\n    NUMBER:     \"number\",\n    OBJECT:     \"object\",\n    STRING:     \"string\"\n};\n\n/*\n * These are the standard PRINT values you can pass as an optional argument to println(); in reality,\n * you can pass anything you want, because they are simply prepended to the message, although PROGRESS\n * messages may also be merged with earlier similar messages to keep the output buffer under control.\n */\nComponent.PRINT = {\n    ERROR:      \"error\",\n    NOTICE:     \"notice\",\n    PROGRESS:   \"progress\",\n    SCRIPT:     \"script\",\n    WARNING:    \"warning\"\n};\n\n/*\n * Every component created on the current page is recorded in this array (see Component.add()),\n * enabling any component to locate another component by ID (see Component.getComponentByID())\n * or by type (see Component.getComponentByType()).\n *\n * Every machine on the page are now recorded as well, by their machine ID.  We then record the\n * various resources used by that machine.\n *\n * Includes a fallback for non-browser-based environments (ie, Node).  TODO: This will need to be\n * tailored to Node, probably using the global object instead of the window object, if we ever want\n * to support multi-machine configs in that environment.\n */\nif (window) {\n    if (!window['PCjs']) window['PCjs'] = {};\n    if (!window['PCjs']['Machines']) window['PCjs']['Machines'] = {};\n    if (!window['PCjs']['Components']) window['PCjs']['Components'] = [];\n    if (!window['PCjs']['Commands']) window['PCjs']['Commands'] = {};\n}\nComponent.machines = window? window['PCjs']['Machines'] : {};\nComponent.components = window? window['PCjs']['Components'] : [];\nComponent.commands = window? window['PCjs']['Commands'] : {};\n\nComponent.asyncCommands = [\n    'hold', 'sleep', 'wait'\n];\nComponent.globalCommands = {\n    'alert': Component.scriptAlert,\n    'sleep': Component.scriptSleep\n};\nComponent.componentCommands = {\n    'select':   Component.scriptSelect\n};\nComponent.printBuffer = \"\";\n\n/*\n * The following polyfills provide ES5 functionality that's missing in older browsers (eg, IE8),\n * allowing PCjs apps to run without slamming into exceptions; however, due to the lack of HTML5 canvas\n * support in those browsers, all you're likely to see are \"soft\" errors (eg, \"Missing <canvas> support\").\n *\n * Perhaps we can implement a text-only faux video display for a fun retro-browser experience someday.\n *\n * TODO: Come up with a better place to put these polyfills.  We will likely have more if we decide to\n * make the leap from ES5 to ES6 features.\n */\n\n/*\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\n */\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(obj, start) {\n        for (var i = (start || 0), j = this.length; i < j; i++) {\n            if (this[i] === obj) { return i; }\n        }\n        return -1;\n    }\n}\n\n/*\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\n */\nif (!Array.isArray) {\n    Array.isArray = function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}\n\n/*\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n */\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function(obj) {\n        if (typeof this != \"function\") {\n            // Closest thing possible to the ECMAScript 5 internal IsCallable function\n            throw new TypeError(\"Function.prototype.bind: non-callable object\");\n        }\n        var args = Array.prototype.slice.call(arguments, 1);\n        var fToBind = this;\n        var fnNOP = /** @constructor */ (function() {});\n        var fnBound = function() {\n            return fToBind.apply(this instanceof fnNOP && obj? this : obj, args.concat(Array.prototype.slice.call(arguments)));\n        };\n        fnNOP.prototype = this.prototype;\n        fnBound.prototype = new fnNOP();\n        return fnBound;\n    };\n}\n\n\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/defines.js (C) Jeff Parsons 2012-2017\n */\n\n/**\n * @define {string}\n */\nvar APPCLASS = \"c1pjs\";         // this @define is the default application class (eg, \"pcx86\", \"c1pjs\")\n\n/**\n * @define {string}\n */\nvar APPNAME = \"C1Pjs\";          // this @define is the default application name (eg, \"PCx86\", \"C1Pjs\")\n\n/**\n * @define {boolean}\n *\n * WARNING: DEBUGGER needs to accurately reflect whether or not the Debugger component is (or will be) loaded.\n * In the compiled case, we rely on the Closure Compiler to override DEBUGGER as appropriate.  When it's *false*,\n * nearly all of debugger.js will be conditionally removed by the compiler, reducing it to little more than a\n * \"type skeleton\", which also solves some type-related warnings we would otherwise have if we tried to remove\n * debugger.js from the compilation process altogether.\n *\n * However, when we're in \"development mode\" and running uncompiled code in debugger-less configurations,\n * I would like to skip loading debugger.js altogether.  When doing that, we must ALSO arrange for an additional file\n * (nodebugger.js) to be loaded immediately after this file, which *explicitly* overrides DEBUGGER with *false*.\n */\nvar DEBUGGER = true;            // this @define is overridden by the Closure Compiler to remove Debugger-related support\n\n/*\n * Combine all the shared globals and machine-specific globals into one machine-specific global object,\n * which all machine components should start using; eg: \"if (C1PJS.DEBUG) ...\" instead of \"if (DEBUG) ...\".\n */\nvar C1PJS = {\n    APPCLASS:    APPCLASS,\n    APPNAME:     APPNAME,\n    APPVERSION:  APPVERSION,    // shared\n    COMPILED:    COMPILED,      // shared\n    CSSCLASS:    CSSCLASS,      // shared\n    DEBUG:       DEBUG,         // shared\n    DEBUGGER:    DEBUGGER,\n    MAXDEBUG:    MAXDEBUG,      // shared\n    PRIVATE:     PRIVATE,       // shared\n    SITEHOST:    SITEHOST,      // shared\n    XMLVERSION:  XMLVERSION     // shared\n};\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/panel.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PPanel extends Component {\n    /**\n     * C1PPanel(parmsPanel)\n     *\n     * The Panel component has no required (parmsPanel) properties.\n     *\n     * @this {C1PPanel}\n     * @param {Object} parmsPanel\n     */\n    constructor(parmsPanel)\n    {\n        super(\"C1PPanel\", parmsPanel);\n\n        this.flags.powered = false;\n    }\n\n    /**\n     * The Panel doesn't have any bindings of its own; it passes along all binding requests to\n     * the Computer, CPU, Keyboard and Debugger components. The order shouldn't matter, since any\n     * component that doesn't recognize the specified binding should simply ignore it.\n     *\n     * @this {C1PPanel}\n     * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\", \"canvas\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"reset\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        if (this.cmp && this.cmp.setBinding(sHTMLType, sBinding, control, sValue)) return true;\n        if (this.cpu && this.cpu.setBinding(sHTMLType, sBinding, control, sValue)) return true;\n        if (this.kbd && this.kbd.setBinding(sHTMLType, sBinding, control, sValue)) return true;\n        if (DEBUGGER && this.dbg && this.dbg.setBinding(sHTMLType, sBinding, control, sValue)) return true;\n        return super.setBinding(sHTMLType, sBinding, control, sValue);\n    }\n\n    /**\n     * @this {C1PPanel}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            this.cmp = cmp;\n            this.cpu = cmp.getComponentByType(\"cpu\");\n            this.kbd = cmp.getComponentByType(\"keyboard\");\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n            C1PPanel.init();\n        }\n    }\n\n    /**\n     * C1PPanel.init()\n     *\n     * This function operates on every HTML element of class \"panel\", extracting the\n     * JSON-encoded parameters for the C1PPanel constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PPanel component, and then binding\n     * any associated HTML controls to the new component.\n     *\n     * NOTE: Unlike most other component init() functions, this one is designed to be\n     * called multiple times: once at load time, so that we can binding our print()\n     * function to the panel's output control ASAP, and again when the C1PComputer component\n     * is verifying that all components are ready and invoking their setPower() functions.\n     *\n     * Our setPower() method gives us a second opportunity to notify any components that\n     * that might care (eg, C1PCPU, C1PKeyboard, and C1PDebugger) that we have some controls\n     * they might want to use.\n     */\n    static init()\n    {\n        var fReady = false;\n        var aePanels = Component.getElementsByClass(document, C1PJS.APPCLASS, \"panel\");\n        for (var iPanel=0; iPanel < aePanels.length; iPanel++) {\n            var ePanel = aePanels[iPanel];\n            var parmsPanel = Component.getComponentParms(ePanel);\n            var panel = Component.getComponentByID(parmsPanel['id']);\n            if (!panel) {\n                fReady = true;\n                panel = new C1PPanel(parmsPanel);\n            }\n            Component.bindComponentControls(panel, ePanel, C1PJS.APPCLASS);\n            if (fReady) panel.setReady();\n        }\n    }\n}\n\n/*\n * Initialize every Panel module on the page.\n */\nWeb.onInit(C1PPanel.init);\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/cpu.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PCPU extends Component {\n    /**\n     * C1PCPU(parmsCPU)\n     *\n     * The C1PCPU object has one component-specific initialization property:\n     *\n     *      autoStart: true to automatically start, false to not, or null (default)\n     *      to make the autoStart decision based on whether or not a Debugger is\n     *      installed (if there's no Debugger AND no \"Run\" button, then auto-start,\n     *      otherwise don't)\n     *\n     * It is hard-coded to simulate a 6502 microprocessor, but it also contains\n     * hooks into other components for communication with the outside world (eg,\n     * Panel and Debugger components). This is a logical simulation, not a physical\n     * simulation, and performance is important, so we take lots of liberties; any\n     * idiosyncrasies of actual 6502 hardware may not be simulated here, unless it\n     * affects the accuracy of the simulation when running actual 6502 software.\n     *\n     * @this {C1PCPU}\n     * @param {Object} parmsCPU\n     */\n    constructor(parmsCPU)\n    {\n        super(\"C1PCPU\", parmsCPU);\n\n        this.clearRegs();\n        this.flags.powered = false;\n        this.flags.running = false;\n        this.fAutoStart = parmsCPU[\"autoStart\"];\n\n        /*\n         * speed is a number from 0 to 2, where 0 means run as close to 1Mhz as possible,\n         * 1 means run at the fastest safe speed, and 2 means run at maximum speed.\n         *\n         * It's updated via the setSpeed() function, which the Debugger's \"option\" command\n         * uses to adjust the virtual speed (eg, \"o slow\", \"o fast\").  There may also\n         * be a button present to control the speed as well (using the \"setSpeed\" binding).\n         */\n        this.SPEED_SLOW = 0;        // see this.mhzSlow\n        this.SPEED_FAST = 1;        // see this.mhzFast\n        this.SPEED_MAX  = 2;\n        this.speed = this.SPEED_SLOW;\n        this.nCyclesPerSecond = 1000000;\n\n        /*\n         * Additional values that control the overall speed of the simulated hardware,\n         * and the frequency at which various updates should occur.  There are no UI\n         * mechanisms for tweaking these values (yet).\n         *\n         * NOTE: Use of the term \"second\" below refers to a virtual CPU second, consisting of\n         * 1 million simulated cycles.  The values below are used to divide those 1 million\n         * cycles into intervals of \"work\", and as long we are limiting the simulation to 1Mhz\n         * per ACTUAL second, then 1 virtual second == 1 real second.\n         *\n         * However, if the setSpeed() function is used to lift the 1Mhz limit, then 1 virtual\n         * second may become much shorter, which is why you may briefly notice the video and/or\n         * status (control panel) updates occurring more frequently. To compensate, calcCycles()\n         * will automatically scale these values if a recent speed recalculation reveals that\n         * we're running significantly faster than 1Mhz.\n         */\n        this.nYieldsPerSecond = 30;\n        this.nVideoUpdatesPerSecond = 30;\n        this.nStatusUpdatesPerSecond = 5;\n        this.mhzSlow = 1;\n        this.mhzFast = 8;\n        this.aSpeeds = [\"Slow\", \"Fast\", \"Max\"];\n        this.aSpeedDescs = [\"(\" + this.mhzSlow + \"Mhz)\", \"(up to \" + this.mhzFast + \"Mhz)\", \"(unlimited)\"];\n\n        /*\n         * Lists of notification handlers: aReadNotify and aWriteNotify are lists (ie, Arrays)\n         * of 4-element sub-arrays that, in turn, contain:\n         *\n         *      [0]: starting address of memory range to monitor\n         *      [1]: ending address of memory range to monitor (inclusive)\n         *      [2]: registered component\n         *      [3]: registered function to call for every read/write from/to memory in that range\n         *\n         * The virtual Serial Port and virtual Keyboard components use these handlers to trap\n         * references to their respective memory-based \"ports\".  Also, the ROM component uses it\n         * to \"repair\" any writes to its address range, since memory is one big array, and arrays\n         * don't support \"write-only\" regions.\n         *\n         * NOTE: the Video component does NOT use notification handlers, because video memory\n         * is written (and occasionally read) far too frequently for that to be efficient.  We\n         * just let the CPU pound on it like any other chunk of memory, and then make periodic\n         * calls directly to the Video component to refresh all portions of the video buffer\n         * that have changed since the last refresh. See displayVideo() for more details.\n         *\n         * WARNING: Write notifications currently do not catch STACK writes (ie, BRK, JSR, PHA and\n         * PHP instructions), because I simply haven't added the necessary code.  Besides, JSR is\n         * one of the most-executed instructions, so I'd rather not slow it down. Note that this\n         * STACK write limitation affects both the CPU's write-notification handlers AND the Debugger's\n         * write breakpoints.\n         */\n        this.aReadNotify = [];\n        this.aWriteNotify = [];\n\n        /*\n         * To speed up the processing of read and write notification handlers, we keep track of\n         * lower and upper address bounds for each set.  These variables maintain those bounds.\n         * They are initialized to values outside the accessible range of addresses.\n         */\n        this.addrReadLower = 0x10000;\n        this.addrReadUpper = 0x0;\n        this.addrWriteLower = 0x10000;\n        this.addrWriteUpper = 0x0;\n\n        /*\n         * Processor status register (P) flag masks\n         */\n        this.BIT_PN = 0x80;     // N = sign\n        this.BIT_PV = 0x40;     // V = overflow\n        this.BIT_PB = 0x10;     // B = break\n        this.BIT_PD = 0x08;     // D = decimal\n        this.BIT_PI = 0x04;     // I = interrupt\n        this.BIT_PZ = 0x02;     // Z = zero\n        this.BIT_PC = 0x01;     // C = carry\n\n     // this.VECTOR_NMI     = 0xfffa;\n        this.VECTOR_RESET   = 0xfffc;\n     // this.VECTOR_IRQ     = 0xfffe;\n\n        /*\n         * Popular opcodes\n         */\n        this.OP_JSR         = 0x20;\n\n        /*\n         * opSim operation codes\n         */\n        this.OP_SIM         = 0x02;\n        this.SIMOP_HLT      = 0x00;\n        this.SIMOP_MSG      = 0x01;\n\n        /*\n         * This 256-entry array of opcode functions is at the heart of the CPU engine: step(n).\n         *\n         * It might be worth trying a switch() statement instead, to see how the performance compares,\n         * but I suspect that will vary quite a bit across JavaScript engines; for now, I'm putting my\n         * money on array lookup.\n         */\n        this.aOpcodeFuncs = [\n            this.opBRK,         // 0x00\n            this.opORAindx,     // 0x01\n            this.opSim,         // 0x02\n            this.opUndefined,   // 0x03\n            this.opUndefined,   // 0x04\n            this.opORAzp,       // 0x05\n            this.opASLzp,       // 0x06\n            this.opUndefined,   // 0x07\n            this.opPHP,         // 0x08\n            this.opORAimm,      // 0x09\n            this.opASLacc,      // 0x0a\n            this.opUndefined,   // 0x0b\n            this.opUndefined,   // 0x0c\n            this.opORAabs,      // 0x0d\n            this.opASLabs,      // 0x0e\n            this.opUndefined,   // 0x0f\n            this.opBPL,         // 0x10\n            this.opORAindy,     // 0x11\n            this.opUndefined,   // 0x12\n            this.opUndefined,   // 0x13\n            this.opUndefined,   // 0x14\n            this.opORAzpx,      // 0x15\n            this.opASLzpx,      // 0x16\n            this.opUndefined,   // 0x17\n            this.opCLC,         // 0x18\n            this.opORAabsy,     // 0x19\n            this.opUndefined,   // 0x1a\n            this.opUndefined,   // 0x1b\n            this.opUndefined,   // 0x1c\n            this.opORAabsx,     // 0x1d\n            this.opASLabsx,     // 0x1e\n            this.opUndefined,   // 0x1f\n            this.opJSRabs,      // 0x20\n            this.opANDindx,     // 0x21\n            this.opUndefined,   // 0x22\n            this.opUndefined,   // 0x23\n            this.opBITzp,       // 0x24\n            this.opANDzp,       // 0x25\n            this.opROLzp,       // 0x26\n            this.opUndefined,   // 0x27\n            this.opPLP,         // 0x28\n            this.opANDimm,      // 0x29\n            this.opROLacc,      // 0x2a\n            this.opUndefined,   // 0x2b\n            this.opBITabs,      // 0x2c\n            this.opANDabs,      // 0x2d\n            this.opROLabs,      // 0x2e\n            this.opUndefined,   // 0x2f\n            this.opBMI,         // 0x30\n            this.opANDindy,     // 0x31\n            this.opUndefined,   // 0x32\n            this.opUndefined,   // 0x33\n            this.opUndefined,   // 0x34\n            this.opANDzpx,      // 0x35\n            this.opROLzpx,      // 0x36\n            this.opUndefined,   // 0x37\n            this.opSEC,         // 0x38\n            this.opANDabsy,     // 0x39\n            this.opUndefined,   // 0x3a\n            this.opUndefined,   // 0x3b\n            this.opUndefined,   // 0x3c\n            this.opANDabsx,     // 0x3d\n            this.opROLabsx,     // 0x3e\n            this.opUndefined,   // 0x3f\n            this.opRTI,         // 0x40\n            this.opEORindx,     // 0x41\n            this.opUndefined,   // 0x42\n            this.opUndefined,   // 0x43\n            this.opUndefined,   // 0x44\n            this.opEORzp,       // 0x45\n            this.opLSRzp,       // 0x46\n            this.opUndefined,   // 0x47\n            this.opPHA,         // 0x48\n            this.opEORimm,      // 0x49\n            this.opLSRacc,      // 0x4a\n            this.opUndefined,   // 0x4b\n            this.opJMPimm16,    // 0x4c\n            this.opEORabs,      // 0x4d\n            this.opLSRabs,      // 0x4e\n            this.opUndefined,   // 0x4f\n            this.opBVC,         // 0x50\n            this.opEORindy,     // 0x51\n            this.opUndefined,   // 0x52\n            this.opUndefined,   // 0x53\n            this.opUndefined,   // 0x54\n            this.opEORzpx,      // 0x55\n            this.opLSRzpx,      // 0x56\n            this.opUndefined,   // 0x57\n            this.opCLI,         // 0x58\n            this.opEORabsy,     // 0x59\n            this.opUndefined,   // 0x5a\n            this.opUndefined,   // 0x5b\n            this.opUndefined,   // 0x5c\n            this.opEORabsx,     // 0x5d\n            this.opLSRabsx,     // 0x5e\n            this.opUndefined,   // 0x5f\n            this.opRTS,         // 0x60\n            this.opADCindx,     // 0x61\n            this.opUndefined,   // 0x62\n            this.opUndefined,   // 0x63\n            this.opUndefined,   // 0x64\n            this.opADCzp,       // 0x65\n            this.opRORzp,       // 0x66\n            this.opUndefined,   // 0x67\n            this.opPLA,         // 0x68\n            this.opADCimm,      // 0x69\n            this.opRORacc,      // 0x6a\n            this.opUndefined,   // 0x6b\n            this.opJMPabs16,    // 0x6c\n            this.opADCabs,      // 0x6d\n            this.opRORabs,      // 0x6e\n            this.opUndefined,   // 0x6f\n            this.opBVS,         // 0x70\n            this.opADCindy,     // 0x71\n            this.opUndefined,   // 0x72\n            this.opUndefined,   // 0x73\n            this.opUndefined,   // 0x74\n            this.opADCzpx,      // 0x75\n            this.opRORzpx,      // 0x76\n            this.opUndefined,   // 0x77\n            this.opSEI,         // 0x78\n            this.opADCabsy,     // 0x79\n            this.opUndefined,   // 0x7a\n            this.opUndefined,   // 0x7b\n            this.opUndefined,   // 0x7c\n            this.opADCabsx,     // 0x7d\n            this.opRORabsx,     // 0x7e\n            this.opUndefined,   // 0x7f\n            this.opUndefined,   // 0x80\n            this.opSTAindx,     // 0x81\n            this.opUndefined,   // 0x82\n            this.opUndefined,   // 0x83\n            this.opSTYzp,       // 0x84\n            this.opSTAzp,       // 0x85\n            this.opSTXzp,       // 0x86\n            this.opUndefined,   // 0x87\n            this.opDEY,         // 0x88\n            this.opUndefined,   // 0x89\n            this.opTXA,         // 0x8a\n            this.opUndefined,   // 0x8b\n            this.opSTYabs,      // 0x8c\n            this.opSTAabs,      // 0x8d\n            this.opSTXabs,      // 0x8e\n            this.opUndefined,   // 0x8f\n            this.opBCC,         // 0x90\n            this.opSTAindy,     // 0x91\n            this.opUndefined,   // 0x92\n            this.opUndefined,   // 0x93\n            this.opSTYzpx,      // 0x94\n            this.opSTAzpx,      // 0x95\n            this.opSTXzpy,      // 0x96\n            this.opUndefined,   // 0x97\n            this.opTYA,         // 0x98\n            this.opSTAabsy,     // 0x99\n            this.opTXS,         // 0x9a\n            this.opUndefined,   // 0x9b\n            this.opUndefined,   // 0x9c\n            this.opSTAabsx,     // 0x9d\n            this.opUndefined,   // 0x9e\n            this.opUndefined,   // 0x9f\n            this.opLDYimm,      // 0xa0\n            this.opLDAindx,     // 0xa1\n            this.opLDXimm,      // 0xa2\n            this.opUndefined,   // 0xa3\n            this.opLDYzp,       // 0xa4\n            this.opLDAzp,       // 0xa5\n            this.opLDXzp,       // 0xa6\n            this.opUndefined,   // 0xa7\n            this.opTAY,         // 0xa8\n            this.opLDAimm,      // 0xa9\n            this.opTAX,         // 0xaa\n            this.opUndefined,   // 0xab\n            this.opLDYabs,      // 0xac\n            this.opLDAabs,      // 0xad\n            this.opLDXabs,      // 0xae\n            this.opUndefined,   // 0xaf\n            this.opBCS,         // 0xb0\n            this.opLDAindy,     // 0xb1\n            this.opUndefined,   // 0xb2\n            this.opUndefined,   // 0xb3\n            this.opLDYzpx,      // 0xb4\n            this.opLDAzpx,      // 0xb5\n            this.opLDXzpy,      // 0xb6\n            this.opUndefined,   // 0xb7\n            this.opCLV,         // 0xb8\n            this.opLDAabsy,     // 0xb9\n            this.opTSX,         // 0xba\n            this.opUndefined,   // 0xbb\n            this.opLDYabsx,     // 0xbc\n            this.opLDAabsx,     // 0xbd\n            this.opLDXabsy,     // 0xbe\n            this.opUndefined,   // 0xbf\n            this.opCPYimm,      // 0xc0\n            this.opCMPindx,     // 0xc1\n            this.opUndefined,   // 0xc2\n            this.opUndefined,   // 0xc3\n            this.opCPYzp,       // 0xc4\n            this.opCMPzp,       // 0xc5\n            this.opDECzp,       // 0xc6\n            this.opUndefined,   // 0xc7\n            this.opINY,         // 0xc8\n            this.opCMPimm,      // 0xc9\n            this.opDEX,         // 0xca\n            this.opUndefined,   // 0xcb\n            this.opCPYabs,      // 0xcc\n            this.opCMPabs,      // 0xcd\n            this.opDECabs,      // 0xce\n            this.opUndefined,   // 0xcf\n            this.opBNE,         // 0xd0\n            this.opCMPindy,     // 0xd1\n            this.opUndefined,   // 0xd2\n            this.opUndefined,   // 0xd3\n            this.opUndefined,   // 0xd4\n            this.opCMPzpx,      // 0xd5\n            this.opDECzpx,      // 0xd6\n            this.opUndefined,   // 0xd7\n            this.opCLD,         // 0xd8\n            this.opCMPabsy,     // 0xd9\n            this.opUndefined,   // 0xda\n            this.opUndefined,   // 0xdb\n            this.opUndefined,   // 0xdc\n            this.opCMPabsx,     // 0xdd\n            this.opDECabsx,     // 0xde\n            this.opUndefined,   // 0xdf\n            this.opCPXimm,      // 0xe0\n            this.opSBCindx,     // 0xe1\n            this.opUndefined,   // 0xe2\n            this.opUndefined,   // 0xe3\n            this.opCPXzp,       // 0xe4\n            this.opSBCzp,       // 0xe5\n            this.opINCzp,       // 0xe6\n            this.opUndefined,   // 0xe7\n            this.opINX,         // 0xe8\n            this.opSBCimm,      // 0xe9\n            this.opNOP,         // 0xea\n            this.opUndefined,   // 0xeb\n            this.opCPXabs,      // 0xec\n            this.opSBCabs,      // 0xed\n            this.opINCabs,      // 0xee\n            this.opUndefined,   // 0xef\n            this.opBEQ,         // 0xf0\n            this.opSBCindy,     // 0xf1\n            this.opUndefined,   // 0xf2\n            this.opUndefined,   // 0xf3\n            this.opUndefined,   // 0xf4\n            this.opSBCzpx,      // 0xf5\n            this.opINCzpx,      // 0xf6\n            this.opUndefined,   // 0xf7\n            this.opSED,         // 0xf8\n            this.opSBCabsy,     // 0xf9\n            this.opUndefined,   // 0xfa\n            this.opUndefined,   // 0xfb\n            this.opUndefined,   // 0xfc\n            this.opSBCabsx,     // 0xfd\n            this.opINCabsx,     // 0xfe\n            this.opUndefined    // 0xff\n        ];\n        /*\n         * This is a 256-byte array of cycle counts, indexed by opcode.\n         * Obviously, true cycle counts are a bit more complicated, but this\n         * gets us most of the way to an authentic-feeling simulation.\n         *\n         * NOTE: BCD functions now account for an extra cycle, and branches\n         * now account for an extra cycle whenever the branch is taken.\n         * However, branches still don't add an extra cycle whenever the branch\n         * crosses a page boundary.\n         *\n         * The other gaping hole in our cycle-counting is accounting for all\n         * page-boundary penalties.  Ideally, that's just a matter of checking\n         * MODE_ABSX, MODE_ABSY, and MODE_INDY instructions for EA straddling\n         * a page boundary--but is it more complicated than that? What if the\n         * criteria is not the final EA, but whether the pre-indexing and\n         * post-indexing EAs are in different pages? I also need to confirm\n         * whether any other situations merit checking (eg, when a 2 or 3-byte\n         * instruction straddles a page boundary).\n         */\n        this.aOpcodeCycles = [\n            7,6,0,0,0,3,5,0,3,2,2,0,0,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            3,6,0,0,3,3,5,0,4,2,2,0,4,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            6,6,0,0,0,3,5,0,3,2,2,0,3,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            6,6,0,0,0,3,5,0,4,2,2,0,5,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            0,6,0,0,3,3,3,0,2,0,2,0,4,4,4,0,\n            2,5,0,0,4,4,4,0,2,4,2,0,0,4,0,0,\n            2,6,2,0,3,3,3,0,2,2,2,0,4,4,4,0,\n            2,5,0,0,4,4,4,0,2,4,2,0,4,4,4,0,\n            2,6,0,0,3,3,5,0,2,2,2,0,4,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0,\n            2,6,0,0,3,3,5,0,2,2,2,0,4,4,6,0,\n            2,5,0,0,0,4,6,0,2,4,0,0,0,4,7,0\n        ];\n    }\n\n    /**\n     * reset(fPowerOn)\n     *\n     * Note that we follow the same model here as other selected reset() handlers; for example, Video.reset()\n     * accepts an fPowerOn parameter to govern what's initially displayed on the video screen.\n     *\n     * @this {C1PCPU}\n     * @param {boolean|undefined} fPowerOn is true for the initial reset, so that if the Debugger isn't\n     * loaded, we can elect to start running.  Under any other circumstances (such as whenever Computer.reset()\n     * is called), \"auto-run\" is not a good idea, and can actually introduce bugs (eg, multiple run() timers).\n     */\n    reset(fPowerOn)\n    {\n        if (this.flags.running) {\n            this.halt();\n        }\n        this.clearRegs();\n        this.regPC = this.getWord(this.VECTOR_RESET);\n        this.clearError();              // clear any fatal error/exception\n        /*\n         * If there's a Debugger, notify Debugger.reset(); otherwise, start running\n         */\n        if (DEBUGGER && this.dbg) {\n            this.dbg.reset();\n        }\n        else if (fPowerOn) {\n            if (this.fAutoStart === true || this.fAutoStart === null && (!DEBUGGER || !this.dbg) && this.bindings[\"run\"] === undefined) {\n                this.run();             // start running automatically on the initial power-up, assuming there's no Debugger\n            }\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"run\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        var fBound = false;\n        switch(sBinding) {\n            case \"run\":\n                this.bindings[sBinding] = control;\n                control.onclick = function(cpu) {\n                    return function() {\n                        if (!cpu.flags.running) {\n                            cpu.run();\n                        } else {\n                            cpu.halt();\n                        }\n                    };\n                }(this);\n                fBound = true;\n                break;\n            case \"A\": case \"X\": case \"Y\": case \"S\": case \"PC\":\n            case \"C\": case \"Z\": case \"I\": case \"D\": case \"B\": case \"V\": case \"N\":\n            case \"speed\":\n                this.bindings[sBinding] = control;\n                fBound = true;\n                break;\n            case \"setSpeed\":\n                this.bindings[sBinding] = control;\n                control.onclick = function(cpu) {\n                    return function() {\n                        var speed = (cpu.speed >= cpu.SPEED_MAX? cpu.SPEED_SLOW : cpu.speed+1);\n                        cpu.setSpeed(speed, true);\n                    };\n                }(this);\n                fBound = true;\n                break;\n            default:\n                break;\n        }\n        return fBound;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     */\n    setBuffer(abMemory, start, end)\n    {\n        this.abMem = abMemory;\n        this.offMem = start;\n        this.cbMem = end - start + 1;\n        this.offLimit = this.offMem + this.cbMem;\n        if (this.offMem) {\n            /*\n             * It's not that we couldn't support an address buffer that starts at a non-zero offset;\n             * we simply have lots of code (eg, all the opcode handlers) that assumes offMem is zero,\n             * and therefore that abMem can be indexed by any of the CPU registers without adding offMem.\n             * All that code would have to be changed (at a slight performance penalty) if we couldn't\n             * make this assumption.\n             */\n            Component.error(\"unsupported CPU address buffer offset (\" + this.offMem + \")\");\n            return;\n        }\n        this.setReady();\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.cmp = cmp;\n            /*\n             * Attach the Debugger, if any, to the CPU, so that the CPU can periodically\n             * notify it as needed (when the CPU starts, stops, and executes instructions)\n             */\n            if (DEBUGGER) {\n                this.dbg = cmp.getComponentByType(\"debugger\");\n                if (this.dbg)\n                    this.dbg.init();\n            }\n            /*\n             * Attach the Video device to the CPU, so that the CPU can periodically update\n             * the video display via displayVideo(), as cycles permit.\n             */\n            var video = cmp.getComponentByType(\"video\");\n            if (video) {\n                this.displayVideo = function(v) {\n                    return function() {\n                        v.updateScreen();\n                    };\n                }(video);\n                this.setFocus = function(v) {\n                    return function() {\n                        v.setFocus();\n                    };\n                }(video);\n            }\n            this.flags.powered = true;\n            this.reset(true);\n            this.update();\n        }\n    }\n\n    /**\n     * Add a memory read-notification handler to the CPU's list of such handlers.\n     *\n     * @this {C1PCPU}\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn is called with the EA and PC values at the time of the write\n     */\n    addReadNotify(start, end, component, fn)\n    {\n        if (this.findNotify(this.aReadNotify, start, end, component, fn) < 0) {\n            if (this.addrReadLower > start)\n                this.addrReadLower = start;\n            if (this.addrReadUpper < end)\n                this.addrReadUpper = end;\n            this.aReadNotify.push([start, end, component, fn]);\n            if (DEBUG) this.log(\"addReadNotify(\" + Str.toHexWord(start) + \",\" + Str.toHexWord(end) + \",\" + component.id + \"): new read range: \" + Str.toHexWord(this.addrReadLower) + \"-\" + Str.toHexWord(this.addrReadUpper));\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addrRead is the EA value at the time of the read\n     * @param {number} [addrFrom] is the PC value at the time of the read;\n     * this will be undefined for read notifications triggered by assorted Debugger commands,\n     * so all handlers should be prepared for that as well.\n     */\n    checkReadNotify(addrRead, addrFrom)\n    {\n        for (var i=0; i < this.aReadNotify.length; i++) {\n            if (addrRead >= this.aReadNotify[i][0] && addrRead <= this.aReadNotify[i][1]) {\n                this.aReadNotify[i][3].call(this.aReadNotify[i][2], addrRead, addrFrom);\n            }\n        }\n    }\n\n    /**\n     * Remove a memory read-notification handler from the CPU's list of such handlers.\n     *\n     * @this {C1PCPU}\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn of previously added handler\n     * @return {boolean} true if remove was successful, false if the handler was not found\n     */\n    removeReadNotify(start, end, component, fn)\n    {\n        var aBounds = this.removeNotify(this.aReadNotify, start, end, component, fn);\n        if (aBounds.length == 4) {\n            this.addrReadLower = aBounds[2];\n            this.addrReadUpper = aBounds[3];\n            if (DEBUG) this.log(\"removeReadNotify(\" + Str.toHexWord(start) + \",\" + Str.toHexWord(end) + \",\" + component.id + \"): new read range: \" + Str.toHexWord(this.addrReadLower) + \"-\" + Str.toHexWord(this.addrReadUpper));\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Add a memory write-notification handler to the CPU's list of such handlers.\n     *\n     * @this {C1PCPU}\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn is called with the EA and PC values at the time of the write\n     */\n    addWriteNotify(start, end, component, fn)\n    {\n        if (this.findNotify(this.aWriteNotify, start, end, component, fn) < 0) {\n            if (this.addrWriteLower > start)\n                this.addrWriteLower = start;\n            if (this.addrWriteUpper < end)\n                this.addrWriteUpper = end;\n            this.aWriteNotify.push([start, end, component, fn]);\n            if (DEBUG) this.log(\"addWriteNotify(\" + Str.toHexWord(start) + \",\" + Str.toHexWord(end) + \",\" + component.id + \"): new write range: \" + Str.toHexWord(this.addrWriteLower) + \"-\" + Str.toHexWord(this.addrWriteUpper));\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addrWrite is the EA value at the time of the write\n     * @param {number} [addrFrom] is the PC value at the time of the write;\n     * this will be undefined for write notifications triggered by assorted Debugger commands,\n     * so all handlers should be prepared for that as well.\n     */\n    checkWriteNotify(addrWrite, addrFrom)\n    {\n        for (var i=0; i < this.aWriteNotify.length; i++) {\n            if (addrWrite >= this.aWriteNotify[i][0] && addrWrite <= this.aWriteNotify[i][1]) {\n                this.aWriteNotify[i][3].call(this.aWriteNotify[i][2], addrWrite, addrFrom);\n            }\n        }\n    }\n\n    /**\n     * Remove a memory write-notification handler from the CPU's list of such handlers.\n     *\n     * @this {C1PCPU}\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn of previously added handler\n     * @return {boolean} true if remove was successful, false if the handler was not found\n     */\n    removeWriteNotify(start, end, component, fn)\n    {\n        var aBounds = this.removeNotify(this.aWriteNotify, start, end, component, fn);\n        if (aBounds.length == 4) {\n            this.addrWriteLower = aBounds[2];\n            this.addrWriteUpper = aBounds[3];\n            if (DEBUG) this.log(\"removeWriteNotify(\" + Str.toHexWord(start) + \",\" + Str.toHexWord(end) + \",\" + component.id + \"): new write range: \" + Str.toHexWord(this.addrWriteLower) + \"-\" + Str.toHexWord(this.addrWriteUpper));\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find a memory notification handler from the given array of handlers\n     *\n     * @this {C1PCPU}\n     * @param {Array} aNotify array of handlers\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn of previously added handler\n     * @return {number} index of the matching handler, or -1 if not found\n     */\n    findNotify(aNotify, start, end, component, fn)\n    {\n        for (var i=0; i < aNotify.length; i++) {\n            if (aNotify[i][0] == start && aNotify[i][1] == end && aNotify[i][2] == component && aNotify[i][3] == fn) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Remove a memory notification handler from the given array of handlers\n     *\n     * @this {C1PCPU}\n     * @param {Array} aNotify array of handlers\n     * @param {number} start address\n     * @param {number} end address\n     * @param {Component} component\n     * @param {function(number,number)} fn of previously added handler\n     * @return {Array} bounds of previous handler ([0] and [1]) and new lower and upper address bounds ([2] and [3])\n     */\n    removeNotify(aNotify, start, end, component, fn)\n    {\n        var aBounds = [];\n        var i = this.findNotify(aNotify, start, end, component, fn);\n        if (i >= 0) {\n            aBounds.push(aNotify[i][0]);\n            aBounds.push(aNotify[i][1]);\n            aNotify.splice(i, 1);\n            var addrLower = 0x10000, addrUpper = 0x0;\n            for (i=0; i < aNotify.length; i++) {\n                if (addrLower > aNotify[i][0])\n                    addrLower = aNotify[i][0];\n                if (addrUpper < aNotify[i][1])\n                    addrUpper = aNotify[i][1];\n            }\n            aBounds.push(addrLower);\n            aBounds.push(addrUpper);\n        }\n        return aBounds;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} [speed] is one of: 0 (slow), 1 (fast) or 2 (maximum)\n     * @param {boolean} [fOnClick] is true if called from a click handler that might have stolen focus\n     * @desc Whenever the speed is changed, the running cycle count and corresponding start time must be reset,\n     * so that the next effective speed calculation obtains sensible results.  In fact, when run() initially calls\n     * setSpeed() with no parameters, that's all this function does (it doesn't change the current speed setting).\n     */\n    setSpeed(speed, fOnClick)\n    {\n        if (speed !== undefined) {\n            this.speed = speed;\n            if (this.bindings[\"setSpeed\"])\n                this.bindings[\"setSpeed\"].innerHTML = this.aSpeeds[speed >= 2? 0 : speed+1];\n            this.println(\"running at \" + this.aSpeeds[speed].toLowerCase() + \" speed \" + this.aSpeedDescs[speed]);\n            if (fOnClick) this.setFocus();\n        }\n        this.nRunCycles = 0;\n        this.msRunStart = Usr.getTime();\n        this.calcCycles();\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} nCycles\n     * @param {number} msElapsed\n     */\n    calcSpeed(nCycles, msElapsed)\n    {\n        if (msElapsed) {\n            this.mhz = Math.round(nCycles / ( msElapsed * 100)) / 10;\n            if (msElapsed >= 86400000)\n                this.setSpeed();        // reset all our counters once per day so that we never have to worry about overflow\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    displayVideo()\n    {\n        // Nothing to do until setPower() installs a replacement function\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    setFocus()\n    {\n        // Nothing to do until setPower() installs a replacement function\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {string} sReg\n     * @param {number} vReg\n     * @param {number} [len]\n     */\n    displayReg(sReg, vReg, len)\n    {\n        if (this.bindings[sReg] !== undefined) {\n            if (len === undefined) len = 1;\n            var s = \"0000\" + vReg.toString(16);\n            this.bindings[sReg].innerHTML = s.slice(s.length-len).toUpperCase();\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    displayStatus()\n    {\n        this.displayReg(\"A\", this.regA, 2);\n        this.displayReg(\"X\", this.regX, 2);\n        this.displayReg(\"Y\", this.regY, 2);\n        var regP = this.getRegP();\n        this.displayReg(\"C\", (regP & this.BIT_PC)? 1 : 0);\n        this.displayReg(\"Z\", (regP & this.BIT_PZ)? 1 : 0);\n        this.displayReg(\"I\", (regP & this.BIT_PI)? 1 : 0);\n        this.displayReg(\"D\", (regP & this.BIT_PD)? 1 : 0);\n        this.displayReg(\"B\", (regP & this.BIT_PB)? 1 : 0);\n        this.displayReg(\"V\", (regP & this.BIT_PV)? 1 : 0);\n        this.displayReg(\"N\", (regP & this.BIT_PN)? 1 : 0);\n        this.displayReg(\"S\", this.regS, 4);\n        this.displayReg(\"PC\", this.regPC, 4);\n        if (this.bindings[\"speed\"] && this.mhz) {\n            this.bindings[\"speed\"].innerHTML = this.mhz.toFixed(1) + \"Mhz\";\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @return {boolean}\n     */\n    isRunning()\n    {\n        return this.flags.running;\n    }\n\n    /**\n     * Calculate the number of cycles to process for each \"burst\" of CPU activity.  The size of a burst\n     * is driven by the following values:\n     *\n     *      nYieldsPerSecond (eg, 30)\n     *      nVideoUpdatesPerSecond (eg, 30)\n     *      nStatusUpdatesPerSecond (eg, 5)\n     *\n     * The largest of the above values forces the size of the burst to its smallest value.  Let's say that\n     * largest value is 30.  Assuming nCyclesPerSecond is 1,000,000, that results in bursts of 33,333 cycles.\n     *\n     * At the end of each burst, we subtract burst cycles from yield, video, and status cycle \"threshold\"\n     * counters. Whenever the \"next yield\" cycle counter goes to (or below) zero, we compare elapsed time\n     * to the time we expected the virtual hardware to take (eg, 1000ms/50 or 20ms), and if we still have time\n     * remaining, we sleep the remaining time (or 0ms if there's no remaining time), and then restart run().\n     *\n     * Similarly, whenever the \"next video update\" cycle counter goes to (or below) zero, we call displayVideo(),\n     * and whenever the \"next status update\" cycle counter goes to (or below) zero, we call displayStatus().\n     *\n     * @this {C1PCPU}\n     * @param {boolean} [fRecalc] is true if the caller wants to recalculate thresholds based on the\n     * most recent mhz calculation (see calcSpeed)\n     */\n    calcCycles(fRecalc)\n    {\n        /*\n         * Calculate the most cycles we're allowed to execute in a single \"burst\"\n         */\n        var nMostUpdatesPerSecond = this.nYieldsPerSecond;\n        if (nMostUpdatesPerSecond < this.nVideoUpdatesPerSecond) nMostUpdatesPerSecond = this.nVideoUpdatesPerSecond;\n        if (nMostUpdatesPerSecond < this.nStatusUpdatesPerSecond) nMostUpdatesPerSecond = this.nStatusUpdatesPerSecond;\n\n        /*\n         * Calculate \"per\" values for the yield, video update, and status update cycle counters\n         */\n        var vMultiplier = 1;\n        if (fRecalc && this.speed > this.SPEED_SLOW && this.mhz) vMultiplier = this.mhz;\n        if (vMultiplier > this.mhzFast && this.speed < this.SPEED_MAX) vMultiplier = this.mhzFast;\n\n        this.msPerYield = Math.round(1000/this.nYieldsPerSecond);\n        this.nCyclesPerBurst = Math.floor(this.nCyclesPerSecond / nMostUpdatesPerSecond * vMultiplier);\n        this.nCyclesPerYield = Math.floor(this.nCyclesPerSecond / this.nYieldsPerSecond * vMultiplier);\n        this.nCyclesPerVideoUpdate = Math.floor(this.nCyclesPerSecond / this.nVideoUpdatesPerSecond * vMultiplier);\n        this.nCyclesPerStatusUpdate = Math.floor(this.nCyclesPerSecond / this.nStatusUpdatesPerSecond * vMultiplier);\n\n        /*\n         * And initialize \"next\" yield, video update, and status update cycle \"threshold\" counters to those \"per\" values\n         */\n        if (!fRecalc) {\n            this.nCyclesNextYield = this.nCyclesPerYield;\n            this.nCyclesNextVideoUpdate = this.nCyclesPerVideoUpdate;\n            this.nCyclesNextStatusUpdate = this.nCyclesPerStatusUpdate;\n        }\n        this.nRecalcCycles = 0;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    calcStartTime()\n    {\n        if (this.nRecalcCycles >= this.nCyclesPerSecond) {\n            this.calcCycles(true);\n        }\n        this.nCyclesThisRun = 0;\n        this.msStartThisRun = Usr.getTime();\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @return {number}\n     */\n    calcRemainingTime()\n    {\n        var msCurrent = Usr.getTime();\n        var msYield = this.msPerYield;\n\n        if (this.nCyclesThisRun) {\n            /*\n             * Normally, we would assume we executed a full quota of work over msPerYield, but since the CPU\n             * now has the option of calling yieldCPU(), that might not be true.  If nCyclesThisRun is correct, then\n             * the ratio of nCyclesThisRun/nCyclesPerYield should represent the percentage of work we performed,\n             * and so applying that percentage to msPerYield should give us a better estimate of work vs. time.\n             */\n            msYield = Math.round(msYield * this.nCyclesThisRun / this.nCyclesPerYield);\n            // if (msYield < this.msPerYield) this.println(\"scaling msPerYield (\" + this.msPerYield + \") to msYield (\" + msYield + \")\");\n        }\n\n        var msElapsedThisRun = msCurrent - this.msStartThisRun;\n        var msRemainsThisRun = msYield - msElapsedThisRun;\n\n        /*\n         * We could pass only \"this run\" results to calcSpeed():\n         *\n         *      nCycles = this.nCyclesThisRun;\n         *      msElapsed = msElapsedThisRun;\n         *\n         * but it seems preferable to use longer time periods and hopefully get a more accurate speed.\n         *\n         * Also, if msRemainsThisRun >= 0 && this.speed == this.SPEED_SLOW, we could pass these results instead:\n         *\n         *      nCycles = this.nCyclesThisRun;\n         *      msElapsed = this.msPerYield;\n         *\n         * to insure that we display a smooth, constant 1Mhz.  But the displayed speed seems pretty steady as-is.\n         */\n        var nCycles = this.nRunCycles;\n        var msElapsed = msCurrent - this.msRunStart;\n\n        if (DEBUG && msRemainsThisRun < 0 && this.speed == this.SPEED_FAST) {\n            this.println(\"warning: updates @\" + msElapsedThisRun + \"ms (prefer \" + Math.round(msYield) + \"ms)\");\n        }\n\n        this.calcSpeed(nCycles, msElapsed);\n\n        if (msRemainsThisRun < 0) {\n            /*\n             * This is an easy case: it's taking more than 1 second to simulate 1Mhz,\n             * so all we can do is yield for as little time as possible (ie, 0ms) and hope the\n             * simulation is at least usable.\n             */\n            msRemainsThisRun = 0;\n        }\n        else {\n            if (this.speed == this.SPEED_FAST) {\n                /*\n                 * This case requires us to artificially limit the CPU speed.  calcSpeed()\n                 * already cranks up the number of cycles we process per burst, in proportion\n                 * to the effective mhz, so there isn't much to do here except sleep for\n                 * whatever time is in msRemainsThisRun.\n                 *\n                 * The artificial limit was chosen largely because it's not currently possible\n                 * for the keyboard component to inject keys fast enough to avoid duplicate\n                 * keystrokes at higher speeds. Perhaps with future improvements to the keyboard\n                 * component, this limit can be lifted.\n                 */\n                if (this.mhz <= this.mhzFast)\n                    msRemainsThisRun = 0;\n            }\n            else\n            if (this.speed == this.SPEED_MAX) {\n                /*\n                 * This is also an easy case: yield for as little time as possible (ie, 0ms), to execute\n                 * the maximum number of cycles per second.\n                 */\n                msRemainsThisRun = 0;\n            }\n        }\n\n        /*\n         * Last but not least, update nRecalcCycles, so that when run() starts up again and calls calcStartTime(),\n         * it'll be ready to decide if calcCycles() should be called again.\n         */\n        this.nRecalcCycles += this.nCyclesThisRun;\n\n        return msRemainsThisRun;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    run()\n    {\n        if (!this.setBusy(true)) {\n            this.update();\n            if (this.cmp) this.cmp.stop(this.msRunStart, this.nRunCycles);\n            return;\n        }\n        if (!this.flags.running) {\n            /*\n             *  setSpeed() without a speed parameter leaves the selected speed in place, but also resets the\n             *  cycle counter and timestamp for the current series of run() calls, calculates the maximum number\n             *  of cycles for each burst based on the last known effective CPU speed, and resets the nRecalcCycles\n             *  threshold counter.\n             */\n            this.setSpeed();\n            if (this.cmp) this.cmp.start();\n            this.flags.running = true;\n            if (this.bindings[\"run\"]) this.bindings[\"run\"].innerHTML = \"Halt\";\n            this.setFocus();\n        }\n        /*\n         *  calcStartTime() initializes the cycle counter and timestamp for this run() invocation, and optionally\n         *  recalculates the the maximum number of cycles for each burst if the nRecalcCycles threshold has been reached.\n         */\n        this.calcStartTime();\n        try {\n            do {\n                /*\n                 * NOTE: nCyclesPerBurst is how many cycles we WANT to run each iteration of step(), but that just\n                 * initializes nBurstCycles, which (after subtracting any remaining nStepCycles) is how many cycles\n                 * we ACTUALLY ran.\n                 */\n                this.step(this.nCyclesPerBurst);\n                /*\n                 * nCyclesThisRun is increased by nBurstCycles, plus any additional cycles step() processed after\n                 * its cycle count had reached zero (and conversely, minus any cycles that it still had yet to process);\n                 * ditto for nRunCycles, which is the cycle count since the CPU first started running.\n                 */\n                var nCycles = this.nBurstCycles - this.nStepCycles;\n                this.nRunCycles += nCycles;\n                this.nCyclesThisRun += nCycles;\n                /*\n                 * These step() cycle variables must be zeroed now, so that getCycles() always returns a valid cycle count.\n                 */\n                this.nBurstCycles = this.nStepCycles = 0;\n\n                this.nCyclesNextVideoUpdate -= this.nCyclesPerBurst;\n                if (this.nCyclesNextVideoUpdate <= 0) {\n                    this.nCyclesNextVideoUpdate += this.nCyclesPerVideoUpdate;\n                    this.displayVideo();\n                }\n\n                this.nCyclesNextStatusUpdate -= this.nCyclesPerBurst;\n                if (this.nCyclesNextStatusUpdate <= 0) {\n                    this.nCyclesNextStatusUpdate += this.nCyclesPerStatusUpdate;\n                    this.displayStatus();\n                }\n\n                this.nCyclesNextYield -= this.nCyclesPerBurst;\n                if (this.nCyclesNextYield <= 0) {\n                    this.nCyclesNextYield += this.nCyclesPerYield;\n                    break;\n                }\n            } while (this.flags.running);\n        }\n        catch (e) {\n            this.halt();\n            this.update();\n            this.setBusy(false);\n            this.setError(e.stack || e.message);\n            return;\n        }\n        setTimeout(function(cpu) { return function() {cpu.run();}; }(this), this.calcRemainingTime());\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} nMinCycles (0 implies a single-step, and therefore breakpoints should be ignored)\n     * @return {boolean|undefined} undefined indicates that the last instruction was not executed (eg,\n     * we hit an execution breakpoint), false implies a post-execution condition was triggered (eg, a write\n     * breakpoint), and true indicates successful completion of all requested cycles.\n     */\n    step(nMinCycles)\n    {\n        /*\n         * The Debugger uses fCompleted to determine if the instruction completed (true) or was interrupted\n         * by a breakpoint or some other exceptional condition (false). NOTE: this does NOT include thrown\n         * exceptions, which step() expects the caller to catch using its own exception handler.\n         *\n         * The CPU relies on the use of halt() rather than fCompleted, because the CPU never single-steps\n         * (ie, nMinCycles is always some large number), whereas the Debugger does.  And conversely, when the\n         * Debugger is single-stepping (even when performing multiple single-steps), fRunning is never set,\n         * so halt() would have no effect as far as the Debugger is concerned.\n         */\n        var fCompleted = true;\n\n        /*\n         * fDebugCheck is true if we need to \"check\" every instruction with the Debugger.  The Debugger will\n         * call cpu.step(n) with n == 0 if it's executing only ONE instruction (ie, the user just clicked the\n         * \"Step\" button, or they've issued a \"t\" or \"t1\" command).  Otherwise, it will call with n == 1\n         * (ie, the user is holding the \"Step\" button, or they've issued a \"t#\" command where # > 1).\n         *\n         * In the first case, we want to ignore (ie, \"step over\") any breakpoints; otherwise, the Debugger has\n         * no easy way of moving past a breakpoint (other than clearing it, of course).  In the second case,\n         * we want to honor any breakpoints, which in turn will set fCompleted to false and signal the Debugger\n         * to stop.\n         *\n         * Note that as a practical matter, both 0 and 1 are otherwise treated the same when it comes to the\n         * minimum number of cycles to run: one and only one instruction will execute, since every instruction\n         * consumes at least 1 cycle.\n         */\n        this.regEA = this.regEAWrite = -1;\n        var fDebugCheck = (DEBUGGER && nMinCycles && this.dbg && this.dbg.checksEnabled());\n\n        /*\n         * We move the minimum cycle count to nStepCycles (the number of cycles left to run), so that other\n         * methods have the ability to force that number to zero (eg, halt()), and thus we don't have to check\n         * some other criteria just to determine whether we should continue running or not.\n         */\n        this.nBurstCycles = this.nStepCycles = nMinCycles;\n        do {\n            var bOpCode = this.abMem[this.regPC];\n\n            if (fDebugCheck && !this.dbg.checkInstruction(this.regPC, bOpCode)) {\n                fCompleted = undefined;\n                this.halt();\n                break;\n            }\n\n            this.regPC++;\n            this.aOpcodeFuncs[bOpCode].call(this);\n\n            /*\n             * Assert that all register contents remain within their respective ranges.\n             */\n\n\n            /*\n             * WARNING: By making the following read-or-write test exclusive, we're not going to catch\n             * those situations where an instruction does BOTH. For example, JSR pushes the old PC\n             * (which, if we were tracking STACK writes, would set regEAWrite) and then fetches a new PC\n             * (which should set regEA).  However, that's a situation which, except for a peculiar\n             * combination of read and write breakpoints set by the Debugger, is one we simply don't care\n             * about.  Moreover, none of our opcode handlers currently set BOTH regEA and regEAWrite,\n             * so it would be completely pointless to check both conditions here.\n             *\n             * Since READS are FAR more common than WRITES, we check the common case first.  If the\n             * day comes that we implement opcode functions that set both regEA AND regEAWrite, then we'll\n             * want to remove the \"else\" below and stop making the read and write tests exclusive.\n             * If we don't, then some of those rare/unusual writes will either get missed or delayed.\n             *\n             * It's also worth mentioning here that not all instructions READ or WRITE (eg, INX, INY and\n             * others that are completely flag or register-bound).  It's a bit ironic that those instructions,\n             * which are typically the fastest, have to perform both the READ and WRITE tests below.  But\n             * on the plus side, both tests will fail, so they'll still get out of here faster than any of\n             * the other instructions.\n             */\n            if (this.regEA >= 0) {\n                /*\n                 * Serial emulation requires a read notification handler, and the keyboard may eventually\n                 * want one, too.\n                 */\n                if (this.regEA >= this.addrReadLower && this.regEA <= this.addrReadUpper) {\n                    this.checkReadNotify(this.regEA, this.regPC);\n                }\n                if (fDebugCheck && !this.dbg.checkMemoryRead(this.regEA)) {\n                    fCompleted = false;\n                    this.halt();\n                    break;\n                }\n                this.regEA = -1;\n            }\n            else if (this.regEAWrite >= 0) {\n                /*\n                 * We process the write notification handlers before the write breakpoint handlers,\n                 * because we don't want to leave any ROM (read-only memory) writes in place before we\n                 * (potentially) give up control.  Undoing every write to ROM address space is an essential\n                 * part of simulating the \"read-only\" behavior of ROM.\n                 *\n                 * Obviously, there are other write notification handlers as well (like the keyboard's),\n                 * which may sometimes do things we'd prefer to intercept first, but let's keep things simple.\n                 */\n                if (this.regEAWrite >= this.addrWriteLower && this.regEAWrite <= this.addrWriteUpper) {\n                    this.checkWriteNotify(this.regEAWrite, this.regPC);\n                }\n                if (fDebugCheck && !this.dbg.checkMemoryWrite(this.regEAWrite, this.abMem[this.regEAWrite])) {\n                    fCompleted = false;\n                    this.halt();\n                    break;\n                }\n                this.regEAWrite = -1;\n            }\n\n            this.nStepCycles -= this.aOpcodeCycles[bOpCode];\n\n        } while (this.nStepCycles > 0);\n\n        return fCompleted;\n    }\n\n    /**\n     * yieldCPU() is similar to halt() with regard to how it resets various cycle countdown values,\n     * but the CPU remains in a \"running\" state.\n     *\n     * @this {C1PCPU}\n     */\n    yieldCPU()\n    {\n        this.nCyclesNextYield = 0;          // this will break us out of run(), once we break out of step()\n        this.nBurstCycles -= this.nStepCycles;\n        this.nStepCycles = 0;               // this will break us out of step()\n    }\n\n    /**\n     * halt() is similar to yieldCPU(), but it doesn't need to zero nCyclesNextYield to break out of run();\n     * it simply needs to clear fRunning.\n     *\n     * @this {C1PCPU}\n     */\n    halt()\n    {\n        this.isBusy(true);\n        this.nBurstCycles -= this.nStepCycles;\n        this.nStepCycles = 0;\n        if (this.flags.running) {\n            this.flags.running = false;\n            if (this.bindings[\"run\"]) this.bindings[\"run\"].innerHTML = \"Run\";\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * This used to be performed at the end of every step(), but run() -- which relies upon step() -- needed to have\n     * more control over when these updates are performed.  However, for other callers of step(), such as the Debugger,\n     * the combination of step() + update() provides the old behavior.\n     */\n    update()\n    {\n        this.displayVideo();\n        this.displayStatus();\n    }\n\n    /**\n     * getCycles() returns the number of cycles executed so far.  Note that we can be called after\n     * a run() OR during a run(), perhaps from a handler triggered during the current run's step(),\n     * so nRunCycles must always be adjusted by number of cycles step() was asked to run (nBurstCycles),\n     * less the number of cycles it has yet to run (nStepCycles).\n     *\n     * nRunCycles is reset whenever the CPU is halted or the CPU speed is changed, so returning 0 when the\n     * CPU is stopped seems perfectly reasonable.  As a result, components that rely on getCycles() returning a\n     * steadily increasing number should also be prepared for a reset at any time (eg, the Keyboard's\n     * updateMemory() function).\n     *\n     * @this {C1PCPU}\n     * @return {number}\n     */\n    getCycles()\n    {\n        return (this.flags.running? this.nRunCycles + this.nBurstCycles - this.nStepCycles : 0);\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addr\n     * @return {number}\n     *\n     * Unlike the Debugger versions of these functions, these presume that addr is always valid,\n     * since it's internally generated, not user-supplied. Of course, we could still have internal\n     * bugs, so asserts are included, but they are present in DEBUG code only (automatically\n     * removed from RELEASE code).\n     *\n     * Moreover, it's unlikely we'll use this function much (unless performance becomes secondary\n     * to code size), since all the opCode functions should perform their own fetches, for obvious\n     * performance reasons.\n     */\n    getByte(addr)\n    {\n\n        var b = this.abMem[addr];\n\n        return b;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addr\n     * @return {number}\n     */\n    getWord(addr)\n    {\n\n        var w = this.abMem[addr] | (this.abMem[addr+1] << 8);\n\n        return w;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} addr\n     * @param {number} b\n     */\n    setByte(addr, b)\n    {\n\n\n        this.abMem[addr] = b;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @return {number}\n     */\n    getRegP()\n    {\n        /*\n         *  // C = LAZY_C;\n         *  this.regP = ((this.regP & 0xfe) | ((((this.regRC & 0x0100)))? 0x01 : 0));\n         *  // Z = LAZY_Z;\n         *  this.regP = ((this.regP & 0xfd) | ((((this.regRZ & 0xff) == 0))? 0x02 : 0));\n         *  // V = LAZY_V;\n         *  this.regP = ((this.regP & 0xbf) | (((((((this.regRV & 0xff) ^ this.regRU) ^ (this.regRV >> 1)) & 0x80) != 0))? 0x40 : 0));\n         *  // N = LAZY_N;\n         *  this.regP = ((this.regP & 0x7f) | ((((this.regRN & 0x80)))? 0x80 : 0));\n         */\n        var regP = ((this.regRC & 0x0100)? 0x01 : 0x00);\n        regP |= (!(this.regRZ & 0xff)? 0x02 : 0x00);\n        regP |= (((((this.regRV & 0xff) ^ this.regRU) ^ (this.regRV >> 1)) & 0x80)? 0x40 : 0x00);\n        regP |= ((this.regRN & 0x80)? 0x80 : 0x00);\n        return (this.regP & 0x3C) | regP;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the C flag\n     */\n    clearC()\n    {\n        this.regRC = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the C flag\n     */\n    setC()\n    {\n        this.regRC = 0x100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the N bit\n     */\n    clearN()\n    {\n        this.regRN = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the N bit\n     */\n    setN()\n    {\n        this.regRN = 0x80;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the V bit\n     */\n    clearV()\n    {\n        this.regRV = 0x00; this.regRU = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the V bit\n     */\n    setV()\n    {\n        this.regRV = 0x00; this.regRU = 0x80;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the Z bit\n     */\n    clearZ()\n    {\n        this.regRZ = 0x01;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the Z bit\n     */\n    setZ()\n    {\n        this.regRZ = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Set the BCD bit and install the BCD opcode handlers\n     */\n    setBCD()\n    {\n        this.regP |= 0x08;\n        this.aOpcodeFuncs[0x61] = this.opADCindxBCD;\n        this.aOpcodeFuncs[0x65] = this.opADCzpBCD;\n        this.aOpcodeFuncs[0x69] = this.opADCimmBCD;\n        this.aOpcodeFuncs[0x6d] = this.opADCabsBCD;\n        this.aOpcodeFuncs[0x71] = this.opADCindyBCD;\n        this.aOpcodeFuncs[0x75] = this.opADCzpxBCD;\n        this.aOpcodeFuncs[0x79] = this.opADCabsyBCD;\n        this.aOpcodeFuncs[0x7d] = this.opADCabsxBCD;\n        this.aOpcodeFuncs[0xe1] = this.opSBCindxBCD;\n        this.aOpcodeFuncs[0xe5] = this.opSBCzpBCD;\n        this.aOpcodeFuncs[0xe9] = this.opSBCimmBCD;\n        this.aOpcodeFuncs[0xed] = this.opSBCabsBCD;\n        this.aOpcodeFuncs[0xf1] = this.opSBCindyBCD;\n        this.aOpcodeFuncs[0xf5] = this.opSBCzpxBCD;\n        this.aOpcodeFuncs[0xf9] = this.opSBCabsyBCD;\n        this.aOpcodeFuncs[0xfd] = this.opSBCabsxBCD;\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * Clear the BCD bit and remove the BCD opcode handlers\n     */\n    clearBCD()\n    {\n        this.regP &= ~0x08;\n        this.aOpcodeFuncs[0x61] = this.opADCindx;\n        this.aOpcodeFuncs[0x65] = this.opADCzp;\n        this.aOpcodeFuncs[0x69] = this.opADCimm;\n        this.aOpcodeFuncs[0x6d] = this.opADCabs;\n        this.aOpcodeFuncs[0x71] = this.opADCindy;\n        this.aOpcodeFuncs[0x75] = this.opADCzpx;\n        this.aOpcodeFuncs[0x79] = this.opADCabsy;\n        this.aOpcodeFuncs[0x7d] = this.opADCabsx;\n        this.aOpcodeFuncs[0xe1] = this.opSBCindx;\n        this.aOpcodeFuncs[0xe5] = this.opSBCzp;\n        this.aOpcodeFuncs[0xe9] = this.opSBCimm;\n        this.aOpcodeFuncs[0xed] = this.opSBCabs;\n        this.aOpcodeFuncs[0xf1] = this.opSBCindy;\n        this.aOpcodeFuncs[0xf5] = this.opSBCzpx;\n        this.aOpcodeFuncs[0xf9] = this.opSBCabsy;\n        this.aOpcodeFuncs[0xfd] = this.opSBCabsx;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} reg\n     * @param {number} mem\n     * @return {number}\n     *\n     * Refer to http://www.6502.org/tutorials/decimal_mode.html for 6502-specific details.\n     * Refer to http://homepage.cs.uiowa.edu/~jones/bcd/bcd.html for optimization tips.\n     */\n    addBCD(reg, mem)\n    {\n        var carry = ((this.regRC & 0x0100)? 1 : 0);\n\n        /*\n         * First add the low nibbles.\n         */\n        var r = (reg & 0x0f) + (mem & 0x0f) + carry;\n\n        /*\n         * Adjust the result. NOTE: The extra AND'ing and ADD'ing isn't necessary if we want to\n         * assume that ONLY valid BCD digits will be added, but we probably shouldn't assume that.\n         * NOTE: We use an OR instead of an ADD at the end because it's logically equivalent and faster.\n         */\n        if (r >= 0x0A) r = ((r + 0x06) & 0x0f) | 0x10;\n\n        /*\n         * Now add the high nibbles.\n         */\n        r += (reg & 0xf0) + (mem & 0xf0);\n\n        /*\n         * Before we do the next adjust, it seems that N and V are dependent on this intermediate\n         * result (however, the meaning of N and V in BCD mode is not well documented).\n         */\n        this.regRU = reg ^ mem; this.regRV = r;\n        this.regRN = (r & 0xff);\n\n        /*\n         * Final adjustment.\n         */\n        if (r >= 0xA0) r += 0x60;\n        /*\n         * NOTE: If the intermediate result was 0x1A0 or more, then adding 0x60 would yield a result\n         * of 0x200 or more, but because the rest of the simulator tests regRC for 0x100, rather than\n         * comparing regRC for values >= 0x100, we'll miss the fact that there was a carry, unless we\n         * scale any value in the 0x200-0x2ff range down to 0x100-0x1ff.  We then assert that the\n         * resulting value is within the proper range.\n         */\n        if (r >= 0x200) r -= 0x100;\n\n\n        /*\n         * In BCD mode, the C flag reflects the decimal result, but the Z flag reflects binary addition.\n         */\n        this.regRC = r;\n        this.regRZ = ((reg + mem + carry) & 0xff);\n\n        /*\n         * Account for an extra cycle in BCD mode as well.\n         */\n        this.nStepCycles--;\n\n        return r & 0xff;\n    }\n\n    /**\n     * @this {C1PCPU}\n     * @param {number} reg\n     * @param {number} mem\n     * @return {number}\n     *\n     * Refer to http://www.6502.org/tutorials/decimal_mode.html for 6502-specific details.\n     * Refer to http://homepage.cs.uiowa.edu/~jones/bcd/bcd.html for optimization tips.\n     */\n    subBCD(reg, mem)\n    {\n        var notcarry = ((this.regRC & 0x0100)? 0 : 1);\n\n        /*\n         * First subtract the low nibbles.\n         */\n        var r = (reg & 0x0f) - (mem & 0x0f) - notcarry;\n\n        /*\n         * Adjust the result. NOTE: The extra AND'ing and SUB'ing isn't necessary if we want to\n         * assume that ONLY valid BCD digits will be added, but we probably shouldn't assume that.\n         */\n        if (r < 0x00) r = ((r - 0x06) & 0x0f) - 0x10;\n\n        /*\n         * Now subtract the high nibbles.\n         */\n        r += (reg & 0xf0) - (mem & 0xf0);\n\n        /*\n         * Final adjustment.\n         */\n        if (r < 0x00) r -= 0x60;\n\n        /*\n         * In BCD mode, the Z -- and C, N and V -- flags are all set as if binary subtraction was performed.\n         */\n        // RC = (A - ML - !LAZY_C); SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC = (reg - mem - notcarry)) & 0xff;\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = reg ^ mem; this.regRV = this.regRC;\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n\n        /*\n         * Account for an extra cycle in BCD mode as well.\n         */\n        this.nStepCycles--;\n\n        return r & 0xff;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    clearRegs()\n    {\n        this.regA = 0;\n        this.regX = 0;\n        this.regY = 0;\n        this.regS = 0x100;\n        this.regP = 0;\n        this.regRN = 0;\n        this.regRZ = 0;\n        this.regRU = 0;\n        this.regRV = 0;\n        this.regRC = 0;\n        this.regPC = 0;\n        this.regEA = -1;\n        this.regEAWrite = -1;\n        this.mhz = 0;\n        this.nRunCycles = this.nBurstCycles = this.nStepCycles = 0;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBRK()\n    {   // opcode 0x00\n        // PC++;\n        this.regPC++;\n        // STACK(S--) = PCH;\n        this.abMem[this.regS--] = (this.regPC >> 8);\n        this.regS |= 0x100;\n        // STACK(S--) = PCL;\n        this.abMem[this.regS--] = (this.regPC & 0xff);\n        this.regS |= 0x100;\n        // B = 1;\n        this.regP |= 0x10;\n        // C = LAZY_C; Z = LAZY_Z; V = LAZY_V; N = LAZY_N;\n        this.regP = this.getRegP();\n        // STACK(S--) = P;\n        this.abMem[this.regS--] = this.regP;\n        this.regS |= 0x100;\n        // B = 0;\n        this.regP &= 0xef;\n        // EA = 0xFFFE;\n        this.regEA = 0xFFFE;\n        // PC = M;\n        this.regPC = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAindx()\n    {   // opcode 0x01\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAzp()\n    {   // opcode 0x05\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLzp()\n    {   // opcode 0x06\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // RC = ML << 1;\n        this.regRC = this.abMem[this.regEAWrite] << 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opPHP()\n    {   // opcode 0x08\n        this.regP = this.getRegP();\n        // STACK(S--) = P;\n        this.abMem[this.regS--] = this.regP;\n        this.regS |= 0x100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAimm()\n    {   // opcode 0x09\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLacc()\n    {   // opcode 0x0a\n        // RC = A << 1;\n        this.regRC = this.regA << 1;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAabs()\n    {   // opcode 0x0d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLabs()\n    {   // opcode 0x0e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = ML << 1;\n        this.regRC = this.abMem[this.regEAWrite] << 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBPL()\n    {   // opcode 0x10\n        // PC = PC + (LAZY_N == 0? SBYTE(PC) : 0) + 1;\n        this.regPC += (!(this.regRN & 0x80)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAindy()\n    {   // opcode 0x11\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAzpx()\n    {   // opcode 0x15\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA |= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLzpx()\n    {   // opcode 0x16\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RC = ML << 1;\n        this.regRC = this.abMem[this.regEAWrite] << 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCLC()\n    {   // opcode 0x18\n        // SET_LAZY_C(0);\n        this.regRC = 0x00;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAabsy()\n    {   // opcode 0x19\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA |= this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opORAabsx()\n    {   // opcode 0x1d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = A | ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA |= this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opASLabsx()\n    {   // opcode 0x1e\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RC = ML << 1;\n        this.regRC = this.abMem[this.regEAWrite] << 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opJSRabs()\n    {   // opcode 0x20\n        // EA = PC; PC += 1;\n        this.regEA = this.regPC++;\n        // STACK(S--) = PCH;\n        this.abMem[this.regS--] = (this.regPC >> 8);\n        this.regS |= 0x100;\n        // STACK(S--) = PCL;\n        this.abMem[this.regS--] = (this.regPC & 0xff);\n        this.regS |= 0x100;\n        // PC = M;\n        this.regPC = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDindx()\n    {   // opcode 0x21\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBITzp()\n    {   // opcode 0x24\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // SET_LAZY_Z((A & ML) == 0);\n        this.regRZ = (this.regA & this.abMem[this.regEA]);\n        // SET_LAZY_N(ML7);\n        this.regRN = ((this.regRN & 0x7f) | (this.abMem[this.regEA] & 0x80));\n        // SET_LAZY_V(ML6);\n        this.regRV = 0; this.regRU = ((this.abMem[this.regEA] & 0x40)? 0x80 : 0x00);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDzp()\n    {   // opcode 0x25\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLzp()\n    {   // opcode 0x26\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | (((this.regRC & 0x0200))? 0x0001 : 0));\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opPLP()\n    {   // opcode 0x28\n        // P = STACK(++S);\n        this.regS = ((this.regS+1) & 0xff) | 0x100;\n        this.regP = this.abMem[this.regS];\n        // SET_LAZY_C(C);\n        this.regRC = ((this.regP & 0x01)? 0x0100 : 0);\n        // SET_LAZY_Z(Z);\n        this.regRZ = (!(this.regP & 0x02)? 0x01 : 0);\n        // SET_LAZY_N(N);\n        this.regRN = (this.regP & 0x80);\n        // SET_LAZY_V(V);\n        this.regRV = 0; this.regRU = ((this.regP & 0x40)? 0x80 : 0x00);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDimm()\n    {   // opcode 0x29\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLacc()\n    {   // opcode 0x2a\n        // RCL =  A;\n        this.regRC = ((this.regRC & 0xff00) | this.regA);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | ((this.regRC & 0x0200)? 0x0001 : 0));\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBITabs()\n    {   // opcode 0x2c\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // SET_LAZY_Z((A & ML) == 0);\n        this.regRZ = (this.regA & this.abMem[this.regEA]);\n        // SET_LAZY_N(ML7);\n        this.regRN = ((this.regRN & 0x7f) | (this.abMem[this.regEA] & 0x80));\n        // SET_LAZY_V(ML6);\n        this.regRV = 0; this.regRU = ((this.abMem[this.regEA] & 0x40)? 0x80 : 0x00);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDabs()\n    {   // opcode 0x2d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLabs()\n    {   // opcode 0x2e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | (((this.regRC & 0x0200))? 0x0001 : 0));\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBMI()\n    {   // opcode 0x30\n        // PC = PC + (LAZY_N != 0? SBYTE(PC) : 0) + 1;\n        this.regPC += ((this.regRN & 0x80)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDindy()\n    {   // opcode 0x31\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDzpx()\n    {   // opcode 0x35\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLzpx()\n    {   // opcode 0x36\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | (((this.regRC & 0x0200))? 0x0001 : 0));\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSEC()\n    {   // opcode 0x38\n        // SET_LAZY_C(1);\n        this.regRC = 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDabsy()\n    {   // opcode 0x39\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opANDabsx()\n    {   // opcode 0x3d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = A & ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA &= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opROLabsx()\n    {   // opcode 0x3e\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RC = RC << 1;\n        this.regRC <<= 1;\n        // RCL0 = RCH1;\n        this.regRC = ((this.regRC & 0xfffe) | (((this.regRC & 0x0200))? 0x0001 : 0));\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRTI()\n    {   // opcode 0x40\n        // P = STACK(++S);\n        this.regS = ((this.regS+1) & 0xff) | 0x100;\n        this.regP = this.abMem[this.regS];\n        // SET_LAZY_C(C);\n        this.regRC = ((this.regP & 0x01)? 0x0100 : 0);\n        // SET_LAZY_Z(Z);\n        this.regRZ = (!(this.regP & 0x02)? 0x01 : 0);\n        // SET_LAZY_N(N);\n        this.regRN = (this.regP & 0x80);\n        // SET_LAZY_V(V);\n        this.regRV = 0; this.regRU = ((this.regP & 0x40)? 0x80 : 0x00);\n        // PCL = STACK(++S);\n        // PCH = STACK(++S);\n        this.regS = ((this.regS+2) & 0xff) | 0x100;\n        this.regPC = (this.abMem[(this.regS-1) | 0x100]) | (this.abMem[this.regS] << 8);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORindx()\n    {   // opcode 0x41\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORzp()\n    {   // opcode 0x45\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRzp()\n    {   // opcode 0x46\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // SET_LAZY_C(ML0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.abMem[this.regEAWrite] & 0x01)? 0x0100 : 0));\n        // ML = RCL = ML >> 1;\n        this.abMem[this.regEAWrite] = ((this.regRC = ((this.regRC & 0xff00) | (this.abMem[this.regEAWrite] >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opPHA()\n    {   // opcode 0x48\n        // STACK(S--) = A;\n        this.abMem[this.regS--] = this.regA;\n        this.regS |= 0x100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORimm()\n    {   // opcode 0x49\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRacc()\n    {   // opcode 0x4a\n        // SET_LAZY_C( A0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.regA & 0x01)? 0x0100 : 0));\n        // A = RCL =  A >> 1;\n        this.regA = ((this.regRC = ((this.regRC & 0xff00) | (this.regA >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opJMPimm16()\n    {   // opcode 0x4c\n        // EA = PC;\n        this.regEA = this.regPC;\n        // PC += 2;\n        // this.regPC += 2;\n        // PC = M;\n        this.regPC = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORabs()\n    {   // opcode 0x4d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRabs()\n    {   // opcode 0x4e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // SET_LAZY_C(ML0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.abMem[this.regEAWrite] & 0x01)? 0x0100 : 0));\n        // ML = RCL = ML >> 1;\n        this.abMem[this.regEAWrite] = ((this.regRC = ((this.regRC & 0xff00) | (this.abMem[this.regEAWrite] >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBVC()\n    {   // opcode 0x50\n        // PC = PC + (LAZY_V == 0? SBYTE(PC) : 0) + 1;\n        this.regPC += (!((((this.regRV & 0xff) ^ this.regRU) ^ (this.regRV >> 1)) & 0x80)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORindy()\n    {   // opcode 0x51\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = this.abMem[this.regPC++];\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORzpx()\n    {   // opcode 0x55\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRzpx()\n    {   // opcode 0x56\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // SET_LAZY_C(ML0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.abMem[this.regEAWrite] & 0x01)? 0x0100 : 0));\n        // ML = RCL = ML >> 1;\n        this.abMem[this.regEAWrite] = ((this.regRC = ((this.regRC & 0xff00) | (this.abMem[this.regEAWrite] >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCLI()\n    {   // opcode 0x58\n        // I = 0;\n        this.regP &= 0xfb;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORabsy()\n    {   // opcode 0x59\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = A ^ ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opEORabsx()\n    {   // opcode 0x5d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = A ^ ML; SET_LAZY_NZ(A)\n        this.regRN = this.regRZ = (this.regA ^= this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLSRabsx()\n    {   // opcode 0x5e\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // SET_LAZY_C(ML0);\n        this.regRC = ((this.regRC & 0xfeff) | ((this.abMem[this.regEAWrite] & 0x01)? 0x0100 : 0));\n        // ML = RCL = ML >> 1;\n        this.abMem[this.regEAWrite] = ((this.regRC = ((this.regRC & 0xff00) | (this.abMem[this.regEAWrite] >> 1))) & 0xff);\n        // SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRTS()\n    {   // opcode 0x60\n        // PCL = STACK(++S);\n        // PCH = STACK(++S);\n        // PC++;\n        this.regS = ((this.regS+2) & 0xff) | 0x100;\n        this.regPC = (((this.abMem[(this.regS-1) | 0x100])) | ((this.abMem[this.regS]) << 8)) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCindx()\n    {   // opcode 0x61\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCindxBCD()\n    {   // opcode 0x61\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCzp()\n    {   // opcode 0x65\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCzpBCD()\n    {   // opcode 0x65\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORzp()\n    {   // opcode 0x66\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opPLA()\n    {   // opcode 0x68\n        // A = STACK(++S); SET_LAZY_NZ(A);\n        this.regS = ((this.regS+1) & 0xff) | 0x100;\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regS];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCimm()\n    {   // opcode 0x69\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCimmBCD()\n    {   // opcode 0x69\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORacc()\n    {   // opcode 0x6a\n        // RCL =  A;\n        this.regRC = ((this.regRC & 0xff00) | this.regA);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     *\n     * NOTE from Wikipedia: \"The 6502's memory indirect jump instruction, JMP (<address>), is partially broken.\n     * If <address> is hex xxFF (i.e., any word ending in FF), the processor will not jump to the address stored in xxFF and xxFF+1 as expected,\n     * but rather the one defined by xxFF and xx00. This defect continued through the entire NMOS line, but was corrected in the CMOS derivatives.\"\n     */\n    opJMPabs16()\n    {   // opcode 0x6c\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // PC = M;\n        this.regPC = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabs()\n    {   // opcode 0x6d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = (A + ML + LAZY_C);\n        this.regRC =(this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsBCD()\n    {   // opcode 0x6d\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORabs()\n    {   // opcode 0x6e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBVS()\n    {   // opcode 0x70\n        // PC = PC + (LAZY_V != 0? SBYTE(PC) : 0) + 1;\n        this.regPC += (((((this.regRV & 0xff) ^ this.regRU) ^ (this.regRV >> 1)) & 0x80)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCindy()\n    {   // opcode 0x71\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCindyBCD()\n    {   // opcode 0x71\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCzpx()\n    {   // opcode 0x75\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCzpxBCD()\n    {   // opcode 0x75\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORzpx()\n    {   // opcode 0x76\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSEI()\n    {   // opcode 0x78\n        // I = 1;\n        this.regP |= 0x04;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsy()\n    {   // opcode 0x79\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsyBCD()\n    {   // opcode 0x79\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsx()\n    {   // opcode 0x7d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RC = (A + ML + LAZY_C);\n        this.regRC = (this.regA + this.abMem[this.regEA] + ((this.regRC & 0x0100)? 1 : 0));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opADCabsxBCD()\n    {   // opcode 0x7d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = this.addBCD(A,ML);\n        this.regA = this.addBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opRORabsx()\n    {   // opcode 0x7e\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RCL = ML;\n        this.regRC = ((this.regRC & 0xff00) | this.abMem[this.regEAWrite]);\n        // RCH1 = RCL0;\n        this.regRC = ((this.regRC & 0xfdff) | ((this.regRC & 0x0001)? 0x0200 : 0));\n        // RC = RC >> 1;\n        this.regRC >>= 1;\n        // ML = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = (this.regRC & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAindx()\n    {   // opcode 0x81\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEAWrite = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEAWrite = (this.abMem[this.regEAWrite] | (this.abMem[this.regEAWrite+1] << 8));\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTYzp()\n    {   // opcode 0x84\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = Y;\n        this.abMem[this.regEAWrite] = this.regY;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAzp()\n    {   // opcode 0x85\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTXzp()\n    {   // opcode 0x86\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = X;\n        this.abMem[this.regEAWrite] = this.regX;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDEY()\n    {   // opcode 0x88\n        // Y = ((Y - 1) & 0xff);\n        this.regY = ((this.regY - 1) & 0xff);\n        // SET_LAZY_NZ(Y);\n        this.regRN = this.regRZ = (this.regY);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTXA()\n    {   // opcode 0x8a\n        // A = X; SET_LAZY_NZ(X);\n        this.regRN = this.regRZ = this.regA = this.regX;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTYabs()\n    {   // opcode 0x8c\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = Y;\n        this.abMem[this.regEAWrite] = this.regY;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAabs()\n    {   // opcode 0x8d\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTXabs()\n    {   // opcode 0x8e\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = X;\n        this.abMem[this.regEAWrite] = this.regX;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBCC()\n    {   // opcode 0x90\n        // PC = PC + (LAZY_C == 0? SBYTE(PC) : 0) + 1;\n        this.regPC += (!(this.regRC & 0x0100)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAindy()\n    {   // opcode 0x91\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEAWrite = (this.abMem[this.regPC++]);\n        this.regEAWrite = (this.abMem[this.regEAWrite] | (this.abMem[this.regEAWrite+1] << 8)) + this.regY;\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTYzpx()\n    {   // opcode 0x94\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // ML = Y;\n        this.abMem[this.regEAWrite] = this.regY;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAzpx()\n    {   // opcode 0x95\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTXzpy()\n    {   // opcode 0x96\n        // EA = (BYTE(PC++)+Y) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regY) & 0xff;\n        // ML = X;\n        this.abMem[this.regEAWrite] = this.regX;\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTYA()\n    {   // opcode 0x98\n        // A = Y; SET_LAZY_NZ(Y);\n        this.regRN = this.regRZ = this.regA = this.regY;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAabsy()\n    {   // opcode 0x99\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTXS()\n    {   // opcode 0x9a\n        // S = X;\n        this.regS = this.regX | 0x100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSTAabsx()\n    {   // opcode 0x9d\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // ML = A;\n        this.abMem[this.regEAWrite] = this.regA;\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYimm()\n    {   // opcode 0xa0\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAindx()\n    {   // opcode 0xa1\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXimm()\n    {   // opcode 0xa2\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYzp()\n    {   // opcode 0xa4\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAzp()\n    {   // opcode 0xa5\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXzp()\n    {   // opcode 0xa6\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTAY()\n    {   // opcode 0xa8\n        // Y = A; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regY = this.regA;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAimm()\n    {   // opcode 0xa9\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTAX()\n    {   // opcode 0xaa\n        // X = A; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regX = this.regA;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYabs()\n    {   // opcode 0xac\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAabs()\n    {   // opcode 0xad\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXabs()\n    {   // opcode 0xae\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBCS()\n    {   // opcode 0xb0\n        // PC = PC + (LAZY_C != 0? SBYTE(PC) : 0) + 1;\n        this.regPC += ((this.regRC & 0x0100)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAindy()\n    {   // opcode 0xb1\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYzpx()\n    {   // opcode 0xb4\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAzpx()\n    {   // opcode 0xb5\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXzpy()\n    {   // opcode 0xb6\n        // EA = (BYTE(PC++)+Y) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regY) & 0xff;\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCLV()\n    {   // opcode 0xb8\n        // SET_LAZY_V(0);\n        this.regRV = 0; this.regRU = 0;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAabsy()\n    {   // opcode 0xb9\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opTSX()\n    {   // opcode 0xba\n        // X = S; SET_LAZY_NZ(S);\n        this.regRN = this.regRZ = this.regX = this.regS & 0xff;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDYabsx()\n    {   // opcode 0xbc\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // Y = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regY = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDAabsx()\n    {   // opcode 0xbd\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = ML; SET_LAZY_NZ(A);\n        this.regRN = this.regRZ = this.regA = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opLDXabsy()\n    {   // opcode 0xbe\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // X = ML; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.regX = this.abMem[this.regEA];\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPYimm()\n    {   // opcode 0xc0\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = Y - ML;\n        this.regRC = this.regY - this.abMem[this.regEA];\n        // SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = (this.regRC);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPindx()\n    {   // opcode 0xc1\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPYzp()\n    {   // opcode 0xc4\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = Y - ML;\n        this.regRC = this.regY - this.abMem[this.regEA];\n        // SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = (this.regRC);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPzp()\n    {   // opcode 0xc5\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDECzp()\n    {   // opcode 0xc6\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = ML - 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] - 1) & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINY()\n    {   // opcode 0xc8\n        // Y = ((Y + 1) & 0xff);\n        this.regY = ((this.regY + 1) & 0xff);\n        // SET_LAZY_NZ(Y);\n        this.regRN = this.regRZ = (this.regY);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPimm()\n    {   // opcode 0xc9\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDEX()\n    {   // opcode 0xca\n        // X = ((X - 1) & 0xff); SET_LAZY_NZ(X);\n        this.regRN = this.regRZ = this.regX = ((this.regX - 1) & 0xff);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPYabs()\n    {   // opcode 0xcc\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = Y - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = this.regY - this.abMem[this.regEA];\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPabs()\n    {   // opcode 0xcd\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDECabs()\n    {   // opcode 0xce\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = ML - 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] - 1) & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBNE()\n    {   // opcode 0xd0\n        // PC = PC + (LAZY_Z == 0? SBYTE(PC) : 0) + 1;\n        this.regPC += ((this.regRZ & 0xff)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPindy()\n    {   // opcode 0xd1\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPzpx()\n    {   // opcode 0xd5\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDECzpx()\n    {   // opcode 0xd6\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // ML = ML - 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] - 1) & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCLD()\n    {   // opcode 0xd8\n        // D = 0;\n        this.clearBCD();\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPabsy()\n    {   // opcode 0xd9\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCMPabsx()\n    {   // opcode 0xdd\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RC = A - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = (this.regA - this.abMem[this.regEA]);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opDECabsx()\n    {   // opcode 0xde\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // ML = ML - 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] - 1) & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPXimm()\n    {   // opcode 0xe0\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = X - ML;\n        this.regRC = this.regX - this.abMem[this.regEA];\n        // SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = (this.regRC);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCindx()\n    {   // opcode 0xe1\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCindxBCD()\n    {   // opcode 0xe1\n        // EA = WORD((BYTE(PC++)+X) & 0xff);\n        this.regEA = ((this.abMem[this.regPC++]) + this.regX) & 0xff;\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8));\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPXzp()\n    {   // opcode 0xe4\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = X - ML;\n        this.regRC = this.regX - this.abMem[this.regEA];\n        // SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = (this.regRC);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCzp()\n    {   // opcode 0xe5\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCzpBCD()\n    {   // opcode 0xe5\n        // EA = BYTE(PC++);\n        this.regEA = this.abMem[this.regPC++];\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINCzp()\n    {   // opcode 0xe6\n        // EA = BYTE(PC++);\n        this.regEAWrite = this.abMem[this.regPC++];\n        // ML = ML + 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] + 1) & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINX()\n    {   // opcode 0xe8\n        // X = ((X + 1) & 0xff);\n        this.regX = ((this.regX + 1) & 0xff);\n        // SET_LAZY_NZ(X);\n        this.regRN = this.regRZ = (this.regX);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCimm()\n    {   // opcode 0xe9\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCimmBCD()\n    {   // opcode 0xe9\n        // EA = PC++;\n        this.regEA = this.regPC++;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opNOP()\n    {   // opcode 0xea\n        //\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opCPXabs()\n    {   // opcode 0xec\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = X - ML; SET_LAZY_NZ(RC);\n        this.regRN = this.regRZ = this.regRC = this.regX - this.abMem[this.regEA];\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabs()\n    {   // opcode 0xed\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsBCD()\n    {   // opcode 0xed\n        // EA = WORD(PC); PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINCabs()\n    {   // opcode 0xee\n        // EA = WORD(PC); PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n        // ML = ML + 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] + 1) & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opBEQ()\n    {   // opcode 0xf0\n        // PC = PC + (LAZY_Z == 1? SBYTE(PC) : 0) + 1;\n        this.regPC += (!(this.regRZ & 0xff)? (this.nStepCycles--,((this.abMem[this.regPC] << 24) >> 24)) : 0) + 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCindy()\n    {   // opcode 0xf1\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCindyBCD()\n    {   // opcode 0xf1\n        // EA = WORD(BYTE(PC++))+Y;\n        this.regEA = (this.abMem[this.regPC++]);\n        this.regEA = (this.abMem[this.regEA] | (this.abMem[this.regEA+1] << 8)) + this.regY;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCzpx()\n    {   // opcode 0xf5\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCzpxBCD()\n    {   // opcode 0xf5\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEA = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINCzpx()\n    {   // opcode 0xf6\n        // EA = (BYTE(PC++)+X) & 0xff;\n        this.regEAWrite = (this.abMem[this.regPC++]+this.regX) & 0xff;\n        // ML = ML + 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] + 1) & 0xff);\n        // W = 1;\n        // NOTE: Consider alternatives for tracking zero-page writes (eg, regEAWriteZP)\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSED()\n    {   // opcode 0xf8\n        // D = 1;\n        this.setBCD();\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsy()\n    {   // opcode 0xf9\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsyBCD()\n    {   // opcode 0xf9\n        // EA = WORD(PC)+Y; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regY;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsx()\n    {   // opcode 0xfd\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // RC = (A - ML - !LAZY_C);\n        this.regRC = (this.regA - this.abMem[this.regEA] - ((this.regRC & 0x0100)? 0 : 1));\n        // SET_LAZY_OV(A,ML,RC);\n        this.regRU = this.regA ^ this.abMem[this.regEA]; this.regRV = this.regRC;\n        // A = RCL; SET_LAZY_NZ(RCL);\n        this.regRN = this.regRZ = this.regA = (this.regRC & 0xff);\n        // SET_LAZY_C(!LAZY_C);\n        this.regRC ^= 0x0100;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSBCabsxBCD()\n    {   // opcode 0xfd\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEA = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // A = this.subBCD(A,ML);\n        this.regA = this.subBCD(this.regA, this.abMem[this.regEA]);\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opINCabsx()\n    {   // opcode 0xfe\n        // EA = WORD(PC)+X; PC += 2;\n        this.regEAWrite = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8)) + this.regX;\n        // ML = ML + 1; SET_LAZY_NZ(ML);\n        this.regRN = this.regRZ = this.abMem[this.regEAWrite] = ((this.abMem[this.regEAWrite] + 1) & 0xff);\n        // W = 1;\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opSim()\n    {\n        var addr;\n        var bSimOp = this.abMem[this.regPC++];\n        switch(bSimOp) {\n\n            case this.SIMOP_HLT:\n                this.println(\"HALT\");\n                this.halt();\n                break;\n\n            case this.SIMOP_MSG:\n                addr = this.regPC;                  // currently we're using \"inline\" strings\n                // addr = (this.abMem[this.regPC++] | (this.abMem[this.regPC++] << 8));\n                var s = \"\";\n                while (addr < this.abMem.length) {\n                    var b = this.abMem[addr++];\n                    if (!b) break;\n                    s += String.fromCharCode(b);\n                }\n                this.regPC = addr;                  // update regPC as long as we're doing \"inline\" strings\n                /*\n                 * Before simply printing the string, what kinds of handy substitutions should we provide?\n                 *\n                 *      eg: %A for this.regA, %X for this.regX, etc\n                 */\n                s = s.replace(/%A/g, Str.toHex(this.regA, 2)).replace(/%X/g, Str.toHex(this.regX, 2)).replace(/%Y/g, Str.toHex(this.regY, 2));\n                this.println(s);\n                /*\n                 * To make printing \"smoother\", let's force a yield\n                 */\n                this.yieldCPU();\n                break;\n\n            default:\n                this.regPC -= 2;\n                this.println(\"undefined opSim: \" + Str.toHexByte(bSimOp) + \" at \" + Str.toHexWord(this.regPC));\n                this.halt();\n        }\n    }\n\n    /**\n     * @this {C1PCPU}\n     */\n    opUndefined()\n    {\n        var b = this.abMem[--this.regPC];\n        this.println(\"undefined opcode: \" + Str.toHexByte(b) + \" at \" + Str.toHexWord(this.regPC));\n        this.halt();\n    }\n\n    /**\n     * C1PCPU.init()\n     *\n     * This function operates on every HTML element of class \"cpu\", extracting the\n     * JSON-encoded parameters for the C1PCPU constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PCPU component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeCPUs = Component.getElementsByClass(document, C1PJS.APPCLASS, \"cpu\");\n        for (var iCPU=0; iCPU < aeCPUs.length; iCPU++) {\n            var eCPU = aeCPUs[iCPU];\n            var parmsCPU = Component.getComponentParms(eCPU);\n            var cpu = new C1PCPU(parmsCPU);\n            Component.bindComponentControls(cpu, eCPU, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Macro reference (from my original 1998 C source code, preserved in the comments below):\n *\n *      #define BYTE(a)  (abMem[(a) & 0xffff])\n *      #define WORD(a)  (*(word *)&BYTE(a))\n *      #define SBYTE(a) ((int)(char)BYTE(a))\n *      #define STACK(a) BYTE(((a) & 0xff)+0x100)\n *      #define M WORD(EA)\n *      #define ML BYTE(EA+0)\n *      #define MH BYTE(EA+1)\n *      #define A (aRegs[0].value)  // 8 bits\n *      #define X (aRegs[1].value)  // 8 bits\n *      #define Y (aRegs[2].value)  // 8 bits\n *      #define S (aRegs[3].value)  // 8 bits\n *      #define P (aRegs[4].value)  // 8 bits\n *      #define RN (aRegs[5].value) // 8 bits\n *      #define RZ (aRegs[6].value) // 8 bits\n *      #define RU (aRegs[7].value) // 8 bits\n *      #define RV (aRegs[8].value) // 16 bits\n *      #define RC (aRegs[9].value) // 16 bits\n *      #define EA (aRegs[10].value)// 16 bits\n *      #define LA (aRegs[11].value)// 16 bits\n *      #define PC (aRegs[12].value)// 16 bits\n *      #define EF (aRegs[13].value)// 8 bits\n *      #define C P0\n *      #define Z P1\n *      #define I P2\n *      #define D P3\n *      #define B P4\n *      #define V P6\n *      #define N P7\n *      #define W EF0\n *      #define LAZY_C (RCH0)\n *      #define SET_LAZY_C(b) (RCH0 = (b))\n *      #define LAZY_N (RN7)\n *      #define SET_LAZY_N(b) (RN7 = (b))\n *      #define SET_LAZY_NZ(v) (RN = RZ = (v))\n *      #define LAZY_Z ((byte)RZ == 0)\n *      #define SET_LAZY_Z(b) (RZ = !(b))\n *      #define LAZY_V ((((RVL ^ RU) ^ (RV >> 1)) & 0x80) != 0)\n *      #define SET_LAZY_V(b) (RV = 0, RU = ((b)? 0x80 : 0x00))\n *      #define SET_LAZY_OV(a,b,r) (RU = (a) ^ (b), RV = (r))\n */\n\n/*\n * Initialize every CPU module on the page (as IF there's ever going to be more than one ;-))\n */\nWeb.onInit(C1PCPU.init);\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/rom.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PROM extends Component {\n    /**\n     * C1PROM(parmsROM)\n     *\n     * The ROM component expects the following (parmsROM) properties:\n     *\n     *      size: amount of ROM, in bytes\n     *      image: name of ROM image file\n     *\n     * NOTE: The final location for the ROM image, once loaded, will be specified\n     * by the Computer object, using the setBuffer() method.\n     *\n     * @this {C1PROM}\n     * @param {Object} parmsROM\n     * @property {function()} convertImage\n     */\n    constructor(parmsROM)\n    {\n        super(\"C1PROM\", parmsROM);\n\n        this.abMem = null;\n        this.abImage = null;\n        this.cbROM = parmsROM['size'];\n        this.sImage = parmsROM['image'];\n        if (this.sImage) {\n            var sFileURL = this.sImage;\n            /**\n             * If the selected ROM image has a \".json\" extension, then we assume it's a pre-converted\n             * JSON-encoded ROM image, so we load it as-is; ditto for files with a \".hex\" extension. Otherwise,\n             * we ask our server-side ROM image converter to return the corresponding JSON-encoded data,\n             * in compact form (ie, minimal whitespace, no ASCII data comments, etc).\n             */\n            var sFileExt = Str.getExtension(this.sImage);\n            if (sFileExt != DumpAPI.FORMAT.JSON && sFileExt != DumpAPI.FORMAT.HEX) {\n                sFileURL = Web.getHost() + DumpAPI.ENDPOINT + '?' + DumpAPI.QUERY.FILE + '=' + this.sImage + '&' + DumpAPI.QUERY.FORMAT + '=' + DumpAPI.FORMAT.BYTES;\n            }\n            var rom = this;\n            Web.getResource(sFileURL, null, true, function(sURL, sResponse, nErrorCode) {\n                rom.convertImage(sURL, sResponse, nErrorCode);\n            });\n        }\n    }\n\n    /**\n     * @this {C1PROM}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.offROM = start;\n        var cbROM = end - start + 1;\n        /*\n         * It's possible that the ROM component didn't specify a size,\n         * in which case just use the size the Computer component has specified.\n         */\n        if (!this.cbROM)\n            this.cbROM = cbROM;\n        if (cbROM != this.cbROM) {\n            this.setError(\"computer-specified ROM size (\" + Str.toHexWord(cbROM) + \") does not match component-specified size (\" + Str.toHexWord(this.cbROM) + \")\");\n            return;\n        }\n        if (cpu) {\n            this.cpu = cpu;\n            cpu.addWriteNotify(start, end, this, this.setByte);\n        }\n        this.copyImage();\n    }\n\n    /**\n     * @this {C1PROM}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n        }\n    }\n\n    /**\n     * @this {C1PROM}\n     * @param {number} addr\n     * @param {number|undefined} [addrFrom]\n     */\n    setByte(addr, addrFrom)\n    {\n        /*\n         * Beyond reporting this write, we need to \"repair\" the ROM, using the original image data,\n         * but only if addrFrom is defined (undefined implies this is a write from the Debugger, and\n         * we need to allow the Debugger to modify ROM contents).\n         */\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_PORT, true);\n            var offset = (addr - this.offROM);\n\n            if (!this.abImage)\n                this.abMem[this.offROM + offset] = 0;\n            else\n                this.abMem[this.offROM + offset] = this.abImage[offset];\n        }\n    }\n\n    /**\n     * @this {C1PROM}\n     * @param {string} sImageName\n     * @param {string} sImageData\n     * @param {number} nErrorCode (response from server if anything other than 200)\n     */\n    convertImage(sImageName, sImageData, nErrorCode)\n    {\n        if (nErrorCode) {\n            this.println(\"Error loading ROM \\\"\" + sImageName + \"\\\" (\" + nErrorCode + \")\");\n            return;\n        }\n        if (sImageData.charAt(0) == \"[\" || sImageData.charAt(0) == \"{\") {\n            try {\n                /*\n                 * The most likely source of any exception will be here: parsing the JSON-encoded ROM data.\n                 */\n                var rom = eval(\"(\" + sImageData + \")\");\n                var ab = rom['bytes'];\n                if (ab) {\n                    this.abImage = ab;\n                } else {\n                    this.abImage = rom;\n                }\n            } catch (e) {\n                this.println(\"Error processing ROM \\\"\" + sImageName + \"\\\": \" + e.message);\n                return;\n            }\n        }\n        else {\n            /*\n             * Parse the ROM image data manually; we assume it's in \"simplified\" hex form (a series of hex byte-values separated by whitespace)\n             */\n            var sData = sImageData.replace(/\\n/gm, \" \").replace(/ +$/, \"\");\n            var asData = sData.split(\" \");\n            this.abImage = new Array(asData.length);\n            for (var i=0; i < asData.length; i++) {\n                this.abImage[i] = parseInt(asData[i], 16);\n            }\n        }\n        this.copyImage();\n    }\n\n    /**\n     * @this {C1PROM}\n     */\n    copyImage()\n    {\n        /*\n         * The Computer object may give us the address of the ROM image before we've finished downloading the image,\n         * so both setBuffer() and convertImage() call copyImage(), which in turn will copy the image ONLY when both\n         * pieces are in place.  At that point, the component becomes \"ready\", in much the same way that other components\n         * (eg, CPU and Screen) become \"ready\" when all their prerequisites are satisfied.\n         */\n        if (!this.isReady()) {\n            if (!this.sImage) {\n                this.setReady();\n            }\n            else\n            if (this.abImage && this.abMem) {\n                var cbImage = this.abImage.length;\n                if (cbImage != this.cbROM) {\n                    this.setError(\"ROM image size (\" + Str.toHexWord(cbImage) + \") does not match component-specified size (\" + Str.toHexWord(this.cbROM) + \")\");\n                    return;\n                }\n                if (DEBUG) this.log(\"copyImage(): copying ROM to \" + Str.toHexWord(this.offROM) + \" (\" + Str.toHexWord(cbImage) + \" bytes)\");\n                for (var i=0; i < cbImage; i++) {\n                    this.abMem[this.offROM + i] = this.abImage[i];\n                }\n                this.setReady();\n            }\n        }\n    }\n\n    /**\n     * C1PROM.init()\n     *\n     * This function operates on every HTML element of class \"rom\", extracting the\n     * JSON-encoded parameters for the C1PROM constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PROM component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeROM = Component.getElementsByClass(document, C1PJS.APPCLASS, \"rom\");\n        for (var iROM=0; iROM < aeROM.length; iROM++) {\n            var eROM = aeROM[iROM];\n            var parmsROM = Component.getComponentParms(eROM);\n            var rom = new C1PROM(parmsROM);\n            Component.bindComponentControls(rom, eROM, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize all the ROM modules on the page.\n */\nWeb.onInit(C1PROM.init);\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/ram.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PRAM extends Component {\n    /**\n     * C1PRAM(parmsRAM)\n     *\n     * The RAM component expects the following (parmsRAM) properties:\n     *\n     *      size: amount of RAM, in bytes\n     *\n     * NOTE: We may make a note of the specified size, but we will not actually allocate\n     * any memory for the RAM; we wait for the Computer object to tell us where our RAM is,\n     * using the setBuffer() method.\n     *\n     * @this {C1PRAM}\n     * @param {Object} parmsRAM\n     */\n    constructor(parmsRAM)\n    {\n        super(\"C1PRAM\", parmsRAM);\n    }\n\n    /**\n     * @this {C1PRAM}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n     // this.offRAM = start;\n     // this.cbRAM = end - start + 1;\n        this.setReady();\n    }\n\n    /**\n     * C1PRAM.init()\n     *\n     * This function operates on every HTML element of class \"ram\", extracting the\n     * JSON-encoded parameters for the C1PRAM constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PRAM component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeRAM = Component.getElementsByClass(document, C1PJS.APPCLASS, \"ram\");\n        for (var iRAM=0; iRAM < aeRAM.length; iRAM++) {\n            var eRAM = aeRAM[iRAM];\n            var parmsRAM = Component.getComponentParms(eRAM);\n            var ram = new C1PRAM(parmsRAM);\n            Component.bindComponentControls(ram, eRAM, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize all the RAM modules on the page.\n */\nWeb.onInit(C1PRAM.init);\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/keyboard.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PKeyboard extends Component {\n    /**\n     * C1PKeyboard(parmsKbd)\n     *\n     * The Keyboard component can be configured with the following (parmsKbd) properties:\n     *\n     *      model: model number (one of: 542 or 600; 600 is the default)\n     *\n     * Its main purpose is to receive binding requests for various keyboard events,\n     * and to use those events to simulate the C1P's keyboard hardware; specifically,\n     * an OSI model 600 board (NOT the model 542).\n     *\n     * Keys on the C1P keyboard that differ from modern keyboards, along with their\n     * closest modern counterpart:\n     *\n     *      C1P      PC\n     *      ---      --\n     *      2\"       2@\n     *      6&       6^\n     *      7'       7&\n     *      8(       8*\n     *      9)       9(\n     *      0        0)\n     *      :*       -_\n     *      -=       =+\n     *      ;+       ;:\n     *      LINEFEED CTRL-J\n     *      RETURN   ENTER (or CTRL-M)\n     *      SHIFT-O  DELETE (or CTRL-H)\n     *      SHIFT-N  ^\n     *      SHIFT-P  @ (used by the BASIC-IN-ROM to abandon the current line)\n     *      SHIFT-L  \\\n     *      SHIFT-K  [\n     *      SHIFT-M  ]\n     *      CTRL-C   Same (used by the BASIC-IN-ROM to interrupt RUN and LIST, unless disabled with POKE 530,1)\n     *      CTRL-O   Same (used by the BASIC-IN-ROM to suppress output until another CTRL-O is typed)\n     *      RUB-OUT  (no mapping chosen for this key yet)\n     *      REPEAT   (no mapping chosen for this key yet)\n     *\n     * Problems with iOS Devices\n     * -------------------------\n     * The keyboard pops up with the SHIFT key depressed, which is not the initial keyboard state that the C1P expects.\n     * I tried to fix that by adding an 'autocapitalize=\"off\"' attribute alongside the 'contenteditable=\"true\"' attribute\n     * on the <canvas> element, but apparently Safari v5 honors that only inside certain elements (eg, <input>).  The simplest\n     * work-around is to tap the iOS device's SHIFT key before starting to type, but I'd prefer an automatic solution.\n     *\n     * Another work-around might be to NEVER pass the real CAPS-LOCK state to the virtual machine, and whenever CAPS-LOCK is\n     * actually down, automatically \"uncapitalize\" all letters.\n     *\n     * However, the current work-around is for keyPressSimulate() to ALWAYS convert all alphabetic charCodes to their\n     * lower-case equivalents, and simply let the C1P's own shift-key logic do its thing.  Note that we do this ONLY for\n     * iOS devices, so that on all other devices, you can still use special shifted key combinations like SHIFT-O and SHIFT-P;\n     * this work-around breaks those key combinations for iOS devices, but that seems like a reasonable trade-off.\n     *\n     * Simple C1P Virtual Hardware Test\n     * --------------------------------\n     * Using the following code:\n     *\n     *      10 POKE 530,1\n     *      20 KEY=57088\n     *      25 Q=-1\n     *      30 POKE KEY,64\n     *      40 P=PEEK(KEY)\n     *      50 IF P<>Q THEN PRINT P\n     *      60 Q=P\n     *      70 GOTO 30\n     *\n     * The value 64 (0x40) should have enabled every row except R6.  Here were the results for keys\n     * on row R7:\n     *\n     *        1   2   3   4   5   6   7\n     *      --- --- --- --- --- --- ---\n     *      126 190 222 238 246 250 252\n     *\n     * Sure enough, none of the keys on R6 worked, and all the keys on rows R0-R5 generated the same\n     * values as R7. But why were the values read all EVEN instead of ODD (ie, why was bit 0 cleared as\n     * well?)  Answer: because 0x40 also enables keys on row R0, where the SHIFT-LOCK key resides,\n     * and since the SHIFT-LOCK is normally locked AND also sits in column C0, bit 0 will be clear as well.\n     *\n     * This explains why the \"STAR WARS\" game (SAMPLE4.BAS) expected values \"126,190,222,238,246,250\"\n     * for keys 1-6 after POKE'ing 64 into location 57088 (0xdf00), instead of the more typical values\n     * \"127,191,223,239,247,251.\"  This also means that anyone who happened to unlock their SHIFT-LOCK\n     * would have trouble playing that game.\n     *\n     * @this {C1PKeyboard}\n     * @param {Object} parmsKbd\n     */\n    constructor(parmsKbd)\n    {\n        super(\"C1PKeyboard\", parmsKbd);\n\n        this.flags.powered = false;\n        this.nDefaultModel = parmsKbd['model'];\n\n        /*\n         * keyCodes that I must pay particular attention to\n         */\n        this.KEYCODE_DELETE     = 0x08;\n        this.KEYCODE_TAB        = 0x09;\n        this.KEYCODE_LF         = 0x0A;\n        this.KEYCODE_CR         = 0x0D;\n        this.KEYCODE_SHIFT      = 0x10;                 // I map this to CHARCODE_LSHIFT\n        this.KEYCODE_CONTROL    = 0x11;\n        this.KEYCODE_ALT        = 0x12;                 // I map this to CHARCODE_RSHIFT (since the C1P keyboard has no ALT key)\n        this.KEYCODE_CAPSLOCK   = 0x14;\n        this.KEYCODE_ESC        = 0x1B;                 // NOTE: for some reason, this comes in via keyDown/keyUp only, not keyPress\n        this.KEYCODE_COMMAND    = 0x5B;\n\n        /*\n         * The following charCodes are the same as the corresponding keyCodes\n         */\n        this.CHARCODE_DELETE    = this.KEYCODE_DELETE;\n        this.CHARCODE_LF        = this.KEYCODE_LF;\n        this.CHARCODE_CR        = this.KEYCODE_CR;\n        this.CHARCODE_ESC       = this.KEYCODE_ESC;\n\n        /*\n         * The following charCodes are NOT the same as the corresponding keyCodes, hence the bias (PSEUDO_CHARCODE);\n         * I've deliberately chosen a bias that still produces values in the byte range (0x00-0xFF) and will therefore\n         * fit into aCharCodeMap, but which shouldn't conflict with any actual, type-able keys.\n         */\n        this.PSEUDO_CHARCODE    = 0xE0;\n        this.CHARCODE_LSHIFT    = this.KEYCODE_SHIFT    + this.PSEUDO_CHARCODE;\n        this.CHARCODE_CTRL      = this.KEYCODE_CONTROL  + this.PSEUDO_CHARCODE;\n        this.CHARCODE_RSHIFT    = this.KEYCODE_ALT      + this.PSEUDO_CHARCODE;\n        this.CHARCODE_SHIFTLOCK = this.KEYCODE_CAPSLOCK + this.PSEUDO_CHARCODE;\n\n        /*\n         * Other common character codes, pseudo (like the C1P's \"BREAK\" key, which has no modern analog) or otherwise\n         */\n        this.CHARCODE_BREAK     = 0x00 + this.PSEUDO_CHARCODE;\n        this.CHARCODE_CTRLC     = 0x03;\n        this.CHARCODE_CTRLO     = 0x0F;\n\n        /*\n         * These are \"shift key\" bits I store in bitsShift, and with the exception of BIT_COMMAND (because\n         * the C1P doesn't have a COMMAND key), they all match the bit position of the corresponding shift key's\n         * column on row 0 (abKbdCols[0]) of the simulated keyboard hardware.\n         *\n         * NOTE: Whenever shift key bits need to be restored from bitsShift to abKbdCols[0] (eg, when restoring\n         * the current shift state at the completion of a simulated key), be sure to mask bitsShift with BITS_SIMULATE\n         * before propagating them.\n         */\n        this.BIT_SHIFTLOCK      = 0x01;\n        this.BIT_RSHIFT         = 0x02;\n        this.BIT_LSHIFT         = 0x04;\n        this.BIT_COMMAND        = 0x08;     // the C1P has no key \"wired\" to this column, so I can use this bit for COMMAND\n        this.BIT_CTRL           = 0x40;\n        this.BITS_SIMULATE      = (this.BIT_RSHIFT | this.BIT_LSHIFT | this.BIT_CTRL);\n\n        this.SIMCODE_KEYPRESS   = 0;\n        this.SIMCODE_KEYRELEASE = 1;\n        this.SIMCODE_KEYEVENT   = 2;\n        this.SIMCODE_KEYTIMEOUT = 3;\n        this.SIMCODE_AUTOCLEAR  = 4;\n        this.aSimCodeDescs = [\"keyPress\",\"keyRelease\",\"keyEvent\",\"keyTimeout\",\"autoClear\"];\n\n        /*\n         * From \"OSI C1P Technical Report\" p.19 regarding the Model 600 Board:\n         *\n         *      \"By holding down any key, one will first get one character output, and after approximately\n         *      a half second delay a repeat rate of approximately 5 characters per second.\"\n         */\n        this.nCyclesThreshold   = 8192;     // number of virtual CPU cycles required before aKbdStates is propagated\n        this.msReleaseDelay     = 250;      // number of milliseconds before a down key is \"forced\" up (unless we see it go up)\n        this.msReleaseRepeat    = 100;      // number of milliseconds before a held key is \"forced\" up (assuming auto-repeat)\n        this.msInjectDelay      = 300;      // number of milliseconds between injected keystrokes\n\n        this.aButtonCodeMap = {};\n        this.aButtonCodeMap['break']  = this.CHARCODE_BREAK;\n        this.aButtonCodeMap['esc']    = this.CHARCODE_ESC;\n        this.aButtonCodeMap['ctrl-c'] = this.CHARCODE_CTRLC;\n        this.aButtonCodeMap['ctrl-o'] = this.CHARCODE_CTRLO;\n\n        /*\n         * This array is used by keyEventSimulate() to lookup a given charCode and convert it to the appropriate\n         * row/col bit combination that the C1P requires.  I assign each supported charCode a 16-bit value, where\n         * the high byte contains the row/col pair (in the high and low nibbles, respectively), and the low byte\n         * contains any required shift-key code.\n         *\n         * For example, an apostrophe (0x27) is an unshifted key on a modern keyboard, but it is a SHIFT-7 on the\n         * C1P keyboard, so when I simulate the 7, I must also simulate a SHIFT (I always choose the LEFT shift\n         * key -- CHARCODE_LSHIFT -- but that choice is completely arbitrary).\n         *\n         * Using charCodes (from keyPress events) proved to be more robust than using keyCodes (from keyDown and\n         * keyUp events), in part because of differences between the C1P keyboard's layout and modern keyboards,\n         * and also because of differences in the way browsers generate the keyDown and keyUp events.  For\n         * example, Safari on iOS devices will not generate up/down events for shift keys, and for other keys,\n         * the up/down events are usually generated after the actual press is complete, and in rapid succession,\n         * which doesn't give the slow C1P virtual machine enough time to detect the key.\n         *\n         * There are still a few times that I call keyEventSimulate() from keyEvent(), and for those occasions,\n         * I create a pseudo-charCode value by adding PSEUDO_CHARCODE (0xE0) to the keyCode value, to avoid any\n         * confusion with real charCodes:\n         *\n         *      CHARCODE_LSHIFT     (originally 0x10, which also looks like CTRL-P, so converted to 0xF0)\n         *      CHARCODE_CTRL       (originally 0x11, which also looks like CTRL-Q, so converted to 0xF1)\n         *      CHARCODE_RSHIFT     (originally 0x12, which also looks like CTRL-R, so converted to 0xF2)\n         *      CHARCODE_SHIFTLOCK  (originally 0x14, which also looks like CTRL-T, so converted to 0xF4)\n         *\n         * Again, as things currently stand, iOS devices will never generate the above charCodes, so any C1P software\n         * that relies detecting on shift-key state changes will not work on those devices.\n         *\n         * For reference purposes, I've left some parenthetical references to corresponding keyCodes in the comments\n         * below.  Relying on keyCodes is problematic, which is why I've tried to eliminate most dependencies on them,\n         * but still, they're all you get on keyDown/keyUp events.\n         */\n        this.aCharCodeMap = [];\n        this.aCharCodeMap[0x31] = 0x7700; this.aCharCodeMap[0x21] = 0x7700 + this.CHARCODE_LSHIFT;  // 1 (0x31) ! (0x31)\n        this.aCharCodeMap[0x32] = 0x7600; this.aCharCodeMap[0x22] = 0x7600 + this.CHARCODE_LSHIFT;  // 2 (0x32) \" (0xDE)\n        this.aCharCodeMap[0x33] = 0x7500; this.aCharCodeMap[0x23] = 0x7500 + this.CHARCODE_LSHIFT;  // 3 (0x33) # (0x33)\n        this.aCharCodeMap[0x34] = 0x7400; this.aCharCodeMap[0x24] = 0x7400 + this.CHARCODE_LSHIFT;  // 4 (0x34) $ (0x34)\n        this.aCharCodeMap[0x35] = 0x7300; this.aCharCodeMap[0x25] = 0x7300 + this.CHARCODE_LSHIFT;  // 5 (0x35) % (0x35)\n        this.aCharCodeMap[0x36] = 0x7200; this.aCharCodeMap[0x26] = 0x7200 + this.CHARCODE_LSHIFT;  // 6 (0x36) & (0x37)\n        this.aCharCodeMap[0x37] = 0x7100; this.aCharCodeMap[0x27] = 0x7100 + this.CHARCODE_LSHIFT;  // 7 (0x37) ' (0xDE)\n        this.aCharCodeMap[0x38] = 0x6700; this.aCharCodeMap[0x28] = 0x6700 + this.CHARCODE_LSHIFT;  // 8 (0x38) ( (0x39)\n        this.aCharCodeMap[0x39] = 0x6600; this.aCharCodeMap[0x29] = 0x6600 + this.CHARCODE_LSHIFT;  // 9 (0x39) ) (0x30)\n        this.aCharCodeMap[0x30] = 0x6500;   // 0\n        this.aCharCodeMap[0x3A] = 0x6400; this.aCharCodeMap[0x2A] = 0x6400 + this.CHARCODE_LSHIFT;  // : (0xBA) * (0x38)\n        this.aCharCodeMap[0x2D] = 0x6300; this.aCharCodeMap[0x3D] = 0x6300 + this.CHARCODE_LSHIFT;  // - (0xBD) = (0xBB)\n      //this.aCharCodeMap[0x00] = 0x6200;   // RUB-OUT (no mapping chosen for this key yet)\n        this.aCharCodeMap[0x2E] = 0x5700; this.aCharCodeMap[0x3E] = 0x5700 + this.CHARCODE_LSHIFT;  // . (0xBE) > (0xBE)\n        this.aCharCodeMap[0x6C] = 0x5600; this.aCharCodeMap[0x4C] = 0x5600 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x5C] = 0x5600 + this.CHARCODE_LSHIFT; // l L \\\n        this.aCharCodeMap[0x6F] = 0x5500; this.aCharCodeMap[0x4F] = 0x5500 + this.CHARCODE_LSHIFT; this.aCharCodeMap[this.CHARCODE_DELETE] = 0x5500 + this.CHARCODE_LSHIFT; // o O DELETE\n        this.aCharCodeMap[this.CHARCODE_LF] = 0x5400;   // LINE-FEED\n        this.aCharCodeMap[this.CHARCODE_CR] = 0x5300;   // RETURN\n        this.aCharCodeMap[0x77] = 0x4700; this.aCharCodeMap[0x57] = 0x4700 + this.CHARCODE_LSHIFT;  // w W\n        this.aCharCodeMap[0x65] = 0x4600; this.aCharCodeMap[0x45] = 0x4600 + this.CHARCODE_LSHIFT;  // e E\n        this.aCharCodeMap[0x72] = 0x4500; this.aCharCodeMap[0x52] = 0x4500 + this.CHARCODE_LSHIFT;  // r R\n        this.aCharCodeMap[0x74] = 0x4400; this.aCharCodeMap[0x54] = 0x4400 + this.CHARCODE_LSHIFT;  // t T\n        this.aCharCodeMap[0x79] = 0x4300; this.aCharCodeMap[0x59] = 0x4300 + this.CHARCODE_LSHIFT;  // y Y\n        this.aCharCodeMap[0x75] = 0x4200; this.aCharCodeMap[0x55] = 0x4200 + this.CHARCODE_LSHIFT;  // u U\n        this.aCharCodeMap[0x69] = 0x4100; this.aCharCodeMap[0x49] = 0x4100 + this.CHARCODE_LSHIFT;  // i I\n        this.aCharCodeMap[0x73] = 0x3700; this.aCharCodeMap[0x53] = 0x3700 + this.CHARCODE_LSHIFT;  // s S\n        this.aCharCodeMap[0x64] = 0x3600; this.aCharCodeMap[0x44] = 0x3600 + this.CHARCODE_LSHIFT;  // d D\n        this.aCharCodeMap[0x66] = 0x3500; this.aCharCodeMap[0x46] = 0x3500 + this.CHARCODE_LSHIFT;  // f F\n        this.aCharCodeMap[0x67] = 0x3400; this.aCharCodeMap[0x47] = 0x3400 + this.CHARCODE_LSHIFT;  // g G\n        this.aCharCodeMap[0x68] = 0x3300; this.aCharCodeMap[0x48] = 0x3300 + this.CHARCODE_LSHIFT;  // h H\n        this.aCharCodeMap[0x6A] = 0x3200; this.aCharCodeMap[0x4A] = 0x3200 + this.CHARCODE_LSHIFT;  // j J\n        this.aCharCodeMap[0x6B] = 0x3100; this.aCharCodeMap[0x4B] = 0x3100 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x5B] = 0x3100 + this.CHARCODE_LSHIFT; // k K [\n        this.aCharCodeMap[0x78] = 0x2700; this.aCharCodeMap[0x58] = 0x2700 + this.CHARCODE_LSHIFT;  // x X\n        this.aCharCodeMap[0x63] = 0x2600; this.aCharCodeMap[0x43] = 0x2600 + this.CHARCODE_LSHIFT;  // c C\n        this.aCharCodeMap[0x76] = 0x2500; this.aCharCodeMap[0x56] = 0x2500 + this.CHARCODE_LSHIFT;  // v V\n        this.aCharCodeMap[0x62] = 0x2400; this.aCharCodeMap[0x42] = 0x2400 + this.CHARCODE_LSHIFT;  // b B\n        this.aCharCodeMap[0x6E] = 0x2300; this.aCharCodeMap[0x4E] = 0x2300 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x5E] = 0x2300 + this.CHARCODE_LSHIFT; // n N ^\n        this.aCharCodeMap[0x6D] = 0x2200; this.aCharCodeMap[0x4D] = 0x2200 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x5D] = 0x2200 + this.CHARCODE_LSHIFT; // m M ]\n        this.aCharCodeMap[0x2C] = 0x2100; this.aCharCodeMap[0x3C] = 0x2100 + this.CHARCODE_LSHIFT;  // , (0xBC) < (0xBC)\n        this.aCharCodeMap[0x71] = 0x1700; this.aCharCodeMap[0x51] = 0x1700 + this.CHARCODE_LSHIFT;  // q Q\n        this.aCharCodeMap[0x61] = 0x1600; this.aCharCodeMap[0x41] = 0x1600 + this.CHARCODE_LSHIFT;  // a A\n        this.aCharCodeMap[0x7A] = 0x1500; this.aCharCodeMap[0x5A] = 0x1500 + this.CHARCODE_LSHIFT;  // z Z\n        this.aCharCodeMap[0x20] = 0x1400;   // SPACE\n        this.aCharCodeMap[0x2F] = 0x1300; this.aCharCodeMap[0x3F] = 0x1300 + this.CHARCODE_LSHIFT;  // / (0xBF) ? (0xBF)\n        this.aCharCodeMap[0x3B] = 0x1200; this.aCharCodeMap[0x2B] = 0x1200 + this.CHARCODE_LSHIFT;  // ; (0xBA) + (0xBB)\n        this.aCharCodeMap[0x70] = 0x1100; this.aCharCodeMap[0x50] = 0x1100 + this.CHARCODE_LSHIFT; this.aCharCodeMap[0x40] = 0x1100 + this.CHARCODE_LSHIFT; // p P @\n      //this.aCharCodeMap[0x00]                     = 0x0700;   // REPEAT (no mapping chosen for this key yet)\n        this.aCharCodeMap[this.CHARCODE_CTRL]       = 0x0600;   // CTRL\n        this.aCharCodeMap[this.CHARCODE_ESC]        = 0x0500;   // ESC\n        this.aCharCodeMap[this.CHARCODE_LSHIFT]     = 0x0200;   // LEFT-SHIFT\n        this.aCharCodeMap[this.CHARCODE_RSHIFT]     = 0x0100;   // RIGHT-SHIFT\n        this.aCharCodeMap[this.CHARCODE_SHIFTLOCK]  = 0x0000;   // SHIFT-LOCK\n\n        this.reset();\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     */\n    reset()\n    {\n        this.setModel(this.nDefaultModel);\n\n        /*\n         * The physical (not virtual) state of various shift keys,\n         * with the exception of SHIFT-LOCK, which needs to start in the\n         * \"locked\" position, regardless of the physical CAPS-LOCK state.\n         *\n         * QUESTION: In JavaScript, how do you query initial key states?\n         */\n        this.bitsShift = this.BIT_SHIFTLOCK;\n\n        /*\n         * Every SET bit of bKbdRows represents an enabled row (this convention\n         * is the REVERSE of the C1P hardware, but I prefer it).\n         */\n        this.bKbdRows = 0x00;\n\n        /*\n         * Every SET bit of abKbdCols represents an enabled column; again, this is\n         * the REVERSE of the C1P hardware, but I compensate for that difference with\n         * a quick XOR in updateMemory().\n         *\n         * Like bitsShift, this 8x8 array (8 byte values, each with 8 bits) represents\n         * the physical state of the keyboard, encoded in C1P format; the C1P won't\n         * actually see data this until updateMemory() decides it's time to propagate it.\n         */\n        this.abKbdCols = [this.BIT_SHIFTLOCK,0x00,0x00,0x00,0x00,0x00,0x00,0x00];\n\n        /*\n         * After a new key event has updated abKbdCols, we \"push\" a copy of that\n         * updated keyboard state onto this array. updateMemory() will then \"shift\"\n         * the next copy off, update its own copy (abKbdColsLast), and then propagate\n         * that to the C1P's keyboard memory, once the CPU has had enough time to\n         * process the previous event (see nCyclesThreshold).\n         */\n        this.aKbdStates = [];\n\n        /*\n         * When a key \"down\" is simulated on behalf of some charCode, I save\n         * the timer object responsible for simulating the key \"up\" here, so that\n         * if I detect the actual key going up sooner, I can cancel the timer and\n         * simulate the \"up\" immediately.  Similarly, if another press for the same\n         * key arrives before last one expired (eg, auto-repeat), I need to cancel\n         * the previous timer for that key before setting another.\n         *\n         * NOTE: If this is anything other than an initial reset, then we need to\n         * make sure there are no outstanding timers before we blow the array away.\n         */\n        if (this.aKeyTimers) {\n            for (var i in this.aKeyTimers) {\n                if (isNaN(+i)) continue; // ignore any non-numeric properties, if any\n                if (this.aKeyTimers[i]) clearTimeout(this.aKeyTimers[i]);\n            }\n        }\n        this.aKeyTimers = [];\n        this.prevCharDown = 0;\n        this.prevKeyDown = 0;\n\n        /*\n         * These save the last values written to keyboard memory, so that I can\n         * avoid rewriting the memory if the values haven't changed since the last update.\n         */\n        this.bWriteLast = -1;\n        this.abKbdColsLast = this.abKbdCols;\n\n        /*\n         * Due to the way the C1P scans its keyboard rows (from R0 up to R7 *or* to the\n         * highest row for which a \"down\" key has just been detected), if we get back-to-back\n         * key events for, say, \"I\" and then \"S\", the C1P will see only the \"S\", never the \"I\",\n         * because \"I\" is on a higher row.\n         *\n         * That's why we have aKbdStates, which relies on the following CPU activity variables.\n         */\n        this.nReadsSinceLastEvent = 0;\n        this.nWritesSinceLastEvent = 0;\n        this.nCyclesSinceLastEvent = 0;\n\n        /*\n         * Make sure the auto-injection buffer is empty, too (an injection could have been\n         * in progress on any reset after the first).\n         */\n        this.sInjectBuffer = \"\";\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"esc\", \"ctrl-c\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        /*\n         * I want to bind to the first caller (ie, the Screen), not subsequent ones (eg, the Panel)\n         */\n        if (this.bindings[sBinding] === undefined) {\n            switch(sBinding) {\n            case \"keyDown\":\n                this.bindings[sBinding] = control;\n                control.onkeydown = function(kbd) {\n                    return function(event) {\n                        return kbd.keyEvent(event, true);\n                    };\n                }(this);\n                return true;\n            case \"keyPress\":\n                this.bindings[sBinding] = control;\n                control.onkeypress = function(kbd) {\n                    return function(event) {\n                        return kbd.keyPress(event);\n                    };\n                }(this);\n                return true;\n            case \"keyUp\":\n                this.bindings[sBinding] = control;\n                control.onkeyup = function(kbd) {\n                    return function(event) {\n                        return kbd.keyEvent(event, false);\n                    };\n                }(this);\n                return true;\n            case \"break\":\n                /*\n                 * The BREAK key is unusual: it requires us forcing the equivalent of someone pressing\n                 * our \"Reset\" and \"Run\" buttons.  As things stand, the Computer component is responsible\n                 * for end-user \"reset\" requests, so we can simply arrange to call this.cmp.reset(true).\n                 *\n                 * NOTE: At the risk of making keyPressSimulate() a bit uglier, I also permit BREAK\n                 * there, in case someone wants to \"inject\" the BREAK key; however, if it's followed by\n                 * other injected keys, I'll need to avoid clearing the injection buffer on a reset;\n                 * currently, reset() resets everything.\n                 */\n                this.bindings[sBinding] = control;\n                control.onclick = function(kbd) {\n                    return function(event) {\n                        if (DEBUG) kbd.println(\"keyPressSimulate(break)\");\n                        if (kbd.cmp) kbd.cmp.reset(true);\n                    };\n                }(this);\n                return true;\n            default:\n                if (this.aButtonCodeMap[sBinding] !== undefined) {\n                    this.bindings[sBinding] = control;\n                    control.onclick = function(kbd, sButton, charCode) {\n                        return function(event) {\n                            if (DEBUG) kbd.println(\"keyPressSimulate(\" + sButton + \")\");\n                            if (kbd.cpu) kbd.cpu.setFocus();\n                            return !kbd.keyPressSimulate(charCode);\n                        };\n                    }(this, sBinding, this.aButtonCodeMap[sBinding]);\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.offKbd = start;\n        this.cbKbd = end - start + 1;\n        this.offKbdLimit = this.offKbd + this.cbKbd;\n        if (cpu) {\n            this.cpu = cpu;\n            if (DEBUG) cpu.addReadNotify(start, end, this, this.getByte);\n            cpu.addWriteNotify(start, end, this, this.setByte);\n        }\n        this.setReady();\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} nModel\n     */\n    setModel(nModel)\n    {\n        this.nModel = nModel;\n        /*\n         * Default to Model 600 behavior, where the keyboard status lines are inverted\n         * (ie, a zero bit indicates a key press).\n         */\n        this.bInvert = 0xff;\n        if (this.nModel != 600) {\n            /*\n             * No inversion for model 542\n             */\n            this.bInvert = 0x00;\n            this.println(\"updated keyboard model: \" + this.nModel);\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     *\n     * We make a note of the Computer component, so that we can invoke its reset() method when our simulated\n     * BREAK key is pressed, and we query the Debugger component so that we can use its info() and halt() functions,\n     * which we use to buffer information without adversely affecting timing and then dump later using the Debugger's\n     * \"info\" command.\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            this.cmp = cmp;\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {boolean} [fReady] is assumed to indicate \"ready\" unless EXPLICITLY set to false\n     */\n    setReady(fReady)\n    {\n        this.iOS = Web.isUserAgent(\"iOS\");\n        this.fMobile = (this.iOS || Web.isUserAgent(\"Android\"));\n        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n            this.dbg.message(\"mobile keyboard support: \" + (this.fMobile? \"true\" : \"false\") + \" (\" + window.navigator.userAgent + \")\");\n        }\n        super.setReady();\n    }\n\n    /**\n     * calcReleaseDelay(fRepeat)\n     *\n     * This attempts to scale our default \"release\" delay appropriately for the current CPU speed.\n     *\n     * Note that if the effective CPU speed exceeds 16Mhz, it becomes very difficult to rely on timer-driven key events\n     * (even the shortest available timer delay still gives the CPU too much time, so it thinks that even the briefest key\n     * press represents a held key, resulting in multiple keystrokes).  We deal with this by artificially limiting the top\n     * speed in the CPU component (the current limit for \"fast\" mode is 8Mhz; see CPU.mhzFast)\n     *\n     * @this {C1PKeyboard}\n     * @param {boolean} fRepeat is true if a timeout had already been active for the current key\n     * @return {number}\n     */\n    calcReleaseDelay(fRepeat)\n    {\n        /*\n         * NOTE: This delay affects only the \"up\" delay, not repeat delay, but it's useful to have an initial\n         * \"up\" delay that's sufficiently large to ensure the native machine's auto-repeat behavior cooperates\n         * with the virtual machine's auto-repeat behavior. msReleaseDelay is the initial delay, msReleaseRepeat\n         * is the subsequent delay.\n         *\n         * Unfortunately, with a large initial delay, we need to enable the auto-clear code in the keyEvent()\n         * handler, otherwise doing things like pressing ENTER repeatedly will result in sluggish behavior\n         * (because you can generally press/release/repress keys faster than they will auto-repeat).\n         */\n        var msDelay = (fRepeat? this.msReleaseRepeat: this.msReleaseDelay);\n        if (this.cpu && this.cpu.mhz) {\n            msDelay /= this.cpu.mhz;\n        }\n        return msDelay;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} [notCharCode]\n     */\n    autoClear(notCharCode)\n    {\n        if (this.prevCharDown && (notCharCode === undefined || notCharCode != this.prevCharDown)) {\n            if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n                this.dbg.message(\"autoClear(\" + Str.toHexByte(this.prevCharDown) + \")\");\n            }\n\n            clearTimeout(this.aKeyTimers[this.prevCharDown]);\n            this.keyEventSimulate(this.prevCharDown, false, this.SIMCODE_AUTOCLEAR);\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {string} sKeyCodes\n     * @param {number} [msDelay] is an optional injection delay (default is msInjectDelay)\n     */\n    injectKeys(sKeyCodes, msDelay)\n    {\n        this.sInjectBuffer = sKeyCodes;\n        if (DEBUG) this.log(\"injectKeys(\" + this.sInjectBuffer.split(\"\\n\").join(\"\\\\n\") + \")\");\n        this.injectKeysFromBuffer(msDelay || this.msInjectDelay);\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} msDelay is the delay between injected keys\n     */\n    injectKeysFromBuffer(msDelay)\n    {\n        if (this.sInjectBuffer.length > 0) {\n            var ch = this.sInjectBuffer.charCodeAt(0);\n            /*\n             * I could require all callers to supply CRs instead of LFs, but this is friendlier.\n             */\n            if (ch == 0x0a)\n                ch = 0x0d;\n            /*\n             * Also, if upper-case characters are being injected, convert them to lower-case, and rely\n             * on the virtual SHIFT-LOCK remaining locked for the duration; otherwise, we'd have to simulate\n             * SHIFT key presses around every character (or around the entire set of characters) as well.\n             *\n             * UPDATE: Even though keyPressSimulate() currently has some code to do this automatically now,\n             * it's really intended as a work-around for a SHIFT-related problem on iOS devices only, so\n             * we can't rely on that in the general case.\n             */\n            if (ch >= 0x41 && ch <= 0x5A)\n                ch += 0x20;\n            this.sInjectBuffer = this.sInjectBuffer.substr(1);\n            this.keyPressSimulate(ch);\n        }\n        if (this.sInjectBuffer.length > 0) {\n            setTimeout(function(kbd) { return function() {kbd.injectKeysFromBuffer(msDelay);}; }(this), msDelay);\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {Object} event\n     * @param {boolean} fDown is true if called for a keyDown event, false if called for a keyUp event\n     * @return {boolean} true to pass the event along, false to consume it\n     */\n    keyEvent(event, fDown)\n    {\n        var fPass;\n        var fAutoClear = !fDown;\n        var keyCode = event.keyCode;\n\n        if (fDown) this.prevKeyDown = keyCode;\n\n        if (keyCode == this.CHARCODE_LSHIFT - this.PSEUDO_CHARCODE) {\n            this.bitsShift &= ~this.BIT_LSHIFT;\n            if (fDown) this.bitsShift |= this.BIT_LSHIFT;\n            keyCode += this.PSEUDO_CHARCODE;\n            fAutoClear = false;\n        }\n        else\n        if (keyCode == this.CHARCODE_RSHIFT - this.PSEUDO_CHARCODE) {\n            this.bitsShift &= ~this.BIT_RSHIFT;\n            if (fDown) this.bitsShift |= this.BIT_RSHIFT;\n            keyCode += this.PSEUDO_CHARCODE;\n            fAutoClear = false;\n        }\n        else\n        if (keyCode == this.CHARCODE_CTRL - this.PSEUDO_CHARCODE) {\n            this.bitsShift &= ~this.BIT_CTRL;\n            if (fDown) this.bitsShift |= this.BIT_CTRL;\n            keyCode += this.PSEUDO_CHARCODE;\n            fAutoClear = false;\n        }\n        else\n        if (keyCode == this.CHARCODE_SHIFTLOCK - this.PSEUDO_CHARCODE) {\n            /*\n             * FYI, this generates a \"down\" event ONLY when getting locked, and an \"up\" event ONLY\n             * when getting unlocked--which is exactly what I want, even though that may seem a little\n             * counter-intuitive (since the key itself actually went down AND up for each event).\n             *\n             * Moreover, since most people do NOT have CAPS-LOCK enabled, whereas the C1P needs it\n             * enabled by default, we invert fDown, so that if the user enables CAPS-LOCK for some\n             * reason, we treat is as *disabling* SHIFT-LOCK, and vice versa.\n             */\n            fDown = !fDown;\n            this.bitsShift &= ~this.BIT_SHIFTLOCK;\n            if (fDown) this.bitsShift |= this.BIT_SHIFTLOCK;\n            keyCode += this.PSEUDO_CHARCODE;\n            fAutoClear = false;\n        }\n        else\n        if (keyCode == this.KEYCODE_COMMAND) {\n            /*\n             * Avoid interfering with useful Browser key commands, like COMMAND-Q, COMMAND-T, etc.\n             */\n            this.bitsShift &= ~this.BIT_COMMAND;\n            if (fDown) this.bitsShift |= this.BIT_COMMAND;\n            fAutoClear = false;\n            fPass = true;\n        }\n        else\n        if (keyCode == this.KEYCODE_TAB) {\n            /*\n             * If I don't consume TAB on the \"down\" event, then that's all I'll see, because the\n             * browser will see it and give focus to the next control. But the \"down\" side is that\n             * that no \"press\" event will be generated.  This puts it in the same category as ESC,\n             * which also generates \"down\" and \"up\" events (LOTS of \"down\" events for that matter),\n             * but no \"press\" event.  However, the C1P has no TAB key, so it's safe to completely ignore.\n             */\n            fPass = fAutoClear = false;\n        }\n        else\n        if (keyCode == this.KEYCODE_ESC || keyCode == this.KEYCODE_DELETE) {\n            /*\n             * I don't get keyPress events for ESC (why?) and I never want the browser to act on DELETE\n             * (which does double-duty as the \"Back\" button and leaves the current page), so I have to\n             * simulate them now.\n             *\n             * Note that I call the \"press\" simulate method and NOT the \"event\" simulate method, because\n             * the former takes care of simulating both individual \"down\" and \"up\" events.\n             */\n            if (DEBUG && DEBUGGER && keyCode == this.KEYCODE_ESC && this.dbg) this.dbg.halt();\n            fPass = (fDown? !this.keyPressSimulate(keyCode) : false);\n        }\n        else {\n            /*\n             * Pass on everything else; I'll take care of this key at the keyPress stage, not the\n             * the keyDown or keyUp stage.\n             */\n            fPass = true;\n            /*\n             * At this point, I have a difficult choice to make: leave fAutoClear true for any remaining\n             * \"up\" events, so that keys will repeat immediately when released/pressed repeatedly (most\n             * noticeable with the Enter key), or set fAutoClear to false to ensure that polling apps have\n             * enough time to see every key press.\n             *\n             * I've decided that the former is more important than the latter, so if polling apps are still\n             * missing keystrokes, then perhaps nCyclesThreshold needs to be supplemented in some way.\n             *\n             *      fAutoClear = false;\n             */\n        }\n\n        if (fAutoClear) {\n            /*\n             * When you use a command like COMMAND-T, I see the COMMAND key going down, but not going up,\n             * so I think the COMMAND key is still down and ignore all input; to easily get out of that state,\n             * I clear our internal BIT_COMMAND whenever I see ANY key go up (well, ALMOST any key; cases\n             * above that explicitly clear fAutoClear -- such as the COMMAND key itself -- are exceptions\n             * to the rule).\n             */\n            this.bitsShift &= ~this.BIT_COMMAND;\n            /*\n             * I don't reliably get keyDown/keyUp events for all keys on all devices, but for those devices that\n             * I DO, it seems like a good idea to cancel any pending key \"up\" simulation on receipt of the actual\n             * keyUp event.\n             *\n             * However, the following code is problematic for Safari on iOS devices, which as noted above, doesn't\n             * generate keyDown/keyUp events until after the press operation is complete, and then they are generated\n             * in rapid succession, which doesn't give the C1P enough time to detect the key.  So I simply don't do\n             * this on iOS devices.\n             */\n            if (!this.fMobile && keyCode == this.prevKeyDown) this.autoClear();\n        }\n\n        if (fPass === undefined) {\n            fPass = !this.keyEventSimulate(keyCode, fDown, this.SIMCODE_KEYEVENT);\n        }\n\n        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n            this.dbg.message(/*(fDown?\"\\n\":\"\") +*/ \"key\" + (fDown?\"Down\":\"Up\") + \"(\" + Str.toHexByte(keyCode) + \"): \" + (fPass? \"pass\" : \"consume\"));\n        }\n        return fPass;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {Object} event\n     * @return {boolean} true to pass the event along, false to consume it\n     *\n     * We've stopped relying on keyPress for keyboard emulation purposes, but it's still handy to hook and monitor\n     * when debugging.\n     */\n    keyPress(event)\n    {\n        var fPass = true;\n        /*\n         * Browser-independent charCode extraction...\n         */\n        event = event || window.event;\n        var charCode = event.which || event.keyCode;\n\n        /*\n         * Let's stop any injection currently in progress, too\n         */\n        this.sInjectBuffer = \"\";\n\n        if (this.bitsShift & this.BIT_COMMAND)\n            this.bitsShift &= ~this.BIT_COMMAND;\n        else\n            fPass = !this.keyPressSimulate(charCode);\n\n        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n            this.dbg.message(\"keyPress(\" + Str.toHexByte(charCode) + \"): \" + (fPass? \"pass\" : \"consume\"));\n        }\n        return fPass;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} charCode\n     * @return {boolean} true if successfully simulated, false if unrecognized/unsupported key\n     */\n    keyPressSimulate(charCode)\n    {\n        var fSimulated = false;\n        if (charCode == this.CHARCODE_BREAK) {\n            /*\n             * The BREAK key is not wired up to the keyboard like the other keys are, but we simulate\n             * it here, so that it can be injected like any other key.\n             */\n            if (this.cmp) {\n                this.cmp.reset(true);\n                fSimulated = true;\n            }\n        }\n        else {\n            /*\n             * WARNING: The next line is why you cannot use SHIFT-N, SHIFT-O, SHIFT-P, etc. But without it,\n             * iOS devices with the annoying \"autocapitalization\" feature enabled make the keyboard unusable\n             * by default.  The trade-off is: either require all iOS users to first tap the shift key to turn\n             * \"autocapitalization\" off, or lose the ability to type any of the special shifted alphabetic keys.\n             * I choose the latter, because I have friendlier aliases already defined for those keys (eg,\n             * ^, DELETE, and @).\n             *\n             * Furthermore, by doing this for iOS (and Android) devices ONLY, other platforms retain the ability\n             * to use those special key combos.\n             */\n            if (this.fMobile) {\n                if (charCode >= 0x41 && charCode <= 0x5A)\n                    charCode += 0x20;\n            }\n\n            /*\n             * Auto-clear any previous down key EXCEPT for charCode (because it may be held and repeating).\n             */\n            this.autoClear(charCode);\n\n            if (this.keyEventSimulate(charCode, true, this.SIMCODE_KEYPRESS)) {\n                /*\n                 * If CPU speed is unlimited, then we switch to an alternate approach, which is to immediately\n                 * queue a \"release\" event as well.  The problem with the original timer-based approach at high\n                 * speeds is that the the CPU may get lucky and execute a LOT of instructions between delivery\n                 * of the keyPress event and the \"keyTimeout\" event. In that case, even enabling keyboard polling\n                 * detection in updateMemory() won't entirely help -- although we do that, too -- because JavaScript\n                 * events are delivered synchronously, so it may simply take too long for the \"keyTimeout\" event\n                 * to arrive.\n                 *\n                 * Why don't we ALWAYS do this? Because in the normal case (SPEED_SLOW, and even SPEED_FAST) we want\n                 * to faithfully simulate how long a key is held, so that features like auto-repeat work properly.\n                 * You'll notice in the SPEED_MAX case, holding a key no longer has any effect; even though multiple\n                 * keyPress events WILL arrive, if we simulate a release immediately after each one, then repeat\n                 * is defeated.  Also, the keyboard polling detection code in updateMemory() doesn't work well for\n                 * all apps.\n                 */\n                if (this.cpu.speed == this.cpu.SPEED_MAX) {\n                    this.keyEventSimulate(charCode, false, this.SIMCODE_KEYRELEASE);\n                }\n                else {\n                    var fRepeat = false;\n                    if (this.aKeyTimers[charCode]) {\n                        clearTimeout(this.aKeyTimers[charCode]);\n                        fRepeat = true;\n                    }\n                    var msDelay = this.calcReleaseDelay(fRepeat);\n                    this.aKeyTimers[this.prevCharDown = charCode] = setTimeout(function(kbd) { return function() {kbd.keyEventSimulate(charCode, false, kbd.SIMCODE_KEYTIMEOUT);}; }(this), msDelay);\n                    if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n                        this.dbg.message(\"keyPressSimulate(\" + Str.toHexByte(charCode) + \"): setTimeout()\");\n                    }\n                }\n                fSimulated = true;\n            }\n        }\n        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_KBD)) {\n            this.dbg.message(\"keyPressSimulate(\" + Str.toHexByte(charCode) + \"): \" + (fSimulated? \"true\" : \"false\"));\n        }\n        return fSimulated;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} charCode\n     * @param {boolean} fDown\n     * @param {number} simCode indicates the origin of the event\n     * @return {boolean} true if successfully simulated, false if unrecognized/unsupported key\n     */\n    keyEventSimulate(charCode, fDown, simCode)\n    {\n        var fSimulated = false;\n        if (!fDown) {\n            this.aKeyTimers[charCode] = null;\n            if (this.prevCharDown == charCode) this.prevCharDown = 0;\n        }\n        var bShift = 0;\n        var bCode = this.aCharCodeMap[charCode];\n        if (bCode === undefined) {\n            /*\n             * Perhaps we're dealing with a CTRL variation of an alphabetic key; this won't\n             * affect non-CTRL-key combos like CR or LF, because they're defined in aCharCodeMap,\n             * and this bit of code relieves us from having to explicitly define every CTRL-letter\n             * possibility in aCharCodeMap. However, CTRL-anything-else is a different matter.\n             */\n            if (charCode >= 0x01 && charCode <= 0x1A) {\n                charCode += 0x40;\n                bShift = this.CHARCODE_CTRL;\n            }\n            bCode = this.aCharCodeMap[charCode];\n        }\n        if (bCode !== undefined) {\n            var iRow = bCode >> 12;\n            var iCol = (bCode >> 8) & 0xf;\n            if (!bShift) bShift = bCode & 0xff;\n            if (fDown) {\n                this.abKbdCols[iRow] |= 1 << iCol;\n                if (bShift == this.CHARCODE_CTRL)\n                    this.abKbdCols[0] |= this.BIT_CTRL;\n                else\n                if (bShift == this.CHARCODE_LSHIFT)\n                    this.abKbdCols[0] |= this.BIT_LSHIFT;\n                else\n                if (bShift == this.CHARCODE_RSHIFT)\n                    this.abKbdCols[0] |= this.BIT_RSHIFT;\n                else\n                    this.abKbdCols[0] &= ~this.BITS_SIMULATE;\n            }\n            else {\n                this.abKbdCols[iRow] &= ~(1 << iCol);\n                this.abKbdCols[0] &= ~this.BITS_SIMULATE;\n                this.abKbdCols[0] |= (this.bitsShift & this.BITS_SIMULATE);\n            }\n            var fPropagate = (simCode == this.SIMCODE_KEYPRESS && !this.aKbdStates.length);\n            this.aKbdStates.push(this.abKbdCols.slice());\n            this.updateMemory(fPropagate);\n            fSimulated = true;\n        }\n        if (DEBUG && this.dbg) this.dbg.info(\"keyEventSimulate(\" + Str.toHexByte(charCode) + \",\" + (fDown?\"down\":\"up\") + \",\" + this.aSimCodeDescs[simCode] + \"): \" + (fSimulated? \"true\" : \"false\"));\n        return fSimulated;\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} addr\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n     *\n     * NOTE: As long as we rely on the CPU processing a certain number of cycles (nCyclesThreshold) before\n     * propagating the next kbd state, and not how many reads and/or writes the CPU has performed, we could\n     * eliminate the overhead of this read-notification handler.\n     *\n     * It's useful for diagnostic purposes, which is why it's still here.\n     */\n    getByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this read (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (DEBUG) {\n            if (addrFrom !== undefined) {\n                this.nReadsSinceLastEvent++;\n                if (DEBUG && this.dbg) this.dbg.info(\"reading kbd \" + Str.toHexWord(addr) + \" @\" + this.cpu.getCycles() + \" cycles\");\n            }\n        }\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {number} addr\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to write the specified addr)\n     *\n     * NOTE: Ordinarily, I wouldn't allow Debugger writes (addrFrom === undefined) to interfere with the simulated\n     * hardware state, but for now, I find it useful to be able to prod the simulation code directly from the Debugger.\n     */\n    setByte(addr, addrFrom)\n    {\n        var b = this.cpu.getByte(addr);\n        this.bKbdRows = b ^ this.bInvert;\n        this.nWritesSinceLastEvent++;\n        this.updateMemory(false, addr, b);\n    }\n\n    /**\n     * @this {C1PKeyboard}\n     * @param {boolean} fPropagate is true to propagate immediately, false to use normal propagation\n     * @param {number} [addr] is the memory address to update; default is the entire memory range\n     * @param {number} [bWrite] is the value of any immediately preceding write, or undefined if none\n     *\n     * Update emulated keyboard memory.  By updating the keyboard memory whenever it's written to,\n     * as well as whenever a key is pressed or released, I avoid the hit of a read-notification handler.\n     * Besides, read-notification handlers are called only AFTER the read has been performed, so it\n     * would be too late to update the memory at that point.\n     *\n     * WARNING: There is a slight risk of an application reading from a different keyboard memory address\n     * than it just wrote to.  That would be legal, but very odd, and we save valuable time by not updating\n     * every other byte in the entire memory range every time a different keyboard \"row\" is selected.\n     */\n    updateMemory(fPropagate, addr, bWrite)\n    {\n        /*\n         * First, we determine if it's time for event propagation...\n         */\n        var nCycles = this.cpu.getCycles();\n\n        /*\n         * Monitoring the C1P's keyboard polling activity is problematic, because not all apps monitor\n         * the keyboard in the same way.  It's better to simply wait for a certain amount of CPU activity to\n         * occur (nCyclesThreshold); it's more reliable and it scales well, because it's not affected by\n         * how many cycles we're executing in real time.  The trick is finding a value for nCyclesThreshold\n         * that works well across the board.\n         */\n        if (!fPropagate) {\n            if (this.cpu.speed == this.cpu.SPEED_MAX)\n                fPropagate = (addr !== undefined && this.nWritesSinceLastEvent >= 32);\n            else {\n                /*\n                 * We have to handle the delta being less than zero, in case the user changed the speed, thereby\n                 * resetting the cycle count returned by getCycles().\n                 */\n                var nCycleDelta = nCycles - this.nCyclesSinceLastEvent;\n                fPropagate = (nCycleDelta < 0 || nCycleDelta >= this.nCyclesThreshold);\n            }\n        }\n\n        /*\n         * Next, we propagate any buffered state (in abKbdStates) as appropriate\n         */\n        if (fPropagate) {\n            var abKbdCols = this.aKbdStates.shift();\n            if (abKbdCols !== undefined) {\n                if (DEBUG && this.dbg) this.dbg.info(\"kbd update @\" + nCycles + \" cycles, \" + this.nWritesSinceLastEvent + \" writes\");\n                this.abKbdColsLast = abKbdCols;\n            }\n            this.nReadsSinceLastEvent = this.nWritesSinceLastEvent = 0;\n            this.nCyclesSinceLastEvent = nCycles;\n        }\n        /*\n         * Then we calculate the value (which may or may not have just been propagated),\n         * based on the currently selected keyboard row(s) (bKbdRows).\n         */\n        var b = 0;\n        for (var iRow=0; iRow < 8; iRow++) {\n            if (!(this.bKbdRows & (1 << iRow)))\n                continue;\n            b |= this.abKbdColsLast[iRow];\n        }\n        /*\n         * Now invert all the bits, since I SET the column bit of an \"active\" key,\n         * whereas the C1P Model 600 keyboard expects \"active\" column bits to be CLEAR.\n         */\n        b ^= this.bInvert;\n\n        if (addr !== undefined) {\n            this.abMem[addr] = b;\n        }\n        else {\n            addr = this.offKbd;\n            if (b != this.bWriteLast) {\n                for (var offset=addr; offset < this.offKbdLimit; offset++)\n                    this.abMem[offset] = b;\n            }\n        }\n        this.bWriteLast = b;\n        if (DEBUG && this.dbg) this.dbg.info(\"updating kbd \" + Str.toHexWord(addr) + \" with \" + Str.toHexByte(b) + (bWrite !== undefined? (\" following write \" + Str.toHexByte(bWrite)) : \"\") + \" @\" + nCycles + \" cycles\");\n    }\n\n    /**\n     * isShift()\n     *\n     * @this {C1PKeyboard}\n     * @param {number} charCode\n     * @return {boolean}\n     *\n     isShift(charCode)\n     {\n         return charCode == this.CHARCODE_LSHIFT || charCode == this.CHARCODE_RSHIFT || charCode == this.CHARCODE_CTRL || charCode == this.CHARCODE_SHIFTLOCK;\n     }\n     */\n\n    /**\n     * C1PKeyboard.init()\n     *\n     * This function operates on every HTML element of class \"keyboard\", extracting the\n     * JSON-encoded parameters for the C1PKeyboard constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PKeyboard component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeKbd = Component.getElementsByClass(document, C1PJS.APPCLASS, \"keyboard\");\n        for (var iKbd=0; iKbd < aeKbd.length; iKbd++) {\n            var eKbd = aeKbd[iKbd];\n            var parmsKbd = Component.getComponentParms(eKbd);\n            var kbd = new C1PKeyboard(parmsKbd);\n            Component.bindComponentControls(kbd, eKbd, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize every Keyboard module on the page.\n */\nWeb.onInit(C1PKeyboard.init);\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/video.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PVideo extends Component {\n    /**\n     * C1PVideo(parmsVideo, canvas, context, imgChars)\n     *\n     * The Video component can be configured with the following (parmsVideo) properties:\n     *\n     *      model: model number (one of: 540 or 600; 600 is the default)\n     *      screenWidth: width of the screen window, in pixels\n     *      screenHeight: height of the screen window, in pixels\n     *      charCols: number of character columns\n     *      charRows: number of character rows\n     *      charWidth: width of charSet characters, in pixels (default is 0)\n     *      charHeight: height of charSet characters, in pixels (default is 0)\n     *      charSet: path to image (eg, PNG) file that defines the character set\n     *      screenColor: background color of the screen window (default is black)\n     *\n     * The Video object assumes that the video buffer is organized such that offset 0 is mapped\n     * to the left-most column and top-most row (col=0,row=0), offset 1 is (1,0), offset 2\n     * is (2,0), and so on.\n     *\n     * The Video object initially contains no underlying video buffer; memory for the buffer\n     * must be given to it by the Computer object.  We allocate a separate buffer, called\n     * the screen buffer, into which we periodically copy the contents of the video buffer\n     * via updateScreen(); any differences between the two buffers are then rendered in the\n     * associated window, via updateWindow().\n     *\n     * When updateScreen() finds a byte in the screen buffer must be redisplayed, it converts\n     * the offset of that byte into a (col,row) character position for the updateWindow() function,\n     * which then converts (col,row) into (x,y) pixel offsets within the underlying canvas.\n     *\n     * Regarding the C1P (aka Model 600): The C1P has a 1K video buffer located at 0xD000-0xD3FF.\n     * The ROM draws the initial \"D/C/W/M ?\" prompt at the \"bottom\" of the video buffer at location\n     * 0xD365. That row really begins at 0xD360, but the C1P \"indents\" everything by 5 columns due\n     * to the lack of a \"guard band feature.\"  Similarly, BASIC defaults to a width of 24 columns\n     * avoid display problems near the right edge.  BASIC will let you choose a width SMALLER than\n     * 24 but not larger. So, while the video buffer supports a theoretical maximum of 32 rows x 32\n     * columns, the practical maximum is 25 rows x 24 columns; the last 4 rows of the video buffer\n     * are never used, and while content DOES scroll through the top 3 lines of the buffer, it should\n     * never be assumed that you can see the top 3 lines.\n     *\n     * This is partially confirmed by the \"C1P Character Graphics Reference Manual\", p3, which says\n     * that the \"the visible character field consists of 25 lines of 25 columns\" and that the \"first\n     * visible character in the upper left of the screen is accessed via address 53379,\" or 0xD083.\n     * However, they were wrong about both the number of columns and the first visible character.\n     *\n     * They probably meant 0xD085, because as mentioned earlier, the C1P indents every row by 5\n     * characters, not 3.  But that's not correct either, because the difference between 0xD365\n     * (where the bottom line starts) and 0xD085 is 0x2E0, or 736.  736 divided by 32 equals 23;\n     * add the bottom row, and that would give you 24 visible rows, not 25.  Since we now have\n     * screenshots of a C1P monitor displaying 25 rows (courtesy of Stephan Mhlstrasser), C1Pjs\n     * now assumes that only the first 3 lines are not visible, and that the address of the first\n     * visible character is actually 0xD065 (53349), yielding 25 visible rows.\n     *\n     * All of this explains why we now use setDimensions(iRowTop=3, nRowsVisible=25) instead of\n     * setDimensions(iRowTop=4, nRowsVisible=24) for the Model 600.\n     *\n     * Model 540 Video Board vs. Model 600 \"Superboard II\"\n     * ---------------------------------------------------\n     * This emulation was originally written for the Model 600 \"Superboard II\" (eg, Challenger 1P).\n     * Support for the Model 540 video board (as used in the Challenger II-4P and II-8P) was added\n     * later.\n     *\n     * NOTE: When Model 540 video emulation is enabled, Model 542 keyboard emulation must also be\n     * enabled, because the former always came with the latter keyboard interface; this is why when\n     * we call this.setModel(540), we must also notify the Keyboard via kbd.setModel(542).\n     *\n     * Key features/differences of the Model 540 video board include:\n     *\n     *      2K (8 pages) of video memory located at 0xD000-0xD7FF\n     *      Two display modes: 32 rows x 64 cols (default on power up), and 32 rows x 32 cols\n     *      64 bytes per screen row, regardless which display mode is selected\n     *      The following options can be selected via WRITE to port address 0xDE00:\n     *          Bit 0: clear to enable 32/64 mode (default on power up), set to enable 32/32\n     *          Bit 1: 1=tone on (542 keyboard)\n     *          Bit 2: 1=color on (Rev. B only?)\n     *          bit 3: 1=enable 38-40Khz AC Home control output (Rev. B only?)\n     *      Video timing counter status via READ from port address 0xDE00:\n     *          Bit 7: 0 for 1/120 second, then 1 for 1/120 second, based on video clock (60Hz)\n     *\n     * @this {C1PVideo}\n     * @param {Object} parmsVideo\n     * @param {HTMLCanvasElement} canvas\n     * @param {CanvasRenderingContext2D} context\n     * @param {HTMLImageElement} imgChars\n     */\n    constructor(parmsVideo, canvas, context, imgChars)\n    {\n        super(\"C1PVideo\", parmsVideo);\n\n        this.nDefaultModel = parmsVideo['model'];\n        this.nDefaultCols = parmsVideo['charCols'];\n        this.nDefaultRows = parmsVideo['charRows'];\n\n        this.cxScreen = parmsVideo['screenWidth'];\n        this.cyScreen = parmsVideo['screenHeight'];\n\n        /*\n         * These (source) character dimensions are tentative, and may not even be provided,\n         * but they will become definitive once imgChars has finished loading and setReady() is called.\n         */\n        this.cxChar = parmsVideo['charWidth'];\n        this.cyChar = parmsVideo['charHeight'];\n\n        /*\n         * This is a preliminary call to setDimensions(), to initialize default screen buffer and\n         * window dimensions.  A more extensive call to setDimensions() will take place when setModel()\n         * is called later, from reset() and possibly via the tripGuard() handler.\n         *\n         * This preliminary call merely establishes a default screen buffer size, so that when\n         * setBuffer() is called, it's able to verify the assigned address space is at least as big\n         * as the screen buffer.\n         */\n        this.setDimensions();\n\n        this.canvasScreen = canvas;\n        this.contextScreen = context;\n        this.imgChars = imgChars;\n\n        /*\n         * Support for disabling (or, less commonly, enabling) image smoothing, which all browsers\n         * seem to support now (well, OK, I still have to test the latest MS Edge browser), despite\n         * it still being labelled \"experimental technology\".  Let's hope the browsers standardize\n         * on this.  I see other options emerging, like the CSS property \"image-rendering: pixelated\"\n         * that's apparently been added to Chrome.  Sigh.\n         */\n        var i, sEvent, asWebPrefixes = ['', 'moz', 'ms', 'webkit'];\n        var fSmoothing = parmsVideo['smoothing'];\n        var sSmoothing = Web.getURLParm('smoothing');\n        if (sSmoothing) fSmoothing = (sSmoothing == \"true\");\n        if (fSmoothing != null) {\n            for (i = 0; i < asWebPrefixes.length; i++) {\n                sEvent = asWebPrefixes[i];\n                if (!sEvent) {\n                    sEvent = 'imageSmoothingEnabled';\n                } else {\n                    sEvent += 'ImageSmoothingEnabled';\n                }\n                if (this.contextScreen[sEvent] !== undefined) {\n                    this.contextScreen[sEvent] = fSmoothing;\n                    break;\n                }\n            }\n        }\n\n        /*\n         * QUESTION: Does this video port exist only on the Model 540?\n         */\n        this.addrVideoPort = 0xDE00;        // WARNING: Hard-coded port address -JP\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {boolean} [fPowerOn] is true for the initial reset, so that we have\n     * the option of rendering \"random\" graphic characters, just like the real machine would do.\n     */\n    reset(fPowerOn)\n    {\n        this.setModel(this.nDefaultModel);\n\n        if (this.abMem) {\n            /*\n             * Let's treat every reset like a power-cycle, just for fun.\n             * If you don't think that's fun, then simply remove the next line.\n             *\n                fPowerOn = true;\n             */\n            for (var offset = this.offVideo; offset < this.offVideoLimit; offset++) {\n                var b = (fPowerOn? Math.floor(Math.random() * 256) : 0x20);\n\n                this.abMem[offset] = b;\n            }\n        }\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"refresh\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        switch(sBinding) {\n        case \"refresh\":\n            this.bindings[sBinding] = control;\n            control.onclick = function(video) {\n                return function() {\n                    if (DEBUG) video.println(\"refreshScreen()\");\n                    video.initScreen();\n                    video.updateScreen();\n                };\n            }(this);\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.offVideo = start;\n        this.cbVideo = end - start + 1;\n        this.offVideoLimit = this.offVideo + this.cbVideo;\n\n        if (cpu) {\n            this.cpu = cpu;\n            if (this.addrVideoPort !== undefined) {\n                cpu.addReadNotify(this.addrVideoPort, this.addrVideoPort, this, this.getByte);\n                cpu.addWriteNotify(this.addrVideoPort, this.addrVideoPort, this, this.setByte);\n            }\n        }\n        this.reset(true);\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number|undefined} [nCols] (default is nDefaultCols)\n     * @param {number|undefined} [nRows] (default is nDefaultRows)\n     * @param {number|undefined} [iRowTop] (eg, 4; default is 0)\n     * @param {number|undefined} [nRowsVisible] (eg, 24; default is nRows)\n     */\n    setDimensions(nCols, nRows, iRowTop, nRowsVisible)\n    {\n        this.nCols = (nCols !== undefined? nCols : this.nDefaultCols);\n        this.nRows = (nRows !== undefined? nRows : this.nDefaultRows);\n        this.cbScreen = this.nCols * this.nRows;\n        this.offVideoLimit = this.offVideo + this.cbScreen;\n        /*\n         * Set the first visible row and total visible rows next\n         */\n        this.iRowTop = (iRowTop !== undefined? iRowTop : 0);\n        this.nRowsVisible = (nRowsVisible !== undefined? nRowsVisible : nRows);\n        this.setDrawingDimensions();\n    }\n\n    /**\n     * @this {C1PVideo}\n     *\n     * cxScreen and cyScreen give us the overall dimensions of the destination surface.  Dividing that by the number of\n     * columns and rows yields a target cell size (cxCharDst,cyCharDst), which may or may not map 1-1 to the source cell size\n     * (cxChar,cyChar).\n     */\n    setDrawingDimensions()\n    {\n        this.cxCharDst = Math.floor(this.cxScreen / this.nCols);\n        this.cyCharDst = Math.floor(this.cyScreen / this.nRowsVisible);\n    }\n\n    /**\n     * @this {C1PVideo}\n     */\n    setFocus()\n    {\n        this.canvasScreen.focus();\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} nModel\n     */\n    setModel(nModel)\n    {\n        this.nModel = nModel;\n        /*\n         * Default to model 600 behavior (1K video buffer);\n         * the only other supported model is 540 (2K video buffer).\n         */\n        if (this.nModel == 600) {\n            this.setDimensions(this.nDefaultCols, this.nDefaultRows, 3, 25);\n            if (this.cbScreen == 1024 && this.cpu) {\n                /*\n                 * NOTE: We deliberately set the guard address to the LAST byte of the 2K\n                 * buffer range, not the FIRST byte, which has the same effect but with the\n                 * added benefit of deferring any screen update until after the \"Model 540\"\n                 * screen initialization code has completely blanked the entire 2K buffer,\n                 * avoiding a brief flicker of unsightly characters.\n                 */\n                this.addrGuard = this.offVideoLimit + this.cbScreen - 1;\n                this.cpu.addWriteNotify(this.addrGuard, this.addrGuard, this, this.tripGuard);\n            }\n        }\n        else {\n            this.println(\"updated video model: \" + this.nModel);\n            this.setDimensions(64, 32);\n        }\n        this.initScreen();\n        this.updateScreen();\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        /*\n         * NOTE: No one should be calling power(true) before first checking isReady(), but we check\n         * it ourselves, too.  This also means that updateScreen() need check only fPower and not isReady(),\n         * since we guarantee that the former implies the latter.\n         */\n        if (fOn && !this.flags.powered && this.isReady()) {\n            this.flags.powered = true;\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n            /*\n             * If we have an associated keyboard, then ensure that the keyboard will be notified whenever\n             * the canvas gets focus and receives input.\n             *\n             * Also, when simulating a Model 540 video board, we need to access to the Keyboard component due\n             * to some shared I/O responsibilities; ie, bit 1 of the video control port at 0xDE00 enables whatever\n             * tone has been selected via the keyboard frequency port at 0xDF01 (frequency == 49152/n, where n\n             * is the value stored at 0xDF01).\n             */\n            this.kbd = cmp.getComponentByType(\"keyboard\");\n            if (this.kbd) {\n                this.kbd.setBinding(\"canvas\", \"keyDown\", this.canvasScreen);\n                this.kbd.setBinding(\"canvas\", \"keyPress\", this.canvasScreen);\n                this.kbd.setBinding(\"canvas\", \"keyUp\", this.canvasScreen);\n            }\n        }\n        else\n        if (!fOn && this.flags.powered) {\n            this.flags.powered = false;\n            /*\n             * This is where we would add some method of blanking the display, without the disturbing the video\n             * buffer contents, and blocking all further updates to the display.\n             */\n        }\n    }\n\n    /**\n     * cxChar and cyChar are the source cell size.  Originally, those values came strictly from the parmsVideo\n     * 'charWidth' and 'charHeight' properties.  Now, if those aren't defined (which is normally the case now),\n     * then we infer the source cell size from the dimensions of imgChars, which is expected to be a 16x16 array of\n     * character bitmaps.  We could be even more flexible, by allowing imgChars to be any rectangular dimension\n     * (eg, 1x256) as long as we can assume it contains exactly 256 characters, but there's no need to get carried away.\n     *\n     * @this {C1PVideo}\n     * @param {boolean} [fReady] is assumed to indicate \"ready\" unless EXPLICITLY set to false\n     */\n    setReady(fReady)\n    {\n        if (!this.cxChar) this.cxChar = Math.floor(this.imgChars.width / 16);\n        if (!this.cyChar) this.cyChar = Math.floor(this.imgChars.height / 16);\n        super.setReady();\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} addr (ie, addrVideoPort)\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n     *\n     * NOTE: Ordinarily, I wouldn't allow Debugger writes (addrFrom === undefined) to interfere with the simulated\n     * hardware state, but for now, I find it useful to be able to prod the simulation code directly from the Debugger.\n     */\n    getByte(addr, addrFrom)\n    {\n        var b = this.cpu.getByte(addr);\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_VIDEO);\n        }\n        /*\n         * The only documented READ bit in addrVideoPort is bit 7, which is supposed to alternate between\n         * 0 and 1 every 1/120 of a second.  There's no way we're going to add special code to the emulator to update\n         * this stupid byte every 8,333 cycles (assuming 1Mhz operation), so clearly we're going to fake it.\n         *\n         * Faking it means that any polling code will unavoidably get a stale value the FIRST time it reads bit 7.\n         * However, we can still do a pretty good job of faking any EXTENSIVE polling: get the number of cycles\n         * executed so far, divide that by 8333, floor the quotient, and then set/clear bit 7 according to whether the\n         * result is odd/even.\n         */\n        var nCyclesHigh = Math.floor(this.cpu.getCycles() / 8333);\n        this.cpu.setByte(addr, (b & 0x7F) | ((nCyclesHigh & 0x1)? 0x80 : 0));\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} addr (ie, addrVideoPort)\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to write the specified addr)\n     */\n    setByte(addr, addrFrom)\n    {\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_VIDEO);\n        }\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} addr (ie, addrGuard)\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n     */\n    tripGuard(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this read (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_VIDEO, true);\n            /*\n             * The CPU has just written to the guard address we established just beyond the video buffer's 1K boundary,\n             * implying that the system thinks we have a 2K buffer instead.  So we bump our model to 540, bump the\n             * associated keyboard model to 542, and remove this guard handler.\n             */\n            this.setModel(540);\n            if (this.kbd) this.kbd.setModel(542);\n            this.cpu.removeWriteNotify(this.addrGuard, this.addrGuard, this, this.tripGuard);\n        }\n    }\n\n    /**\n     * @this {C1PVideo}\n     */\n    initScreen()\n    {\n        this.abScreen = new Array(this.cbScreen);\n        for (var offset=0; offset <= this.cbScreen; offset++) {\n            this.abScreen[offset] = -1; // initialize every cell of the screen to an invalid value\n        }\n    }\n\n    /**\n     * updateScreen() updates the screen buffer from the video buffer and updates the window with any changes.\n     *\n     * @this {C1PVideo}\n     * @return {boolean}\n     *\n     * For every byte in the video buffer, this renders it if it differs from the byte stored in the screen buffer,\n     * and then updates the screen buffer to match.  Since initScreen() sets every byte in the screen buffer\n     * to an illegal byte value (ie, a value which is outside the byte range 0x00-0xff), that assures the first call\n     * to updateScreen() will redraw every byte in the video buffer.\n     */\n    updateScreen()\n    {\n        var offset = 0;\n        if (this.flags.powered) {\n            while (offset < this.cbScreen) {\n                var b = this.abMem[this.offVideo + offset];\n                if (this.abScreen[offset] != b) {\n                    if (!this.writeByte(offset, b)) {\n                        break;\n                    }\n                    this.abScreen[offset] = b;\n                }\n                offset++;\n            }\n        }\n        return (offset == this.cbScreen);\n    }\n\n    /**\n     * @this {C1PVideo}\n     * @param {number} offset\n     * @param {number} b\n     * @return {boolean}\n     */\n    writeByte(offset, b)\n    {\n        var col = offset % this.nCols;\n        var row = Math.floor(offset / this.nCols);\n        return this.updateWindow(col, row, b);\n    }\n\n    /**\n     * updateWindow(col, row, b)\n     *\n     * Updates a particular position (row,col) in the associated window with the given byte (b)\n     *\n     * @this {C1PVideo}\n     * @param {number} col\n     * @param {number} row\n     * @param {number} b\n     * @return {boolean} true if successful, false if not\n     *\n     * I originally used (screenWidth,screenHeight) == (512,448) and (cols,rows) == (32,32) and (cxChar,cyChar) == (16,16),\n     * and I simply copied the source cells 1-to-1 to the destination (16,16), knowing that we would never try to display\n     * more than 28 rows (the last 4 rows of the 32 possible rows were never used to display any content).  However, I should\n     * still have ignored any attempt to draw past row 28 (aka screenHeight 448).  I now perform row clipping and biasing,\n     * according to the first visible row (iRowTop) and total visible rows (nRowsVisible).\n     *\n     * Moreover, I no longer copy the source cell images to the destination 1-to-1.  I calculate (cxCharDst,cyCharDst)\n     * separately (see setDrawingDimensions).  And I no longer assume that (cxChar,cyChar) are (16,16); once the source\n     * image file has finished loading, I calculate (cxChar,cyChar) based on the size of image file (see setReady).  I made\n     * this change when I created chargen1x.png.  In fact, at first I thought I might be able to eliminate chargen2x.png\n     * and just let drawImage() scale up the individual character images from (8,8) to (16,16) or whatever (cxCharDst,cyCharDst)\n     * size was needed, but the results were fuzzy, so it's still best to use chargen2x.png when using larger window sizes.\n     */\n    updateWindow(col, row, b)\n    {\n        if (row >= this.iRowTop) {\n            row -= this.iRowTop;\n            if (row < this.nRowsVisible) {\n                var xChar = (b * this.cxChar);\n                var ySrc = Math.floor(xChar / this.imgChars.width) * this.cyChar;\n                var xSrc = xChar % this.imgChars.width;\n                var xDst = col * this.cxCharDst;\n                var yDst = row * this.cyCharDst;\n                // if (DEBUG) this.log(\"updateWindow(\" + col + \",\" + row + \",\" + b +\"): drawing from \" + xSrc + \",\" + ySrc + \" to \" + xDst + \",\" + yDst);\n                this.contextScreen.drawImage(this.imgChars, xSrc, ySrc, this.cxChar, this.cyChar, xDst, yDst, this.cxCharDst, this.cyCharDst);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * C1PVideo.init()\n     *\n     * This function operates on every HTML element of class \"video\", extracting the\n     * JSON-encoded parameters for the C1PVideo constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PVideo component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeVideo = Component.getElementsByClass(document, C1PJS.APPCLASS, \"video\");\n        for (var iVideo=0; iVideo < aeVideo.length; iVideo++) {\n            var eVideo = aeVideo[iVideo];\n            var parmsVideo = Component.getComponentParms(eVideo);\n\n            /*\n             * As noted in keyboard.js, the keyboard on an iOS device pops up with the SHIFT key depressed,\n             * which is not the initial keyboard state that the C1P expects. I originally tried to fix that by\n             * adding an 'autocapitalize=\"off\"' attribute alongside the 'contenteditable=\"true\"' attribute\n             * on the <canvas> element, but apparently Safari honors that only inside certain elements (eg, <input>).\n             *\n             * I've since settled on a better work-around in keyboard.js, so I've stopped worrying about how to make\n             * \"autocapitalize\" work here.\n             */\n            var eCanvas = /** @type {HTMLCanvasElement} */ (document.createElement(\"canvas\"));\n            if (eCanvas === undefined || !eCanvas.getContext) {\n                eVideo.innerHTML = \"<br/>Missing &lt;canvas&gt; support. Please try a newer web browser.\";\n                return;\n            }\n            eCanvas.setAttribute(\"class\", C1PJS.APPCLASS + \"-canvas\");\n            eCanvas.setAttribute(\"width\", parmsVideo['screenWidth']);\n            eCanvas.setAttribute(\"height\", parmsVideo['screenHeight']);\n\n            eCanvas.setAttribute(\"contenteditable\", \"true\");\n            eCanvas.setAttribute(\"autocapitalize\", \"off\");\n            eCanvas.setAttribute(\"autocorrect\", \"off\");\n            eCanvas.style.backgroundColor = parmsVideo['screenColor'];\n\n            /*\n             * HACK: A canvas style of \"auto\" provides for excellent responsive canvas scaling in EVERY browser\n             * except IE9/IE10, so I recalculate the appropriate CSS height every time the parent DIV is resized;\n             * IE11 works without this hack, so we take advantage of the fact that IE11 doesn't report itself as \"MSIE\".\n             */\n            eCanvas.style.height = \"auto\";\n            if (Web.getUserAgent().indexOf(\"MSIE\") >= 0) {\n                eCanvas.style.height = (((eVideo.clientWidth * parmsVideo['screenHeight']) / parmsVideo['screenWidth']) | 0) + \"px\";\n                eVideo.onresize = function(eParent, eChild, cx, cy) {\n                    return function() {\n                        eChild.style.height = (((eParent.clientWidth * cy) / cx) | 0) + \"px\";\n                    };\n                }(eVideo, eCanvas, parmsVideo['screenWidth'], parmsVideo['screenHeight']);\n            }\n            eVideo.appendChild(eCanvas);\n\n            /*\n             * Now we can create the Video object, record it, and wire it up to the associated document elements.\n             *\n             * Regarding \"new Image()\", see https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement.Image:\n             *\n             *      This constructor exists for historical reasons only and returns an HTMLImageElement instance just as\n             *      document.createElement('img') would.\n             */\n            var imgCharSet = new Image();\n            var eContext = /** @type {CanvasRenderingContext2D} */ (eCanvas.getContext(\"2d\"));\n            var video = new C1PVideo(parmsVideo, eCanvas, eContext, imgCharSet);\n            imgCharSet.onload = function(video, sCharSet) {\n                return function() {\n                    if (DEBUG) video.log(\"onload(): finished loading \" + sCharSet);\n                    video.setReady();\n                };\n            }(video, parmsVideo['charSet']);        // jshint ignore:line\n            imgCharSet.src = parmsVideo['charSet'];\n\n            /*\n             * Bind any video-specific controls (eg, the Refresh button). There are no essential controls, however;\n             * even the \"Refresh\" button is just a diagnostic tool, to verify that the screen contents are up-to-date.\n             */\n            Component.bindComponentControls(video, eVideo, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize every Video module on the page.\n */\nWeb.onInit(C1PVideo.init);\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/serial.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PSerialPort extends Component {\n    /**\n     * C1PSerialPort(parmsSerial)\n     *\n     * The SerialPort component has no component-specific parameters.\n     *\n     * @this {C1PSerialPort}\n     * @param {Object} parmsSerial\n     */\n    constructor(parmsSerial)\n    {\n        super(\"C1PSerialPort\", parmsSerial);\n\n        this.flags.powered = false;\n        this.fDemo = parmsSerial['demo'];\n\n        this.reset(true);\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {boolean} [fHard]\n     */\n    reset(fHard)\n    {\n        /*\n         * Because we reset the machine at the start of a 6502 HEX command file auto-load,\n         * we must avoid tossing the serial port's input buffer in that particular case (2).\n         */\n        if (fHard || this.autoLoad != C1PSerialPort.AUTOLOAD_6502) {\n\n            this.bInput = -1;\n            this.iInput = 0;\n            this.sInput = \"\";\n            if (this.fDemo) {\n                this.sInput = \"10 PRINT \\\"HELLO OSI #\" + this.getMachineNum() + \"\\\"\\n\";\n            }\n\n         // this.sOutput = new Array(0);\n         // this.iOutputNext = 0;\n\n            this.fConvertLF = true;\n            this.autoLoad = C1PSerialPort.AUTOLOAD_NONE;\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     */\n    start()\n    {\n        if (this.kbd && this.fDemo) {\n            this.kbd.injectKeys(\" C\\n\\n\", 3000);     // override the default injection delay (currently 300ms)\n            setTimeout(function(serial) { return function() {serial.startLoad();}; }(this), 12000);\n        }\n        this.fDemo = false;\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"listSerial\")\n     * @param {Object} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        var serial = this;\n\n        switch(sBinding) {\n\n        case \"listSerial\":\n            this.bindings[sBinding] = control;\n            return true;\n\n        case \"loadSerial\":\n            this.bindings[sBinding] = control;\n\n            control.onclick = function onClickLoadSerial(event) {\n                if (serial.bindings[\"listSerial\"]) {\n                    var sFile = serial.bindings[\"listSerial\"].value;\n                    // serial.println(\"loading \" + sFile + \"...\");\n                    Web.getResource(sFile, null, true, function(sURL, sResponse, nErrorCode) {\n                        serial.loadFile(sURL, sResponse, nErrorCode);\n                    });\n                }\n            };\n            return true;\n\n        case \"mountSerial\":\n            /*\n             * Check for non-mobile (desktop) browser and the availability of FileReader\n             */\n            if (!Web.isMobile() && window && 'FileReader' in window) {\n                this.bindings[sBinding] = control;\n                /*\n                 * Enable \"Mount\" button only if a file is actually selected\n                 */\n                control.onchange = function onChangeMountSerial() {\n                    var fieldset = control.children[0];\n                    var files = fieldset.children[0].files;\n                    var submit = fieldset.children[1];\n                    submit.disabled = !files.length;\n                };\n                control.onsubmit = function onSubmitMountSerial(event) {\n                    var file = event.currentTarget[1].files[0];\n\n                    var reader = new FileReader();\n                    reader.onload = function() {\n                        // serial.println(\"mounting \" + file.name + \"...\");\n                        serial.loadFile(file.name, reader.result.toString(), 0);\n                    };\n                    reader.readAsText(file);\n\n                    /*\n                     * Prevent reloading of web page after form submission\n                     */\n                    return false;\n                };\n            }\n            else {\n                if (DEBUG) this.log(\"Local file support not available\");\n                control.parentNode.removeChild(/** @type {Node} */ (control));\n            }\n            return true;\n\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     * @param {C1PCPU} cpu\n     */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.offPort = start;\n        this.cbPort = end - start + 1;\n        this.offPortLimit = this.offPort + this.cbPort;\n        if ((this.cpu = cpu)) {\n            cpu.addReadNotify(start, end, this, this.getByte);\n            cpu.addWriteNotify(start, end, this, this.setByte);\n        }\n        this.setReady();\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     *\n     * We make a note of the Computer component, so that we can invoke its reset() method whenever we need to\n     * simulate a warm start, and we query the Keyboard component so that we can use its injectKeys() function.\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            this.cmp = cmp;\n            this.kbd = cmp.getComponentByType(\"keyboard\");\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     */\n    startLoad()\n    {\n        this.autoLoad = C1PSerialPort.AUTOLOAD_BASIC;\n        this.kbd.injectKeys(\"LOAD\\n\");\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {string} sFileName\n     * @param {string} sFileData (null if getResource() encountered an error)\n     * @param {number} nResponse from server\n     */\n    loadFile(sFileName, sFileData, nResponse)\n    {\n        if (!sFileData) {\n            this.println(\"Error loading file \\\"\" + sFileName + \"\\\" (\" + nResponse + \")\");\n            return;\n        }\n\n        this.iInput = 0;\n        this.sInput = sFileData;\n        this.fConvertLF = true;\n        this.autoLoad = C1PSerialPort.AUTOLOAD_NONE;\n\n        /*\n         * The following code adds support for loading \"65V\" files encoded as JSON, which is a cleaner\n         * way to store and deliver those files when they contain binary (non-ASCII) data.\n         *\n         * For example, my 6502 ASSEMBLER/DISASSEMBLER program starts with a conventional \"65V\" loading\n         * sequence, which loads and launches a small program loader that loads the rest of the program\n         * using a raw (1-to-1) binary format instead of the usual (3-to-1) HEX format used by \"65V\" files.\n         *\n         * The \"rawness\" of the binary format also necessitates disabling fConvertLF.\n         */\n        if (Str.endsWith(sFileName, \".json\")) {\n            try {\n                /*\n                 * The most likely source of any exception will be here: parsing the JSON-encoded data.\n                 */\n                var s = \"\";\n                var data = eval(\"(\" + sFileData + \")\");\n                var ab = data['bytes'];\n                for (var i = 0; i < ab.length; i++) {\n                    s += String.fromCharCode(ab[i]);\n                }\n                this.sInput = s;\n                this.fConvertLF = false;\n            } catch (e) {\n                this.println(\"Error processing file \\\"\" + sFileName + \"\\\": \" + e.message);\n                return;\n            }\n        }\n\n        if (this.cmp && this.kbd && this.cpu.isRunning()) {\n            this.println(\"auto-loading \" + sFileName);\n            /*\n             * QUESTION: Is this setFocus() call strictly necessary?  We're being called in the\n             * context of getResource(), not some user action.  If there was an original user action,\n             * then the handler for THAT action should take care to switch focus back, not us.\n             */\n            this.cpu.setFocus();\n            /*\n             * We interpret the presence of a \".\" at the beginning of the file as a \"65V Monitor\"\n             * address-mode command, and consequently treat the file as 6502 HEX command file.\n             *\n             * Anything else is treated as commands for the BASIC interpreter, which we re-initialize\n             * with \"NEW\" and \"LOAD\" commands.  To prevent that behavior, halt the CPU, perform the load,\n             * and then start it running again.  BASIC will start reading the data as soon as you type\n             * LOAD.\n             */\n            if (this.sInput.charAt(0) != '.') {\n                this.autoLoad = C1PSerialPort.AUTOLOAD_BASIC;\n                this.kbd.injectKeys(\"NEW\\nLOAD\\n\");\n            }\n            else {\n                /*\n                 * Set autoLoad to AUTOLOAD_6502 before the reset, so that when our reset() method is called,\n                 * we'll take care to preserve all the data we just loaded.\n                 */\n                this.autoLoad = C1PSerialPort.AUTOLOAD_6502;\n                /*\n                 * Although the Keyboard allows us to inject any key, even the BREAK key, like so:\n                 *\n                 *      this.kbd.injectKeys(String.fromCharCode(this.kbd.CHARCODE_BREAK))\n                 *\n                 * it's easier to initiate a reset() ourselves and then start the machine-language load process\n                 */\n                this.cmp.reset(true);\n                this.kbd.injectKeys(\"ML\");\n            }\n        }\n        else {\n            this.println(sFileName + \" ready to load\");\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {number} addr\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n     */\n    getByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this read (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            /*\n             *  WARNING: All I need to do for now is load the COM interface's \"data byte\"\n             *  with the next byte from the virtual cassette data stream -JP\n             */\n            if (!(addr & 0x01)) {\n                /*\n                 * An EVEN address implies they're looking, so if we have a fresh buffer,\n                 * then prime the pump.\n                 */\n                if (this.sInput && !this.iInput)\n                    this.advanceInput();\n            } else {\n                /*\n                 * An ODD address implies they just grabbed a data byte, so prep the next data byte.\n                 */\n                this.advanceInput();\n            }\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     * @param {number} addr\n     * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to write the specified addr)\n     */\n    setByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this write (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_SERIAL, true);\n            /*\n             * WARNING: I don't yet care what state the CPU puts the port into.  When it's time to support serial output,\n             * obviously that will become an issue.\n             */\n        }\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     */\n    advanceInput()\n    {\n        if (this.sInput !== undefined) {\n            this.bInput = -1;\n            if (this.iInput < this.sInput.length) {\n                var b = this.sInput.charCodeAt(this.iInput++) & 0xff;\n                if (this.fConvertLF) {\n                    if (b == 0x0a) b = 0x0d;\n                }\n                this.bInput = b;\n                // if (DEBUG) this.log(\"advanceInput(\" + Str.toHexByte(b) + \")\");\n            }\n            else {\n                this.sInput = \"\";\n                this.iInput = 0;\n                if (DEBUG) this.log(\"advanceInput(): out of data\");\n                if (this.autoLoad == C1PSerialPort.AUTOLOAD_BASIC && this.kbd) {\n                    this.kbd.injectKeys(\" \\nRUN\\n\");\n                }\n                this.autoLoad = C1PSerialPort.AUTOLOAD_NONE;\n            }\n            this.updateMemory();\n        }\n        // else if (DEBUG) this.log(\"advanceInput(): no input\");\n    }\n\n    /**\n     * @this {C1PSerialPort}\n     */\n    updateMemory()\n    {\n        var offset;\n        /*\n         * Update all the status (even) bytes\n         */\n        for (offset = this.offPort+0; offset < this.offPortLimit; offset+=2) {\n            this.abMem[offset] = (this.bInput >= 0? C1PSerialPort.STATUS_DATA : C1PSerialPort.STATUS_NONE);\n        }\n        /*\n         * Update all the data (odd) bytes\n         */\n        for (offset = this.offPort+1; offset < this.offPortLimit; offset+=2) {\n            this.abMem[offset] = (this.bInput >= 0? this.bInput : 0);\n        }\n    }\n\n    /**\n     * C1PSerialPort.init()\n     *\n     * This function operates on every HTML element of class \"serial\", extracting the\n     * JSON-encoded parameters for the C1PSerialPort constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PSerialPort component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeSerial = Component.getElementsByClass(document, C1PJS.APPCLASS, \"serial\");\n        for (var iSerial=0; iSerial < aeSerial.length; iSerial++) {\n            var eSerial = aeSerial[iSerial];\n            var parmsSerial = Component.getComponentParms(eSerial);\n            var serial = new C1PSerialPort(parmsSerial);\n            Component.bindComponentControls(serial, eSerial, C1PJS.APPCLASS);\n        }\n    }\n}\n\nC1PSerialPort.STATUS_NONE   = 0x00;\nC1PSerialPort.STATUS_DATA   = 0x01;     // indicates data available\n\n/*\n * Values for autoLoad:\n *\n *      0: no auto-load active\n *      1: BASIC command file auto-load in progress\n *      2: 6502 HEX command file auto-load in progress\n */\nC1PSerialPort.AUTOLOAD_NONE  = 0;\nC1PSerialPort.AUTOLOAD_BASIC = 1;\nC1PSerialPort.AUTOLOAD_6502  = 2;\n\n/*\n * Initialize every SerialPort module on the page.\n */\nWeb.onInit(C1PSerialPort.init);\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/disk.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * @class Drive\n * @property {number} iType\n * @property {number} nTracks\n * @property {boolean} fProtected\n * @property {number} nIndexPulse\n * @property {number} iTrackSelect\n * @property {number} iTrackOffset\n * @property {Array} aTracks\n */\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PDiskController extends Component {\n    /**\n     * C1PDiskController(parmsDC)\n     *\n     * The C1PDiskController component has no component-specific parameters.\n     *\n     * This component is being built to supplement a C1P (aka SuperBoard II) Model 600\n     * single-board computer with the addition of a 610 Accessory Board, which included:\n     *\n     *      MC6820 PIA (Peripheral Interface Adapter at $C000-$C003, decoded at $C000-$C00F)\n     *      MC6850 ACIA (Asynchronous Communications Interface Adapter at $C010-$C011, decoded at $C010-$C01F)\n     *\n     * From \"OSI C1P Technical Report\" p.4 regarding the 610 Accessory Board:\n     *\n     *      \"This board holds up to 24K of additional RAM memory, a dual mini-floppy disk controller,\n     *      a BUS expansion facility to Model 620 BUS adapter, and switching circuitry to route the\n     *      600 board's serial interface to both the modem and printer as well as an audio cassette.\n     *      Thus, a fully expanded Challenger lP system can have BASIC-in-ROM, 32K of RAM memory,\n     *      dual mini-floppies, cassette, printer, modem, and full BUS expansion capability to the OSI\n     *      48 line BUS through which over 40 accessories can be added (A/D, D/A, voice, I/O, more memory,\n     *      etc.).\"\n     *\n     * On p.20, the Report says that the 610 Accessory Board contains:\n     *\n     *      - Up to 24K of RAM\n     *      - Dual mini-floppy controller\n     *      - Real Time Clock (although elsewhere the Report says this is disabled by default)\n     *      - Expansion interface to a model 620 BUS adapter\n     *\n     * On p.21, the Report also says:\n     *\n     *      \"The dual mini-floppy interface is designed after Ohio Scientific's extremely popular\n     *      and successful 470 floppy disk controller. This floppy disk controller and encoding\n     *      technique has been field proven for several years in thousands of floppy disks and is\n     *      believed to be one of the most reliable floppy disk configurations in existence. Although\n     *      the Challenger lP product line is new, it has the advantage of the experience of a company\n     *      which has been building high performance microcomputers for several years.\"\n     *\n     * From \"PEEK 65\" Vol.2 No.3 March 1981, p.9:\n     *\n     *      \"The 470 board wired as a floppy disk controller contains two different interfaces:\n     *      a PIA and an ACIA. The PIA A and B ports are used in control circuits: raise and lower\n     *      the head, detect drive ready, detect sector hole, clear error faults, etc. The ACIA is\n     *      the interface over which the data actually travels. Typical operation is to drop the head,\n     *      reset the ACIA, wait for the index hole to come around, activate the read or write circuit,\n     *      then read or write characters through the ACIA.\"\n     *\n     *      470 Board Addressing\n     *      --------------------\n     *\n     *      Address     Read                    Write\n     *      -------     ----                    -----\n     *      C000        PIA: PA0 thru PA7       PIA: PA0 thru PA7 or DDA0 thru DDA7\n     *      C001        PIA: Port A Ctrl        PIA: Port A Control\n     *      C002        PIA: PB0 thru PB7       PIA: PB0 thru PB7 or DDB0 thru DDB7\n     *      C003        PIA: Port B Ctrl        PIA: Port B Control\n     *      C010        ACIA: Status Reg.       ACIA: Control Register\n     *      C011        ACIA: Data Path         ACIA: Data Path\n     *      C020        Clear Real Time Clock   Clear Real Time Clock\n     *                  (Reset) ($FF returned)  (Reset) (Data Ignored)\n     *\n     *      PIA Data Register A Layout:\n     *\n     *      PA7     PA6     PA5     PA4     PA3     PA2     PA1     PA0\n     *      ---     ---     ---     ----    ---     ---     ---     ----\n     *      IHD  |  SD2  |  WP   |  RDY2 |  SHD  |  FD   |  TZD  |  RDY1\n     *      (In)    (Out)   (In)    (In)    (In)    (In)    (In)    (In)\n     *\n     *      PIA Data Register B Layout:\n     *\n     *      PB7     PB6     PB5     PB4     PB3     PB2     PB1     PB0\n     *      ---     ---     ---     ---     ---     ---     ---     ---\n     *      HLD  |  LCS  |  SD1  |  FR   |  ST   |  STI  |  EE   |  WE\n     *      (Out)   (Out)   (Out)   (Out)   (Out)   (Out)   (Out)   (Out)\n     *\n     *      PIA Data Register A Lines       PIA Data Register B Lines\n     *      -------------------------       -------------------------\n     *      IHD - Index Hole Detect         HLD - Head Load\n     *      SD2 - Select Drive 2 (Drive B)  LCS - Low Current Select\n     *      WP  - Write Protected           SD1 - Select Drive 1\n     *      RDY2- Drive 2 Ready             FR  - Fault Reset\n     *      SHD - Sector Hole Detect        ST  - Step\n     *      FD  - Fault Detected            STI - Step In\n     *      TZD - Track Zero Detected       EE  - Enable Erase\n     *      RDY1- Drive 1 Ready             WE  - Write Enable\n     *\n     * NOTE: The PIA bit assignments above agree with those described, albeit somewhat less clearly,\n     * in http://www.osiweb.org/osiweb/misc/osi-hardware.txt, under \"Model 475 Floppy disk system with\n     * 470 Controller board\".\n     *\n     * There is apparently significant overlap with another OSI board: the Model 505 CPU Board\n     * used in C4P/MF systems.  According to http://www.osiweb.org/osiweb/misc/osi-hardware.txt, it\n     * contained:\n     *\n     *      CPU board w/ ROM, ACIA, Floppy Disk I/O, Real Time Clock\n     *      ROM $FDxx, $FExx, $FFxx\n     *      Floppy disk interface: 6820 PIA at $C000, 6850 ACIA at $C010 [Original says \"6850 PIA\"]\n     *      ACIA 6850 at $FC00 for RS-232 serial I/O. Baud jumpers for 75,150,300,600,1200,2400,4800,9600\n     *      Disk PIA $C0xx CB1 connected to 400mSEC (2.5/sec) clock divided from system clock (RTC)\n     *      Home security - PIA $F700-F703\n     *\n     * Disk Formats (from http://osi.marks-lab.com/files/winOSI/old-source-V1.2/Disk_io.cpp):\n     *\n     *      5.25\" disk, 40 tracks, 8 sectors/track, 256 bytes/sector, 11 bits/byte (8E1) = 80K/disk.\n     *\n     *      NOTE: 8E1 refers to \"8 data bits, even parity, 1 stop bit,\" plus an implied start bit.\n     *\n     *      OSI uses 8E1 to give a max unformatted capacity of 2272 bytes per track (see below).\n     *      However other bit encodings (8N1) could give up to 2500 bytes/track.\n     *\n     *      NOTE: 8N1 refers to \"8 data bits, no parity, 1 stop bit,\" plus an implied start bit.\n     *\n     *      The standard speed for 5.25\" drives is 300rpm. Thus one rotation of the disk is 200ms.\n     *      Stated baud-rate is 125k or 125000 bits/sec and one serial byte is 11 bits (1 start,\n     *      8 data, 1 parity, 1 stop). So the theoretical absolute maximum storage per track is\n     *      (125000 x 0.2) / 11 = 2272 bytes or 8.8 pages.\n     *\n     *      OS-65D loses a bit more because it doesn't write until 10ms after the index pulse, so\n     *      (125000 x 0.19) / 11 = 2159 bytes or 8.4 pages and this doesn't even allow for the length\n     *      of the index pulse (a few milliseconds?) and the speed variation between drives.\n     *\n     *      8\" disk, 77 tracks, 12 sectors/track, 256 bytes/sector, 11 bits/byte (8E1) = 231K/disk.\n     *      OSI uses 8E1 to give a max unformatted capacity of 3772 bytes/track (see below).\n     *      However other bit encodings (8N1) could give up to 3900 bytes/track.\n     *\n     *      The standard speed for 8\" drives is 360rpm. Thus one rotation of the disk is 166.6ms.\n     *      Stated baud rate is 250K or 250000 bits/sec and one serial byte is 11 bits (1 start,\n     *      8 data, 1 parity, 1 stop). So the theoretical absolute maximum storage per track is\n     *      (250000 x 0.166 ) / 11 = 3772 or 14.7 pages.\n     *\n     *      OS-65D loses a bit more because it doesn't write until 10 mS after the index pulse, so\n     *      (250000 x 0.156) / 11 = 3545 bytes  or 13.8 pages and this doesn't even allow for the length\n     *      of the index pulse (a few milliseconds?) and the speed variation between drives.\n     *\n     *      Track 0 Format\n     *      --------------\n     *              (10ms delay after index hole)\n     *      0,1     load address of the track in hi,lo form\n     *      2       page count of how much data is written on track 0.\n     *      3+      sector data\n     *\n     *      Track N Format (N > 0)\n     *      ----------------------\n     *              (10ms delay after index hole)\n     *      0,1     2-byte start code $43, $57\n     *      2       BCD track number\n     *      3       track type code (always $58)\n     *      4+      sector data\n     *\n     *      Sector Format (5.25\" disks)\n     *      ---------------------------\n     *      There can be any mixture of various length sectors. The total page count can not\n     *      exceed 8 pages (8*256) if more than one sector is on a track. Each sector is written\n     *      in the following format:\n     *\n     *          previous sector length (4 if none before) times 800 microseconds of delay\n     *          sector start code $76\n     *          sector number in binary\n     *          sector length (#pages) in binary\n     *          sector data\n     *          (end of sector mark? $47, $53? MDS)\n     *\n     *      Directory Format\n     *      ----------------\n     *      2 sectors (1 & 2) on track 12 hold the directory information.\n     *      Each entry requires 8 bytes. There are a total of 64 entries. The entries are\n     *      formatted as follows:\n     *\n     *          0-5 ASCII 6 character filename\n     *          6 BCD first track of file\n     *          7 BCD Last track of file\n     *\n     * So far, all the 5.25\" disk images I've seen are 92160 bytes, regardless whether they have an\n     * .IMG or .65D extension.  If we divide that total by 40 (tracks/disk), we get 2304 (bytes/track).\n     * Divide 2304 by 256 (bytes/page) and we get 9 pages/track.  Presumably a fixed 9 pages was chosen\n     * to yield a consistent track size across the entire image, while also allowing room for all the\n     * metadata that's typically present on a track as well.  As explained above, the upper limit\n     * on data per track (both sector data and metadata) is 8.8 pages in theory, or 8.4 pages in practice.\n     *\n     * @this {C1PDiskController}\n     * @param {Object} parmsDC\n     */\n    constructor(parmsDC)\n    {\n        super(\"C1PDiskController\", parmsDC);\n\n        this.flags.powered = false;\n\n        /*\n         * Our DiskController simulates the combination of an MC6820 PIA and an MC6850 ACIA.\n         * This image of an OSI 470 Controller Board (http://osi.marks-lab.com/boards/images/OSI470.jpg)\n         * shows that the chips actually used were MC68B21P and MC68B50P.\n         *\n         * We start with definitions for the MC6820 PIA.\n         */\n        this.PORT_PDA   = 0;        // PIA Peripheral Data Register A\n        this.PORT_DDA   = 0;        // PIA Data Direction Register A (DDA shares the same register offset as PDA)\n        this.PORT_CRA   = 1;        // PIA Control Register A\n\n        this.PORT_PDB   = 2;        // PIA Peripheral Data Register B\n        this.PORT_DDB   = 2;        // PIA Data Direction Register B (DDB shares the same register offset as PDB)\n        this.PORT_CRB   = 3;        // PIA Control Register B\n\n        this.CR_IRQ1    = 0x80;     // IRQ1\n        this.CR_IRQ2    = 0x40;     // IRQ2\n     // this.CR_C2_OUT  = 0x20;     // C2 is designated an output\n     // this.CR_C2_CTRL = 0x18;     // C2 Control (00 and 10 mask IRQ2, 01 and 11 pass IRQ2 through to the CPU)\n        this.CR_PD_SEL  = 0x04;     // set to select PD (PDA or PDB), clear to select DD (DDA or DDB)\n     // this.CR_C1_CTRL = 0x03;     // C1 Control (00 and 10 mask IRQ1, 01 and 11 pass IRQ1 through to the CPU)\n\n        /*\n         * The PDA bits have the following hard-wired connections in the OSI Floppy Disk Controller.\n         * Each line marked INPUT should have its corresponding Data Direction bit clear (0), and each line\n         * marked OUTPUT should have its Data Direction bit set (1); however, we do not currently verify that\n         * the Data Direction bits are actually initialized to match these specs (and in fact, in the case\n         * of PDA_SD2, they may not be).\n         */\n        this.PDA_RDY1   = 0x01;     // INPUT:   0 = Drive 1 Ready\n        this.PDA_TZD    = 0x02;     // INPUT:   0 = Track Zero Detected\n        this.PDA_FD     = 0x04;     // INPUT:   0 = Fault Detected\n        this.PDA_SHD    = 0x08;     // INPUT:   0 = Sector Hole Detect\n        this.PDA_RDY2   = 0x10;     // INPUT:   0 = Drive 2 Ready\n        this.PDA_WP     = 0x20;     // INPUT:   0 = Write Protected\n        this.PDA_SD2    = 0x40;     // OUTPUT:  0 = Select Drive 2 (Drive B)\n        this.PDA_IHD    = 0x80;     // INPUT:   0 = Index Hole Detect\n\n     // this.PDB_WE     = 0x01;     // OUTPUT:  0 = Write Enable\n     // this.PDB_EE     = 0x02;     // OUTPUT:  0 = Erase Enable (set to 1)\n        this.PDB_STI    = 0x04;     // OUTPUT:  0 = Step In (away from track 0)\n        this.PDB_ST     = 0x08;     // OUTPUT:  0 = Step (on 1-to-0 transition)\n     // this.PDB_FR     = 0x10;     // OUTPUT:  0 = Fault Reset (set to 1)\n        this.PDB_SD1    = 0x20;     // OUTPUT:  0 = Select Drive 1\n     // this.PDB_LCS    = 0x40;     // OUTPUT:  0 = Low Current Select (set to 1)\n     // this.PDB_HLD    = 0x80;     // OUTPUT:  0 = Head Load (head on disk)\n\n        /*\n         * Next, definitions for the MC6850 ACIA.\n         *\n         * For reference, here are all the possible CTRL_WSEL (Word Select) values:\n         *\n         *      000     0x00        7 bits, even parity, 2 stop bits\n         *      001     0x04        7 bits, odd parity, 2 stop bits\n         *      010     0x08        7 bits, even parity, 1 stop bit\n         *      011     0x0C        7 bits, odd parity, 1 stop bit\n         *      100     0x10        8 bits, 2 stop bits\n         *      101     0x14        8 bits, 1 stop bit\n         *      110     0x18        8 bits, even parity, 1 stop bit\n         *      111     0x1C        8 bits, odd parity, 1 stop bit\n         *\n         * And here are all the possible CTRL_TCTL (Transmit Control) values:\n         *\n         *      00      0x00        RTS=Low, Transmitting Interrupt Disabled\n         *      01      0x20        RTS=Low, Transmitting Interrupt Enabled\n         *      10      0x40        RTS=High, Transmitting Interrupt Disabled\n         *      11      0x60        RTS=Low, Transmits a Break level on the Transmit Data Output; Transmitting Interrupt Disabled\n         */\n        this.PORT_CTRL = 0x10;  // ACIA Control Register (WRITE-only)\n        this.PORT_STAT = 0x10;  // ACIA Status Register (READ-only)\n        this.PORT_DATA = 0x11;  // ACIA Data Register (Transmit Data Register on WRITE, Receive Data Register on READ)\n\n        this.CTRL_CDIV  = 0x03; // Counter Divide (CR1,CR0) [OSI sets both, performing a \"Master Reset\", then immediately clears both, for a divide ratio of 1]\n     // this.CTRL_WSEL  = 0x1C; // Word Select (CR4,CR3,CR2), determining word length, parity and stop bits [OSI selects 0x18 for \"8 bits, even parity, 1 stop bit\"]\n     // this.CTRL_TCTL  = 0x60; // Transmit Control (CR6,CR5) [OSI selects 0x40 for \"RTS=High, Transmitting Interrupt Disabled\"]\n     // this.CTRL_RINT  = 0x80; // Receive Interrupt Enable (CR7) [OSI selects 0x00 for interrupts disabled]\n\n        this.STAT_RDRF  = 0x01; // Receive Data Register Full\n        this.STAT_TDRE  = 0x02; // Transmit Data Register Empty\n        this.STAT_DCD   = 0x04; // Data Carrier Detect\n        this.STAT_CTS   = 0x08; // Clear To Send\n     // this.STAT_FE    = 0x10; // Framing Error (ie, the received character is improperly framed by a start and a stop bit and is detected by the absence of the first stop bit)\n     // this.STAT_OVRN  = 0x20; // Receiver Overrun (ie, one or more characters in the data stream were lost due to not being read from the Receive Data Register in time)\n     // this.STAT_PE    = 0x40; // Parity Error (ie, the number of highs (ones) in the character does not agree with the preselected odd or even parity)\n     // this.STAT_IRQ   = 0x80; // Interrupt Request (ie, state of the IRQ output; cleared by a read operation to the Receive Data Register or a write operation to the Transmit Data Register)\n\n        /*\n         * Last but not least, some internal state definitions and hard-coded assumptions\n         */\n        this.DRIVETYPE_5INCH = 0;\n     // this.DRIVETYPE_8INCH = 1;\n\n        this.MAXTRACKS_5INCH = 40;\n     // this.MAXTRACKS_8INCH = 77;\n\n        /*\n         * Some random OS-65D notes\n         *\n         * Version 3.3 Initialization Code\n         * -------------------------------\n         *\n         * The following code (where X is 0x00):\n         *\n         *      2217 8E 01 F4  STX $F401\n         *      221A 8E 00 F4  STX $F400\n         *      221D 8E 03 F4  STX $F403\n         *\n         * is intended to reset a Printer PIA located at 0xF400.\n         *\n         * It then takes a detour to \"SET KEYBOARD SOUND GENERATOR TO LOWEST FREQUENCY (192.753 HZ)\"\n         * with X set to 0xFF; the sound generator is supposed to be turned off a bit later, presumably\n         * at the same time it sets \"64 char/line\" mode -- well, that's what v3.2 did anyway.\n         *\n         *      2220 CA        DEX\n         *      2221 8E 01 DF  STX $DF01\n         *\n         * While X is still 0xFF, it continues initializing the Printer PIA:\n         *\n         *      2224 8E 02 F4  STX $F402\n         *\n         * Then the code fiddles a bit with a mystery serial port (perhaps the \"Model 430B Cassette & Analog I/O\"\n         * interface?)\n         *\n         *      2227 AD 06 FB  LDA $FB06\n         *      222A 8E 05 FB  STX $FB05\n         *\n         * And then it's back to more Printer PIA initialization:\n         *\n         *      222D A9 04     LDA #$04\n         *      222F 8D 01 F4  STA $F401\n         *      2232 8D 03 F4  STA $F403\n         *\n         * Then it does some disk resetting (with A still 0x04 and Y set to 0x00):\n         *\n         *      2235 8C 01 C0  STY $C001\n         *      2238 A0 40     LDY #$40 ;'@'\n         *      223A 8C 00 C0  STY $C000\n         *      223D 8D 01 C0  STA $C001\n         *\n         * This code supposedly selects DRIVE 1:\n         *\n         *      2240 A9 01     LDA #$01\n         *      2242 20 C6 29  JSR $29C6\n         *\n         * Then it \"resets\" and \"sets\" the TERMINAL ACIA.  Note that the C1P serial port is addressed\n         * at 0xF000-0xF0FF, and the C1P has ROM mapped to 0xF800-0xFFFF, so we know nothing of the serial\n         * port mentioned above at 0xFBxx, nor this terminal ACIA port at 0xFCxx.\n         *\n         *      2245 A9 03     LDA #$03\n         *      2247 8D 00 FC  STA $FC00\n         *      224A A0 11     LDY #$11\n         *      224C 8C 00 FC  STY $FC00\n         *\n         * Next, there's some code to \"SET CA-10X 16 WAY SERIAL BOARD\" at 0xCF00-0xCF1F; again, something\n         * we know nothing about:\n         *\n         *      224F A2 1E     LDX #$1E\n         *      2251 9D 00 CF  STA $CF00,X\n         *      2254 98        TYA\n         *      2255 9D 00 CF  STA $CF00,X\n         *      2258 A9 03     LDA #$03\n         *      225A CA        DEX\n         *      225B CA        DEX\n         *      225C 10 F3     BPL $2251\n         *\n         * Then it clears 8 pages of video memory (ie, it simply ASSUMES that this is a Model 540 video board\n         * with 2K of video memory):\n         *\n         *      225E A2 08     LDX #$08\n         *      2260 A9 D0     LDA #$D0\n         *      2262 85 FF     STA $FF\n         *      2264 A0 00     LDY #$00\n         *      2266 84 FE     STY $FE\n         *      2268 A9 20     LDA #$20 ;' '\n         *      226A 91 FE     STA ($FE),Y\n         *      226C C8        INY\n         *      226D D0 FB     BNE $226A\n         *      226F E6 FF     INC $FF\n         *      2271 CA        DEX\n         *      2272 D0 F6     BNE $226A\n         *\n         * Then it performs a memory test, starting with a high page of 0xBF, and stores the highest page of\n         * available RAM at 0x2300:\n         *\n         *      2276 A0 BF     LDY #$BF\n         *      2278 20 EC 22  JSR $22EC\n         *      227B F0 03     BEQ $2280\n         *      227D 88        DEY\n         *      227E D0 F8     BNE $2278\n         *      2280 8C 00 23  STY $2300\n         *\n         * Now it checks for \"SERIAL OR VIDEO (EITHER 65-A OR 65-V PROM)\" (the byte at 0xFE01 on a C1P is 0x28,\n         * so X will be 2, implying \"VIDEO\"):\n         *\n         *      2283 A2 01     LDX #$01\n         *      2285 AD 01 FE  LDA $FE01\n         *      2288 F0 01     BEQ $228B\n         *      228A E8        INX\n         *      228B 8E C6 2A  STX $2AC6\n         *\n         * Finally, there's some code that's a little different from v3.2; in 3.2, it would set X to 0x01\n         * and then store X at 0xDE00, effectively forcing the video board into \"64 char/line\" mode -- which was\n         * originally EXACTLY what I was looking for in the video emulation component.  But v3.3 doesn't do that.\n         * Here's what it does instead:\n         *\n         *      228F A2 00     LDX #$00\n         *      2291 8E 80 DC  STX $DC80\n         *\n         * So, what's supposed to be at 0xDC80?\n         */\n\n        this.reset(true);\n    }\n\n    /**\n     * @this {C1PDiskController}\n     * @param {boolean|undefined} [fPowerOn] is true for the initial reset only\n     */\n    reset(fPowerOn)\n    {\n        this.resetRegs();\n        this.iDriveSelect = -1;\n        if (fPowerOn) {\n            this.aDrives = [];\n            this.resetDrive(0, this.DRIVETYPE_5INCH, this.MAXTRACKS_5INCH);\n        }\n    }\n\n    /**\n     * @this {C1PDiskController}\n     */\n    resetRegs()\n    {\n        this.regDDA = {\n            bits: this.PDA_SD2, // clear all DDA bits, indicating that all PDA bits represent INPUT lines (well, except for PDA_SD2)\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    if (b !== undefined) this.bits = b;\n                    if (!(controller.regCRA.bits & controller.CR_PD_SEL)) {\n                        controller.writePort(controller.PORT_DDA, this);\n                    }\n                };\n            }(this)\n        };\n        this.regPDA = {\n            bits: 0xff,\n            read: function() {\n                this.update();\n            },\n            update: function(controller) {\n                return function(b) {\n                    this.bits = controller.updatePDA(b);\n                    if (controller.regCRA.bits & controller.CR_PD_SEL) {\n                        controller.writePort(controller.PORT_PDA, this);\n                    }\n                };\n            }(this)\n        };\n        this.regCRA = {\n            bits: 0,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    /*\n                     * Most bits written to CRA should be left as-is (the CPU should read back what it wrote);\n                     * bits 7 and 6 (IRQ1 and IRQ2) are exceptions, since those are tied to peripheral \"Control Lines\"\n                     * C1 and C2, which can in theory generate an interrupt depending on how the C1_CTRL and C2_CTRL bits\n                     * in CRA are set.  However, assuming there's no need to simulate interrupts for this particular\n                     * controller hardware, all we'll do is simply insure those two bits are always off.\n                     */\n                    if (b !== undefined) this.bits = (b & ~(controller.CR_IRQ1 | controller.CR_IRQ2));\n                    controller.writePort(controller.PORT_CRA, this);\n                    /*\n                     * Since a CRA write may have also changed which register (PDA or DDA) is enabled via the corresponding\n                     * PDA port, we simply ask ask both to update (only the one that's enabled will write itself to memory).\n                     */\n                    controller.regPDA.update();\n                    controller.regDDA.update();\n                };\n            }(this)\n        };\n        this.regDDB = {\n            bits: 0xff,         // set all DDB bits, indicating that all PDB bits represent OUTPUT lines\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    if (b !== undefined) this.bits = b;\n                    if (!(controller.regCRB.bits & controller.CR_PD_SEL)) {\n                        controller.writePort(controller.PORT_DDB, this);\n                    }\n                };\n            }(this)\n        };\n        this.regPDB = {\n            bits: 0xff,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    this.bits = controller.updatePDB(b);\n                    if (controller.regCRB.bits & controller.CR_PD_SEL) {\n                        controller.writePort(controller.PORT_PDB, this);\n                    }\n                };\n            }(this)\n        };\n        this.regCRB = {\n            bits: 0,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    /*\n                     * Most bits written to CRB should be left as-is (the CPU should read back what it wrote);\n                     * bits 7 and 6 (IRQ1 and IRQ2) are exceptions, since those are tied to peripheral \"Control Lines\"\n                     * C1 and C2, which can in theory generate an interrupt depending on how the C1_CTRL and C2_CTRL bits\n                     * in CRB are set.  However, assuming there's no need to simulate interrupts for this particular\n                     * controller hardware, all we'll do is simply insure those two bits are always off.\n                     */\n                    if (b !== undefined) this.bits = (b & ~(controller.CR_IRQ1 | controller.CR_IRQ2));\n                    controller.writePort(controller.PORT_CRB, this);\n                    /*\n                     * Since a CRB write may have also changed which register (PDB or DDB) is enabled via the corresponding\n                     * PDB port, we simply ask ask both to update (only the one that's enabled will write itself to memory).\n                     */\n                    controller.regPDB.update();\n                    controller.regDDB.update();\n                };\n            }(this)\n        };\n        this.regCTRL = {\n            bits: 0,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    if (b !== undefined) {\n                        if ((b & controller.CTRL_CDIV) == controller.CTRL_CDIV) {\n                            /*\n                             * Setting both CTRL_CDIV bits (CR0 and CR1) constitutes a \"Master Reset\" of the ACIA\n                             */\n                            controller.regSTAT.bits = (controller.STAT_TDRE | controller.STAT_DCD | controller.STAT_CTS);\n                        }\n                        this.bits = b;\n                    }\n                    // regCTRL isn't readable; instead, we ensure regSTAT is rewritten in its place\n                    controller.regSTAT.update();\n                };\n            }(this)\n        };\n        this.regSTAT = {\n            bits: (this.STAT_TDRE | this.STAT_DCD | this.STAT_CTS),\n            read: function() {},\n            update: function(controller) {\n                return function(b) {\n                    this.bits = controller.updateSTAT(b);\n                    controller.writePort(controller.PORT_STAT, this);\n                };\n            }(this)\n        };\n        this.regDATA = {\n            bits: 0,\n            read: function(controller) {\n                return function() {\n                    controller.advanceDriveData();\n                };\n            }(this),\n            update: function(controller) {\n                return function(b) {\n                    if (b !== undefined) this.bits = b;\n                    controller.writePort(controller.PORT_DATA, this);\n                };\n            }(this)\n        };\n        this.regUnknown = {\n            bits: 0,\n            read: function() {},\n            update: function(controller) {\n                return function(b) {};\n            }(this)\n        };\n        if (DEBUG) {\n            this.regDDA.sName = \"DDA\",\n            this.regDDA.aBitIDs = {0x80:\"DD7\",0x40:\"DD6\",0x20:\"DD5\",0x10:\"DD4\",0x08:\"DD3\",0x04:\"DD2\",0x02:\"DD1\",0x01:\"DD0\"};    // jshint ignore:line\n            this.regPDA.sName = \"PDA\";\n            this.regPDA.aBitIDs = {0x80:\"IHD\",0x40:\"SD2\",0x20:\"WP\",0x10:\"RDY2\",0x08:\"SHD\",0x04:\"FD\",0x02:\"TZD\",0x01:\"RDY1\"};\n            this.regCRA.sName = \"CRA\";\n            this.regCRA.aBitIDs = {0x80:\"IRQ1\",0x40:\"IRQ2\",0x20:\"C2OUT\",0x10:\"C2:1\",0x08:\"C2:0\",0x04:\"PDS\",0x02:\"C1:1\",0x01:\"C1:0\"};\n            this.regDDB.sName = \"DDB\";\n            this.regDDB.aBitIDs = {0x80:\"DD7\",0x40:\"DD6\",0x20:\"DD5\",0x10:\"DD4\",0x08:\"DD3\",0x04:\"DD2\",0x02:\"DD1\",0x01:\"DD0\"};\n            this.regPDB.sName = \"PDB\";\n            this.regPDB.aBitIDs = {0x80:\"HLD\",0x40:\"LCS\",0x20:\"SD1\",0x10:\"FR\",0x08:\"ST\",0x04:\"STI\",0x02:\"EE\",0x01:\"WE\"};\n            this.regCRB.sName = \"CRB\";\n            this.regCRB.aBitIDs = {0x80:\"IRQ1\",0x40:\"IRQ2\",0x20:\"C2OUT\",0x10:\"C2:1\",0x08:\"C2:0\",0x04:\"PDS\",0x02:\"C1:1\",0x01:\"C1:0\"};\n            this.regCTRL.sName = \"CTRL\";\n            this.regCTRL.aBitIDs = {0x80:\"CR7\",0x40:\"CR6\",0x20:\"CR5\",0x10:\"CR4\",0x08:\"CR3\",0x04:\"CR2\",0x02:\"CR1\",0x01:\"CR0\"};\n            this.regSTAT.sName = \"STAT\";\n            this.regDATA.sName = \"DATA\";\n            this.regUnknown.sName = \"unknown\";\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} iDrive\n    * @param {number} iDriveType\n    * @param {number} nMaxTracks\n    */\n    resetDrive(iDrive, iDriveType, nMaxTracks)\n    {\n        this.aDrives[iDrive] = {\n            iType: iDriveType,\n            nTracks: nMaxTracks,\n            fProtected: true,               // fake for now\n            nIndexPulse: 20,                // nIndex (20 is initial index pulse)\n            iTrackSelect: 0,                // nTrack\n            iTrackOffset: -1,               // nSector\n            /*\n             * Our disk data consists of an array of tracks, where each track is an array of sectors;\n             * as long as aTracks.length == 0 (empty array), the drive is not considered \"loaded\" with a disk.\n             */\n            aTracks: []\n        };\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n    * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"listDisk\")\n    * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n    * @param {string} [sValue] optional data value\n    * @return {boolean} true if binding was successful, false if unrecognized binding request\n    */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        switch(sBinding) {\n\n        case \"listDisk\":\n            this.bindings[sBinding] = control;\n            return true;\n\n        case \"loadDisk\":\n            this.bindings[sBinding] = control;\n            control.onclick = function(controller) {\n                return function() {\n                    if (controller.bindings[\"listDisk\"]) {\n                        var sFilePath = controller.bindings[\"listDisk\"].value;\n                        var sFileURL = sFilePath;\n                        /*\n                         * If the selected disk image has a \".json\" extension, then we assume it's a pre-converted\n                         * JSON-encoded disk image, so we load it as-is; otherwise, we ask our server-side disk image\n                         * converter to return the corresponding JSON-encoded data, in compact form (ie, minimal whitespace,\n                         * no ASCII data comments, etc).\n                         */\n                        if (sFilePath.substr(sFilePath.length-5) != \".json\") {\n                            /*\n                             * TODO: This code was using a deprecated parameter (compact=1); make sure things still work.\n                             *\n                             * TODO: Convert this code to use the new shared Disk API definitions and weblib functions; eg:\n                             *\n                             *      sDiskURL = Web.getHost() + DumpAPI.ENDPOINT + \"?\" + DumpAPI.QUERY.DISK + \"=\" + sDiskPath;\n                             */\n                            sFileURL = \"http://\" + window.location.host + \"/api/v1/dump?disk=\" + sFilePath;\n                        }\n                        controller.println(\"loading  \" + Str.getBaseName(sFilePath) + \"...\");\n                        Web.getResource(sFileURL, null, true, function(sURL, sResponse, nErrorCode) {\n                            controller.loadDisk(sURL, sResponse, nErrorCode);\n                        });\n                    }\n                };\n            }(this);\n            return true;\n\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {Array} abMemory\n    * @param {number} start\n    * @param {number} end\n    * @param {C1PCPU} cpu\n    */\n    setBuffer(abMemory, start, end, cpu)\n    {\n        this.abMem = abMemory;\n        this.addrController = start;\n     // this.addrControllerLimit = end + 1;\n        if ((this.cpu = cpu)) {\n            cpu.addReadNotify(start, end, this, this.getByte);\n            cpu.addWriteNotify(start, end, this, this.setByte);\n        }\n        this.setReady();\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {boolean} fOn\n    * @param {C1PComputer} cmp\n    *\n    * We need We make a note of the Computer component, so that we can invoke its reset() method whenever we need to\n    * simulate a warm start, and we query the Keyboard component so that we can use its injectKeys() function.\n    */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            if (DEBUGGER) this.dbg = cmp.getComponentByType(\"debugger\");\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {string} sDiskName\n    * @param {string} sDiskData\n    * @param {number} nErrorCode (response from server if anything other than 200)\n    *\n    * NOTE: Although I've expanded the JSON disk-image format to support multiple heads (ie, platters or disk surfaces),\n    * this controller implementation currently supports only single-head drives, and therefore only single-sided images.\n    * So, if the image contains more than one entry in head data array, all we use is the first entry; data for any remaining\n    * heads is discarded.\n    *\n    * WARNING: The disk-image format should match that used by PCjs, where the image is an array of cylinders, each of which\n    * is an array of heads.  That's also more typical, because it maintains the original data's physical locality.\n    */\n    loadDisk(sDiskName, sDiskData, nErrorCode)\n    {\n        if (nErrorCode) {\n            this.println(\"disk load error (\" + nErrorCode + \")\");\n            return;\n        }\n        var aHeads = [];\n        this.println(\"mounting \" + sDiskName + \"...\");\n        try {\n            /*\n             * The most likely source of any exception will be right here, where we're parsing\n             * the JSON-encoded disk data.\n             */\n            aHeads = eval(\"(\" + sDiskData + \")\");   // jshint ignore:line\n            if (!aHeads.length) {\n                this.println(\"no data: \" + sDiskName);\n                return;\n            }\n            if (!aHeads[0].length) {\n                this.println(\"no tracks: \" + sDiskName);\n                return;\n            }\n            var aTracks = aHeads[0];\n            if (aTracks[0]['trackNum'] === undefined) {\n                this.println(\"data error: \" + aTracks[0]);\n                return;\n            }\n            /*\n             * NOTE: This should never happen, otherwise we shouldn't have initiated the load\n             * in the first place. Can we guarantee that and eliminate this test?\n             */\n            if (!this.aDrives[0]) {\n                this.println(\"no available drives\");\n                return;\n            }\n            /*\n             * To make disk access more efficient, we need to supplement every track object with a\n             * simple byte-array (trackData) containing all the data bytes for the entire track.\n             */\n            for (var iTrack=0; iTrack < aTracks.length; iTrack++) {\n                var iTrackNum;\n                var track = aTracks[iTrack];\n                var sectors = track['sectors'];\n                /*\n                 * WARNING: There are MANY other ways the track data could be malformed, but we'll\n                 * start with the most egregious, and worry about the rest later.\n                 */\n                if ((iTrackNum = track['trackNum']) === undefined || sectors === undefined) {\n                    throw new Error(\"track \" + iTrack + \" missing data\");\n                }\n                /*\n                 * WARNING: We allow out-of-order tracks, because we store each track's data according\n                 * to its trackNum index, but just in case that wasn't intended, we're going to mention it.\n                 */\n                if (iTrackNum != iTrack) {\n                    Component.warning(\"track \" + iTrackNum + \" out of order (expected \" + iTrack + \")\");\n                }\n                /*\n                 * For each track, we start with an empty trackData array and \"push\" (ie, append) all the\n                 * sector data onto it. Most of the data is already in byte form and can simply use Array.push(),\n                 * but there is also some metadata (signatures, types, lengths, etc), for which we have assorted\n                 * helpers below: pushBCD, pushBin, and pushSig.\n                 */\n                var trackData = [], sector, sectorData, i;\n                if (!iTrackNum) {\n                    sector = sectors[0];\n                    sectorData = sector['sectorData'];\n                    this.pushBin(trackData, track, 'trackLoad', 2);\n                    this.pushBin(trackData, sector, 'sectorPages');\n                    for (i = 0; i < sectorData.length; i++) {\n                        trackData.push(sectorData[i]);\n                    }\n                }\n                else {\n                    this.pushSig(trackData, track, 'trackSig');\n                    this.pushBCD(trackData, track, 'trackNum');\n                    this.pushBin(trackData, track, 'trackType');\n                    for (var iSector=0; iSector < sectors.length; iSector++) {\n                        sector = sectors[iSector];\n                        sectorData = sector['sectorData'];\n                        this.pushBin(trackData, sector, 'sectorSig');\n                        this.pushBin(trackData, sector, 'sectorNum');\n                        this.pushBin(trackData, sector, 'sectorPages');\n                        for (i = 0; i < sectorData.length; i++) {\n                            trackData.push(sectorData[i]);\n                        }\n                        this.pushSig(trackData, sector, 'sectorEndSig');\n                    }\n                }\n                /*\n                 * Finally, here's where we add the newly-created chunk of track data to the current track object\n                 */\n                aTracks[iTrackNum].trackData = trackData;\n                if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_DISK)) {\n                    this.dbg.message(\"track \" + iTrackNum + \": \" + trackData.length + \" bytes\");\n                }\n            }\n            this.aDrives[0].aTracks = aTracks;\n            this.println(\"mount of \" + sDiskName + \" complete\");\n        } catch (e) {\n            this.println(\"disk data error: \" + e.message);\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {Array.<number>} a\n    * @param {Object} o is the object containing the key\n    * @param {string} k is the key of 8-bit value to convert to BCD (ie, two 4-bit BCD digits) and push\n    */\n    pushBCD(a, o, k)\n    {\n        var n = o[k];\n        if (n === undefined) {\n            throw new Error(\"missing bcd value: \" + k);\n        }\n        var bcd = (Math.floor(n / 10) << 4) | (n % 10);\n        a.push(bcd);\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {Array.<number>} a\n    * @param {Object} o is the object containing the key\n    * @param {string} k is the key of the value\n    * @param {number} [cb] is the number of bytes to push (only 1 or 2 is supported, and the default is 1)\n    */\n    pushBin(a, o, k, cb)\n    {\n        var n = o[k];\n        if (n === undefined) {\n            throw new Error(\"missing binary value: \" + k);\n        }\n        if (cb == 2) {\n            a.push((n >> 8) & 0xff);\n        }\n        a.push(n & 0xff);\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {Array.<number>} a\n    * @param {Object} o is the object containing the key\n    * @param {string} k is the key of the signature string to push\n    */\n    pushSig(a, o, k)\n    {\n        var s = o[k];\n        if (s === undefined) {\n            throw new Error(\"missing signature: \" + k);\n        }\n        for (var i=0; i < s.length; i++) {\n            a.push(s.charCodeAt(i));\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} port address (0x0000-0x00FF) relative to addrController (0xC000)\n    * @param {boolean} fWrite is true if port write, false if port read\n    * @return {Object} reg will always be a valid register object, but it may be the \"unknown\" register if we don't recognize the port.\n    */\n    getReg(port, fWrite)\n    {\n        var reg;\n        port &= 0x3F;\n        /*\n         * Now that we've masked the full port range of 0x00-0xFF down to 0x00-0x3F, we further mask the\n         * PIA port range (0x00-0x0F) to 0x00-0x03, and the ACIA port range (0x10-0x1F) to 0x10-0x11.\n         * The rest of the masked range (0x20-0x3F) is unmapped, so we map it to our global unknown register.\n         */\n        if (port < 0x10)\n            port &= 0x03;\n        else if (port < 0x20)\n            port &= 0x11;\n        switch(port) {\n        case this.PORT_PDA:\n            reg = (this.regCRA.bits & this.CR_PD_SEL)? this.regPDA : this.regDDA;\n            break;\n        case this.PORT_CRA:\n            reg = this.regCRA;\n            break;\n        case this.PORT_PDB:\n            reg = (this.regCRB.bits & this.CR_PD_SEL)? this.regPDB : this.regDDB;\n            break;\n        case this.PORT_CRB:\n            reg = this.regCRB;\n            break;\n        case this.PORT_CTRL:\n            reg = (fWrite? this.regCTRL : this.regSTAT);\n            break;\n        case this.PORT_DATA:\n            reg = this.regDATA;\n            break;\n        default:\n            reg = this.regUnknown;\n            break;\n        }\n        return reg;\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} addr\n    * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to read the specified addr)\n    */\n    getByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this read (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            var port = addr - this.addrController;\n            var reg = this.getReg(port, false);\n            if (DEBUGGER && this.dbg) this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_DISK, false, reg.sName);\n            reg.read();\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} addr\n    * @param {number|undefined} addrFrom (not defined whenever the Debugger tries to write the specified addr)\n    */\n    setByte(addr, addrFrom)\n    {\n        /*\n         * Don't trigger any further hardware emulation (beyond what we've already stored in memory) if\n         * the Debugger performed this write (need a special Debugger I/O command if/when you really want to do that).\n         */\n        if (addrFrom !== undefined) {\n            var b = this.cpu.getByte(addr);\n            var port = addr - this.addrController;\n            var reg = this.getReg(port, true);\n            if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_DISK | this.dbg.MESSAGE_PORT)) {\n                this.dbg.messageIO(this, addr, addrFrom, this.dbg.MESSAGE_DISK, true, reg.sName);\n                if (reg.aBitIDs) {\n                    var bTest = 0x80;\n                    var bChanged = reg.bits ^ b;\n                    while (bChanged && bTest) {\n                        if (bChanged & bTest) {\n                            this.dbg.message(\"  changed \" + reg.sName + \".\" + reg.aBitIDs[bTest] + \" to \" + ((b & bTest)? \"1\" : \"0\"));\n                        }\n                        bTest >>= 1;\n                    }\n                }\n            }\n            reg.update(b);\n        }\n    }\n\n    /**\n    * @this {C1PDiskController}\n    * @param {number} bPDA\n    * @param {number} bPDB\n    */\n    setSelectedDrive(bPDA, bPDB)\n    {\n        var iDriveSelect = -1;\n        if (bPDA !== undefined && bPDB !== undefined) {\n            iDriveSelect = 0;\n            if (!(bPDB & this.PDB_SD1))\n                iDriveSelect |= 0x02;\n            if (!(this.regPDA.bits & this.PDA_SD2))\n                iDriveSelect |= 0x01;\n        }\n        if (this.iDriveSelect != iDriveSelect) {\n            this.iDriveSelect = iDriveSelect;\n            this.regSTAT.update();\n        }\n    }\n\n    /**\n     * @this {C1PDiskController}\n     */\n    startDriveData()\n    {\n        if (this.iDriveSelect >= 0) {\n            this.aDrives[this.iDriveSelect].iTrackOffset = 0;\n            this.advanceDriveData();\n        }\n    }\n\n    /**\n     * @this {C1PDiskController}\n     */\n    stopDriveData()\n    {\n        if (this.iDriveSelect >= 0) {\n            this.aDrives[this.iDriveSelect].iTrackOffset = -1;\n            this.regDATA.update(0xFF);          // QUESTION: Is this necessary or helpful in some way?\n            this.regSTAT.update();\n        }\n    }\n\n    /**\n     * @this {C1PDiskController}\n     * @return {number} current byte of data from the currently selected drive, or null if no (more) data available\n     */\n    advanceDriveData()\n    {\n        var b = null;\n        if (this.iDriveSelect >= 0) {\n            var drive = this.aDrives[this.iDriveSelect];\n            var track = drive.aTracks[drive.iTrackSelect];\n            if (track !== undefined) {\n                if (drive.iTrackOffset >= 0 && drive.iTrackOffset < track.trackData.length) {\n                    drive.nIndexPulse = 100;    // QUESTION: Necessary?\n                    b = track.trackData[drive.iTrackOffset++];\n                    this.regDATA.update(b);\n                    this.regSTAT.update();\n                }\n                else {\n                    drive.nIndexPulse = 10;     // QUESTION: Valid or necessary to force index pulse on next poll of $C000?\n                    this.stopDriveData();\n                }\n            }\n        }\n        return b;\n    }\n\n    /**\n     * updatePDA() calculates an updated value for the PDA register.\n     *\n     * In the process, this may also update iDriveSelect and assorted drive internal variables.\n     *\n     * @this {C1PDiskController}\n     * @param {number|undefined} bPDA\n     * @return {number} updated bits for PDA\n     */\n    updatePDA(bPDA)\n    {\n        if (bPDA === undefined)\n            bPDA = this.regPDA.bits;\n        else\n            this.setSelectedDrive(bPDA, this.regPDB.bits);\n\n        /*\n         * We start by turning ON most bits, except for PDA_RDY1, which we always leave\n         * OFF (indicating ready).  We leave PDA_SD2 alone, so that it reflects whatever\n         * the CPU had set.\n         *\n         * Then we dive into the update logic, which will turn OFF any of the bits we\n         * originally turned ON if the corresponding condition is true (because an OFF bit\n         * signals an active condition).\n         */\n        bPDA |= (this.PDA_IHD | this.PDA_WP | this.PDA_SHD | this.PDA_FD | this.PDA_TZD | this.PDA_RDY2);\n        bPDA &= ~(this.PDA_RDY1);\n\n        if (this.iDriveSelect >= 0) {\n\n            if (this.aDrives[this.iDriveSelect].aTracks.length) {\n\n                var drive = this.aDrives[this.iDriveSelect];\n\n                if (drive.fProtected) {\n                    bPDA &= ~this.PDA_WP;\n                }\n                if (!drive.iTrackSelect) {\n                    bPDA &= ~this.PDA_TZD;\n                }\n                /*\n                 * Simulate PHD_IHD (Index Hole Detect)\n                 */\n                if (--drive.nIndexPulse <= 10) {\n                    if (drive.nIndexPulse > 0) {\n                        bPDA &= ~this.PDA_IHD;\n                        this.stopDriveData();\n                    } else {\n                        drive.nIndexPulse = 100;\n                        this.startDriveData();\n                    }\n                }\n            }\n        }\n        return bPDA;\n    }\n\n    /**\n     * updatePDB() calculates an updated value for the PDB register.  However, since the\n     * PDB consists entirely of OUTPUT bits, none of the given bits should actually be modified.\n     *\n     * In the process, this may also update iDriveSelect and assorted drive internal variables,\n     * as well as selected PDA INPUT bits (hence the call to regPDA.update()).\n     *\n     * @this {C1PDiskController}\n     * @param {number|undefined} bPDB\n     * @return {number} updated bits for PDB\n     */\n    updatePDB(bPDB)\n    {\n        if (bPDB === undefined)\n            bPDB = this.regPDB.bits;\n        else\n            this.setSelectedDrive(this.regPDA.bits, bPDB);\n\n        if (this.iDriveSelect >= 0 && this.iDriveSelect < this.aDrives.length) {\n\n            var drive = this.aDrives[this.iDriveSelect];\n\n            if (drive.aTracks.length) {\n                /*\n                 * Is PDB_ST transitioning from 1 to 0?\n                 */\n                if ((this.regPDB.bits & this.PDB_ST) && !(bPDB & this.PDB_ST)) {\n                    /*\n                     *  PDB_STI == 0? step toward track 39 : step toward track 0\n                     */\n                    if (bPDB & this.PDB_STI)\n                        drive.iTrackSelect--;\n                    else\n                        drive.iTrackSelect++;\n\n                    if (DEBUGGER && this.dbg && this.dbg.messageEnabled(this.dbg.MESSAGE_DISK)) {\n                        this.dbg.message(\"stepping \" + ((bPDB & this.PDB_STI)? \"down\" : \"up\") + \" to track \" + drive.iTrackSelect);\n                    }\n\n                    if (drive.iTrackSelect >= drive.nTracks)\n                        drive.iTrackSelect = drive.nTracks;\n\n                    if (drive.iTrackSelect < 0)\n                        drive.iTrackSelect = 0;\n\n                    drive.nIndexPulse = 20;\n\n                    this.regPDA.update(this.regPDA.bits | this.PDA_IHD);\n                    this.stopDriveData();\n                }\n            }\n        }\n        else if (DEBUG && this.iDriveSelect >= 0) {\n            this.println(\"updatePDB(\" + Str.toHexByte(bPDB) + \"): invalid drive: \" + this.iDriveSelect);\n        }\n        return bPDB;\n    }\n\n    /**\n     * updateSTAT() calculates an updated value for the ACIA Status register.\n     *\n     * @this {C1PDiskController}\n     * @param {number|undefined} bSTAT\n     * @return {number} updated bits for STAT\n     */\n    updateSTAT(bSTAT)\n    {\n        if (bSTAT === undefined)\n            bSTAT = this.regSTAT.bits;\n        bSTAT &= ~this.STAT_RDRF;\n        if (this.iDriveSelect >= 0 && this.aDrives[this.iDriveSelect].iTrackOffset >= 0)\n            bSTAT |= this.STAT_RDRF;\n        return bSTAT;\n    }\n\n    /**\n     * @this {C1PDiskController}\n     * @param {number} port\n     * @param {Object} reg\n     */\n    writePort(port, reg)\n    {\n        this.cpu.setByte(port + this.addrController, reg.bits);\n    }\n\n    /**\n     * @this {C1PDiskController}\n     * @param {boolean} fLoaded is true if the selected drive must be loaded, false if don't care\n     * @return {Object} drive reference to the selected drive, or null if no drive is selected or it doesn't meet the fLoaded requirement\n     *\n     getSelectedDrive(fLoaded)\n     {\n         var drive = null;\n         if (this.iDriveSelect >= 0) {\n             if (this.aDrives[this.iDriveSelect]) {\n                 if (!fLoaded || this.aDrives[this.iDriveSelect].aTracks.length)\n                     drive = this.aDrives[this.iDriveSelect];\n             }\n         }\n         return drive;\n     }\n     */\n\n    /**\n     * C1PDiskController.init()\n     *\n     * This function operates on every HTML element of class \"disk\", extracting the\n     * JSON-encoded parameters for the C1PDiskController constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PDiskController component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeDC = Component.getElementsByClass(document, C1PJS.APPCLASS, \"disk\");\n        for (var iDC=0; iDC < aeDC.length; iDC++) {\n            var eDC = aeDC[iDC];\n            var parmsDC = Component.getComponentParms(eDC);\n            var controller = new C1PDiskController(parmsDC);\n            Component.bindComponentControls(controller, eDC, C1PJS.APPCLASS);\n        }\n    }\n}\n\n/*\n * Initialize every DiskController module on the page.\n */\nWeb.onInit(C1PDiskController.init);\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/debugger.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PDebugger extends Component {\n    /**\n     * C1PDebugger(parmsDbg)\n     *\n     * The C1PDebugger component has no required (parmsDbg) properties.\n     *\n     * The C1PDebugger component is an optional component that implements a variety of user\n     * commands for controlling the CPU, dumping and editing memory, etc.\n     *\n     * @this {C1PDebugger}\n     * @param {Object} parmsDbg\n     */\n    constructor(parmsDbg)\n    {\n        if (DEBUGGER) {\n\n            super(\"C1PDebugger\", parmsDbg);\n\n            this.dbg = this;\n            /*\n             * This keeps track of instruction activity, but only when tracing or when\n             * Debugger checks have been enabled (eg, one or more breakpoints have been set).\n             *\n             * This is zeroed by CPU notification handlers reset() and stopped().\n             * We set it here to -1 to indicate that the CPU has not yet initialized us.\n             */\n            this.cIns = -1;\n\n            /*\n             * Some commands, like the dump (d) command, start at nextAddr when no address\n             * is given (and they also update nextAddr when they're done).\n             */\n            this.nextAddr = 0;\n\n            /*\n             * When Enter is pressed on an empty input buffer, we default to the previous\n             * command, which is preserved here.\n             */\n            this.prevCmd = null;\n\n            /*\n             * fAssemble is true when \"assemble mode\" is active, false when not.\n             */\n            this.fAssemble = false;\n            this.addrAssembleNext = 0;\n\n            /*\n             * Initialize the lists of breakpoint addresses.  aExecBreak is a list (Array) of addresses\n             * to halt at whenever attempting to execute an instruction at the corresponding address,\n             * and aReadBreak and aWriteBreak are lists of addresses to halt at whenever a read or write,\n             * respectively, occurs at the corresponding address.\n             */\n            this.clearBreakpoints();\n\n            /*\n             * Instead of pre-allocating these arrays, we wait until our reset() function is called.\n             * These arrays are updated in checkInstruction(), but the CPU will never actually call it\n             * unless checksEnabled() returns true, and that won't happen until one or more breakpoints\n             * have been set.  This ensures that, by default, the CPU runs as fast as possible.\n             */\n            this.iStepHistory = 0;\n            this.aStepHistory = [];\n            this.aaOpcodeFreqs = [];\n\n            /*\n             * This \"info\" buffer is a lightweight logging mechanism that has minimal impact on the\n             * browser (unlike printing to either window.console.log or an HTML control, which can make\n             * the browser unusable if printing is too frequent).  The Debugger's \"i\" command dumps\n             * this buffer.  Note that dumping too much at once can also bog things down, but by that\n             * point, you've presumably already captured the info you need and are willing to wait.\n             */\n            if (DEBUG) {\n                this.iInfoBuffer = 0;\n                this.aInfoBuffer = new Array(10000);\n            }\n\n            /*\n             * Message categories supported by the message() function; they are designed to be combined\n             * (ie, OR'ed) as needed.  The Debugger's \"option\" command is used to turn message categories\n             * on and off, like so:\n             *\n             *      o msg port on\n             *      o msg port off\n             *      ...\n             */\n            this.MESSAGE_PORT   = 0x01;\n            this.MESSAGE_KBD    = 0x10;\n            this.MESSAGE_VIDEO  = 0x20;\n            this.MESSAGE_DISK   = 0x40;\n            this.MESSAGE_SERIAL = 0x80;\n            this.MESSAGE_NONE   = 0x00;\n         // this.MESSAGE_ALL    = 0xff;\n            this.bitsMessage = this.MESSAGE_NONE;\n            this.aMessageCategories = {\n                'port':     this.MESSAGE_PORT,\n                'kbd':      this.MESSAGE_KBD,\n                'video':    this.MESSAGE_VIDEO,\n                'disk':     this.MESSAGE_DISK,\n                'serial':   this.MESSAGE_SERIAL\n            };\n\n            /*\n             * The aaOperations array is indexed by opcode, and each element is a sub-array that\n             * describes the corresponding opcode. The sub-elements are as follows:\n             *\n             *      [0]: {number} of the operation code (see OP_*)\n             *      [1]: {number} of additional bytes following the opcode byte, if any\n             *      [2]: {number} of the operation mode operand, if any (see MODE_*)\n             *\n             * These sub-elements are all optional. If [0] is not present, the opcode is undefined;\n             * if [1] is not present (or contains a zero), the opcode is a single-byte opcode; and if\n             * [2] is not present, the opcode uses no (or implied) operands.\n             */\n            this.OP_ADC = 0;\n            this.OP_AND = 1;\n            this.OP_ASL = 2;\n            this.OP_BCC = 3;\n            this.OP_BCS = 4;\n            this.OP_BEQ = 5;\n            this.OP_BIT = 6;\n            this.OP_BMI = 7;\n            this.OP_BNE = 8;\n            this.OP_BPL = 9;\n            this.OP_BRK = 10;\n            this.OP_BVC = 11;\n            this.OP_BVS = 12;\n            this.OP_CLC = 13;\n            this.OP_CLD = 14;\n            this.OP_CLI = 15;\n            this.OP_CLV = 16;\n            this.OP_CMP = 17;\n            this.OP_CPX = 18;\n            this.OP_CPY = 19;\n            this.OP_DEC = 20;\n            this.OP_DEX = 21;\n            this.OP_DEY = 22;\n            this.OP_EOR = 23;\n            this.OP_INC = 24;\n            this.OP_INX = 25;\n            this.OP_INY = 26;\n            this.OP_JMP = 27;\n            this.OP_JSR = 28;\n            this.OP_LDA = 29;\n            this.OP_LDX = 30;\n            this.OP_LDY = 31;\n            this.OP_LSR = 32;\n            this.OP_NOP = 33;\n            this.OP_ORA = 34;\n            this.OP_PHA = 35;\n            this.OP_PHP = 36;\n            this.OP_PLA = 37;\n            this.OP_PLP = 38;\n            this.OP_ROL = 39;\n            this.OP_ROR = 40;\n            this.OP_RTI = 41;\n            this.OP_RTS = 42;\n            this.OP_SBC = 43;\n            this.OP_SEC = 44;\n            this.OP_SED = 45;\n            this.OP_SEI = 46;\n            this.OP_STA = 47;\n            this.OP_STX = 48;\n            this.OP_STY = 49;\n            this.OP_TAX = 50;\n            this.OP_TAY = 51;\n            this.OP_TSX = 52;\n            this.OP_TXA = 53;\n            this.OP_TXS = 54;\n            this.OP_TYA = 55;\n            this.OP_SIM = 56;\n            this.OP_DB  = 57;\n\n            this.aOpCodes = [\n                \"ADC\",\"AND\",\"ASL\",\"BCC\",\"BCS\",\"BEQ\",\"BIT\",\"BMI\",\n                \"BNE\",\"BPL\",\"BRK\",\"BVC\",\"BVS\",\"CLC\",\"CLD\",\"CLI\",\n                \"CLV\",\"CMP\",\"CPX\",\"CPY\",\"DEC\",\"DEX\",\"DEY\",\"EOR\",\n                \"INC\",\"INX\",\"INY\",\"JMP\",\"JSR\",\"LDA\",\"LDX\",\"LDY\",\n                \"LSR\",\"NOP\",\"ORA\",\"PHA\",\"PHP\",\"PLA\",\"PLP\",\"ROL\",\n                \"ROR\",\"RTI\",\"RTS\",\"SBC\",\"SEC\",\"SED\",\"SEI\",\"STA\",\n                \"STX\",\"STY\",\"TAX\",\"TAY\",\"TSX\",\"TXA\",\"TXS\",\"TYA\",\n                \"SIM\",\".DB\"\n            ];\n\n            this.aOpSimCodes = [\n                \"HLT\", \"MSG\"\n            ];\n\n            this.setOpModes(true);\n\n            this.aaOperations = [\n                /* 0x00 */ [this.OP_BRK],\n                /* 0x01 */ [this.OP_ORA, 1, this.MODE_INDX],\n                /* 0x02 */ [this.OP_SIM, 1],\n                /* 0x03 */ [],\n                /* 0x04 */ [],\n                /* 0x05 */ [this.OP_ORA, 1, this.MODE_ZP],\n                /* 0x06 */ [this.OP_ASL, 1, this.MODE_ZP],\n                /* 0x07 */ [],\n                /* 0x08 */ [this.OP_PHP],\n                /* 0x09 */ [this.OP_ORA, 1, this.MODE_IMM],\n                /* 0x0a */ [this.OP_ASL, 0, this.MODE_ACC],\n                /* 0x0b */ [],\n                /* 0x0c */ [],\n                /* 0x0d */ [this.OP_ORA, 2, this.MODE_ABS],\n                /* 0x0e */ [this.OP_ASL, 2, this.MODE_ABS],\n                /* 0x0f */ [],\n                /* 0x10 */ [this.OP_BPL, 1, this.MODE_DISP],\n                /* 0x11 */ [this.OP_ORA, 1, this.MODE_INDY],\n                /* 0x12 */ [],\n                /* 0x13 */ [],\n                /* 0x14 */ [],\n                /* 0x15 */ [this.OP_ORA, 1, this.MODE_ZPX],\n                /* 0x16 */ [this.OP_ASL, 1, this.MODE_ZPX],\n                /* 0x17 */ [],\n                /* 0x18 */ [this.OP_CLC],\n                /* 0x19 */ [this.OP_ORA, 2, this.MODE_ABSY],\n                /* 0x1a */ [],\n                /* 0x1b */ [],\n                /* 0x1c */ [],\n                /* 0x1d */ [this.OP_ORA, 2, this.MODE_ABSX],\n                /* 0x1e */ [this.OP_ASL, 2, this.MODE_ABSX],\n                /* 0x1f */ [],\n                /* 0x20 */ [this.OP_JSR, 2, this.MODE_IMM16],\n                /* 0x21 */ [this.OP_AND, 1, this.MODE_INDX],\n                /* 0x22 */ [],\n                /* 0x23 */ [],\n                /* 0x24 */ [this.OP_BIT, 1, this.MODE_ZP],\n                /* 0x25 */ [this.OP_AND, 1, this.MODE_ZP],\n                /* 0x26 */ [this.OP_ROL, 1, this.MODE_ZP],\n                /* 0x27 */ [],\n                /* 0x28 */ [this.OP_PLP],\n                /* 0x29 */ [this.OP_AND, 1, this.MODE_IMM],\n                /* 0x2a */ [this.OP_ROL, 0, this.MODE_ACC],\n                /* 0x2b */ [],\n                /* 0x2c */ [this.OP_BIT, 2, this.MODE_ABS],\n                /* 0x2d */ [this.OP_AND, 2, this.MODE_ABS],\n                /* 0x2e */ [this.OP_ROL, 2, this.MODE_ABS],\n                /* 0x2f */ [],\n                /* 0x30 */ [this.OP_BMI, 1, this.MODE_DISP],\n                /* 0x31 */ [this.OP_AND, 1, this.MODE_INDY],\n                /* 0x32 */ [],\n                /* 0x33 */ [],\n                /* 0x34 */ [],\n                /* 0x35 */ [this.OP_AND, 1, this.MODE_ZPX],\n                /* 0x36 */ [this.OP_ROL, 1, this.MODE_ZPX],\n                /* 0x37 */ [],\n                /* 0x38 */ [this.OP_SEC],\n                /* 0x39 */ [this.OP_AND, 2, this.MODE_ABSY],\n                /* 0x3a */ [],\n                /* 0x3b */ [],\n                /* 0x3c */ [],\n                /* 0x3d */ [this.OP_AND, 2, this.MODE_ABSX],\n                /* 0x3e */ [this.OP_ROL, 2, this.MODE_ABSX],\n                /* 0x3f */ [],\n                /* 0x40 */ [this.OP_RTI],\n                /* 0x41 */ [this.OP_EOR, 1, this.MODE_INDX],\n                /* 0x42 */ [],\n                /* 0x43 */ [],\n                /* 0x44 */ [],\n                /* 0x45 */ [this.OP_EOR, 1, this.MODE_ZP],\n                /* 0x46 */ [this.OP_LSR, 1, this.MODE_ZP],\n                /* 0x47 */ [],\n                /* 0x48 */ [this.OP_PHA],\n                /* 0x49 */ [this.OP_EOR, 1, this.MODE_IMM],\n                /* 0x4a */ [this.OP_LSR, 0, this.MODE_ACC],\n                /* 0x4b */ [],\n                /* 0x4c */ [this.OP_JMP, 2, this.MODE_IMM16],\n                /* 0x4d */ [this.OP_EOR, 2, this.MODE_ABS],\n                /* 0x4e */ [this.OP_LSR, 2, this.MODE_ABS],\n                /* 0x4f */ [],\n                /* 0x50 */ [this.OP_BVC, 1, this.MODE_DISP],\n                /* 0x51 */ [this.OP_EOR, 1, this.MODE_INDY],\n                /* 0x52 */ [],\n                /* 0x53 */ [],\n                /* 0x54 */ [],\n                /* 0x55 */ [this.OP_EOR, 1, this.MODE_ZPX],\n                /* 0x56 */ [this.OP_LSR, 1, this.MODE_ZPX],\n                /* 0x57 */ [],\n                /* 0x58 */ [this.OP_CLI],\n                /* 0x59 */ [this.OP_EOR, 2, this.MODE_ABSY],\n                /* 0x5a */ [],\n                /* 0x5b */ [],\n                /* 0x5c */ [],\n                /* 0x5d */ [this.OP_EOR, 2, this.MODE_ABSX],\n                /* 0x5e */ [this.OP_LSR, 2, this.MODE_ABSX],\n                /* 0x5f */ [],\n                /* 0x60 */ [this.OP_RTS],\n                /* 0x61 */ [this.OP_ADC, 1, this.MODE_INDX],\n                /* 0x62 */ [],\n                /* 0x63 */ [],\n                /* 0x64 */ [],\n                /* 0x65 */ [this.OP_ADC, 1, this.MODE_ZP],\n                /* 0x66 */ [this.OP_ROR, 1, this.MODE_ZP],\n                /* 0x67 */ [],\n                /* 0x68 */ [this.OP_PLA],\n                /* 0x69 */ [this.OP_ADC, 1, this.MODE_IMM],\n                /* 0x6a */ [this.OP_ROR, 0, this.MODE_ACC],\n                /* 0x6b */ [],\n                /* 0x6c */ [this.OP_JMP, 2, this.MODE_ABS16],\n                /* 0x6d */ [this.OP_ADC, 2, this.MODE_ABS],\n                /* 0x6e */ [this.OP_ROR, 2, this.MODE_ABS],\n                /* 0x6f */ [],\n                /* 0x70 */ [this.OP_BVS, 1, this.MODE_DISP],\n                /* 0x71 */ [this.OP_ADC, 1, this.MODE_INDY],\n                /* 0x72 */ [],\n                /* 0x73 */ [],\n                /* 0x74 */ [],\n                /* 0x75 */ [this.OP_ADC, 1, this.MODE_ZPX],\n                /* 0x76 */ [this.OP_ROR, 1, this.MODE_ZPX],\n                /* 0x77 */ [],\n                /* 0x78 */ [this.OP_SEI],\n                /* 0x79 */ [this.OP_ADC, 2, this.MODE_ABSY],\n                /* 0x7a */ [],\n                /* 0x7b */ [],\n                /* 0x7c */ [],\n                /* 0x7d */ [this.OP_ADC, 2, this.MODE_ABSX],\n                /* 0x7e */ [this.OP_ROR, 2, this.MODE_ABSX],\n                /* 0x7f */ [],\n                /* 0x80 */ [],\n                /* 0x81 */ [this.OP_STA, 1, this.MODE_INDX],\n                /* 0x82 */ [],\n                /* 0x83 */ [],\n                /* 0x84 */ [this.OP_STY, 1, this.MODE_ZP],\n                /* 0x85 */ [this.OP_STA, 1, this.MODE_ZP],\n                /* 0x86 */ [this.OP_STX, 1, this.MODE_ZP],\n                /* 0x87 */ [],\n                /* 0x88 */ [this.OP_DEY],\n                /* 0x89 */ [],\n                /* 0x8a */ [this.OP_TXA],\n                /* 0x8b */ [],\n                /* 0x8c */ [this.OP_STY, 2, this.MODE_ABS],\n                /* 0x8d */ [this.OP_STA, 2, this.MODE_ABS],\n                /* 0x8e */ [this.OP_STX, 2, this.MODE_ABS],\n                /* 0x8f */ [],\n                /* 0x90 */ [this.OP_BCC, 1, this.MODE_DISP],\n                /* 0x91 */ [this.OP_STA, 1, this.MODE_INDY],\n                /* 0x92 */ [],\n                /* 0x93 */ [],\n                /* 0x94 */ [this.OP_STY, 1, this.MODE_ZPX],\n                /* 0x95 */ [this.OP_STA, 1, this.MODE_ZPX],\n                /* 0x96 */ [this.OP_STX, 1, this.MODE_ZPY],\n                /* 0x97 */ [],\n                /* 0x98 */ [this.OP_TYA],\n                /* 0x99 */ [this.OP_STA, 2, this.MODE_ABSY],\n                /* 0x9a */ [this.OP_TXS],\n                /* 0x9b */ [],\n                /* 0x9c */ [],\n                /* 0x9d */ [this.OP_STA, 2, this.MODE_ABSX],\n                /* 0x9e */ [],\n                /* 0x9f */ [],\n                /* 0xa0 */ [this.OP_LDY, 1, this.MODE_IMM],\n                /* 0xa1 */ [this.OP_LDA, 1, this.MODE_INDX],\n                /* 0xa2 */ [this.OP_LDX, 1, this.MODE_IMM],\n                /* 0xa3 */ [],\n                /* 0xa4 */ [this.OP_LDY, 1, this.MODE_ZP],\n                /* 0xa5 */ [this.OP_LDA, 1, this.MODE_ZP],\n                /* 0xa6 */ [this.OP_LDX, 1, this.MODE_ZP],\n                /* 0xa7 */ [],\n                /* 0xa8 */ [this.OP_TAY],\n                /* 0xa9 */ [this.OP_LDA, 1, this.MODE_IMM],\n                /* 0xaa */ [this.OP_TAX],\n                /* 0xab */ [],\n                /* 0xac */ [this.OP_LDY, 2, this.MODE_ABS],\n                /* 0xad */ [this.OP_LDA, 2, this.MODE_ABS],\n                /* 0xae */ [this.OP_LDX, 2, this.MODE_ABS],\n                /* 0xaf */ [],\n                /* 0xb0 */ [this.OP_BCS, 1, this.MODE_DISP],\n                /* 0xb1 */ [this.OP_LDA, 1, this.MODE_INDY],\n                /* 0xb2 */ [],\n                /* 0xb3 */ [],\n                /* 0xb4 */ [this.OP_LDY, 1, this.MODE_ZPX],\n                /* 0xb5 */ [this.OP_LDA, 1, this.MODE_ZPX],\n                /* 0xb6 */ [this.OP_LDX, 1, this.MODE_ZPY],\n                /* 0xb7 */ [],\n                /* 0xb8 */ [this.OP_CLV],\n                /* 0xb9 */ [this.OP_LDA, 2, this.MODE_ABSY],\n                /* 0xba */ [this.OP_TSX],\n                /* 0xbb */ [],\n                /* 0xbc */ [this.OP_LDY, 2, this.MODE_ABSX],\n                /* 0xbd */ [this.OP_LDA, 2, this.MODE_ABSX],\n                /* 0xbe */ [this.OP_LDX, 2, this.MODE_ABSY],\n                /* 0xbf */ [],\n                /* 0xc0 */ [this.OP_CPY, 1, this.MODE_IMM],\n                /* 0xc1 */ [this.OP_CMP, 1, this.MODE_INDX],\n                /* 0xc2 */ [],\n                /* 0xc3 */ [],\n                /* 0xc4 */ [this.OP_CPY, 1, this.MODE_ZP],\n                /* 0xc5 */ [this.OP_CMP, 1, this.MODE_ZP],\n                /* 0xc6 */ [this.OP_DEC, 1, this.MODE_ZP],\n                /* 0xc7 */ [],\n                /* 0xc8 */ [this.OP_INY],\n                /* 0xc9 */ [this.OP_CMP, 1, this.MODE_IMM],\n                /* 0xca */ [this.OP_DEX],\n                /* 0xcb */ [],\n                /* 0xcc */ [this.OP_CPY, 2, this.MODE_ABS],\n                /* 0xcd */ [this.OP_CMP, 2, this.MODE_ABS],\n                /* 0xce */ [this.OP_DEC, 2, this.MODE_ABS],\n                /* 0xcf */ [],\n                /* 0xd0 */ [this.OP_BNE, 1, this.MODE_DISP],\n                /* 0xd1 */ [this.OP_CMP, 1, this.MODE_INDY],\n                /* 0xd2 */ [],\n                /* 0xd3 */ [],\n                /* 0xd4 */ [],\n                /* 0xd5 */ [this.OP_CMP, 1, this.MODE_ZPX],\n                /* 0xd6 */ [this.OP_DEC, 1, this.MODE_ZPX],\n                /* 0xd7 */ [],\n                /* 0xd8 */ [this.OP_CLD],\n                /* 0xd9 */ [this.OP_CMP, 2, this.MODE_ABSY],\n                /* 0xda */ [],\n                /* 0xdb */ [],\n                /* 0xdc */ [],\n                /* 0xdd */ [this.OP_CMP, 2, this.MODE_ABSX],\n                /* 0xde */ [this.OP_DEC, 2, this.MODE_ABSX],\n                /* 0xdf */ [],\n                /* 0xe0 */ [this.OP_CPX, 1, this.MODE_IMM],\n                /* 0xe1 */ [this.OP_SBC, 1, this.MODE_INDX],\n                /* 0xe2 */ [],\n                /* 0xe3 */ [],\n                /* 0xe4 */ [this.OP_CPX, 1, this.MODE_ZP],\n                /* 0xe5 */ [this.OP_SBC, 1, this.MODE_ZP],\n                /* 0xe6 */ [this.OP_INC, 1, this.MODE_ZP],\n                /* 0xe7 */ [],\n                /* 0xe8 */ [this.OP_INX],\n                /* 0xe9 */ [this.OP_SBC, 1, this.MODE_IMM],\n                /* 0xea */ [this.OP_NOP],\n                /* 0xeb */ [],\n                /* 0xec */ [this.OP_CPX, 2, this.MODE_ABS],\n                /* 0xed */ [this.OP_SBC, 2, this.MODE_ABS],\n                /* 0xee */ [this.OP_INC, 2, this.MODE_ABS],\n                /* 0xef */ [],\n                /* 0xf0 */ [this.OP_BEQ, 1, this.MODE_DISP],\n                /* 0xf1 */ [this.OP_SBC, 1, this.MODE_INDY],\n                /* 0xf2 */ [],\n                /* 0xf3 */ [],\n                /* 0xf4 */ [],\n                /* 0xf5 */ [this.OP_SBC, 1, this.MODE_ZPX],\n                /* 0xf6 */ [this.OP_INC, 1, this.MODE_ZPX],\n                /* 0xf7 */ [],\n                /* 0xf8 */ [this.OP_SED],\n                /* 0xf9 */ [this.OP_SBC, 2, this.MODE_ABSY],\n                /* 0xfa */ [],\n                /* 0xfb */ [],\n                /* 0xfc */ [],\n                /* 0xfd */ [this.OP_SBC, 2, this.MODE_ABSX],\n                /* 0xfe */ [this.OP_INC, 2, this.MODE_ABSX],\n                /* 0xff */ []\n            ];\n\n        }   // endif DEBUGGER\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\", \"canvas\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"reset\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        var dbg = this;\n        switch(sBinding) {\n        case \"debugInput\":\n            this.bindings[sBinding] = control;\n            this.eDebug = control;\n            this.eDebug.focus();\n            control.onkeypress = function(dbg, e) {\n                return function(event) {\n                    if (event.keyCode == 13) {\n                        sBinding = e.value;\n                        e.value = \"\";\n                        C1PDebugger.input(dbg, sBinding);\n                    }\n                };\n            }(this, control);\n            return true;\n        case \"debugEnter\":\n            this.bindings[sBinding] = control;\n            /*\n             * I've replaced the standard \"onclick\" code with a call to our onClickRepeat() helper in\n             * component.js, so that the \"Enter\" button can be held to repeat, just like the \"Step\" button.\n             */\n            Web.onClickRepeat(\n                control, 500, 100,\n                function(fRepeat) {\n                    if (dbg.eDebug) {\n                        sBinding = dbg.eDebug.value;\n                        //\n                        //  If we want to use the debugEnter button to repeatedly enter the same command,\n                        //  then don't clear the command string.\n                        //\n                        //      dbg.eDebug.value = \"\";\n                        //\n                        C1PDebugger.input(dbg, sBinding);\n                        return true;\n                    }\n                    if (DEBUG) dbg.log(\"no debugger input buffer\");\n                    return false;\n                }\n            );\n            return true;\n        case \"step\":\n            this.bindings[sBinding] = control;\n            Web.onClickRepeat(\n                control, 500, 100,\n                function(fRepeat) {\n                    var fCompleted = false;\n                    if (!dbg.isBusy(true)) {\n                        dbg.setBusy(true);\n                        fCompleted = dbg.step(fRepeat? 1 : 0);\n                        dbg.setBusy(false);\n                    }\n                    return fCompleted;\n                }\n            );\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array} abMemory\n     * @param {number} start\n     * @param {number} end\n     */\n    setBuffer(abMemory, start, end)\n    {\n        this.abMem = abMemory;\n        this.offMem = start;\n        this.cbMem = end - start + 1;\n        this.offLimit = this.offMem + this.cbMem;\n        this.setReady();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {boolean} fOn\n     * @param {C1PComputer} cmp\n     */\n    setPower(fOn, cmp)\n    {\n        if (fOn && !this.flags.powered) {\n            this.flags.powered = true;\n            this.cpu = cmp.getComponentByType(\"cpu\");\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    setFocus()\n    {\n        this.eDebug.focus();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {boolean} fClassic is true for \"classic\" operand syntax, or false for \"modern\" operand syntax\n     *\n     * The strings describing the operand(s) also describe the addressing mode, as follows:\n     *\n     *      bbb     mode    classic     modern         description\n     *      ---     ----    -------     -------         ----------------\n     *      000     INDX    ($nn,X)     [[nn+X]]        Indexed Indirect\n     *      001     ZP      $nn         [nn]            Zero-Page\n     *      010     IMM     #$nn        nn              Immediate\n     *      011     ABS     $nnnn       [nnnn]          Absolute\n     *      100     INDY    ($nn),Y     [[nn]+Y]        Indirect Indexed\n     *      101     ZPX     $nn,X       [nn+X]          Zero-Page,X\n     *      110     ABSY    $nnnn,Y     [nnnn+Y]        Absolute,Y\n     *      111     ABSX    $nnnn,X     [nnnn+X]        Absolute,X\n     *\n     * where bbb generally corresponds to bits 2-4 of the opcode.  I find that using brackets in the\n     * descriptors to indicate a memory access (or multiple brackets, in the case of indirect accesses),\n     * along with \"+\" and any index register, is more intuitive than the \"classic\" operand formats;\n     * the absence of any brackets implies immediate data, eliminating the need for a prepended \"#\".\n     * Also, the use of 2-digit instead of 4-digit addresses indicates that a zero-page address is\n     * being used.  Finally, all displacements/addresses and immediate values are displayed in hex by\n     * default, so there is no need to waste space prepending the traditional \"$\" to such values.\n     *\n     * Other addressing modes:\n     *\n     *      101     ZPY     $nn,Y           Zero-Page,Y (used by LDX and STX only)\n     *\n     *              ACC     A               Accumulator\n     *\n     *              IMM16   $nnnn           Used by JSR (0x20) and JMP (0x4C); I consider this an \"Immediate\" operation\n     *                                      that uses 16 bits, but it is documented as \"Absolute\" addressing (see Zaks)\n     *\n     *                                      FYI, this is the same operand format used for branch displacements (MODE_DISP),\n     *                                      except the displacements are 8-bit values that are signed-extended to 16 bits, so\n     *                                      discriminating between MODE_DISP and MODE_IMM16 also requires checking the operand size\n     *\n     *              ABS16   ($nnnn)         Used by JMP (0x6C); I consider this an \"Absolute\" operation that fetches\n     *                                      16 bits of data, but it is documented as \"Indirect\" addressing (see Zaks)\n     */\n    setOpModes(fClassic)\n    {\n        /*\n         * NOTE: The modes are arranged within aOpModes so that longer matches are checked before\n         * any subsets that could also match (eg, check for \"$nn,X\" before \"$nn\", \"$nnnn,X\" before \"$nnnn\", etc).\n         */\n        this.MODE_ACC   = 0;\n        this.MODE_IMM   = 1;\n        this.MODE_ABSX  = 2;\n        this.MODE_ABSY  = 3;\n        this.MODE_IMM16 = 4;\n        this.MODE_ABS16 = 5;\n        this.MODE_ZPX   = 6;\n        this.MODE_ZPY   = 7;\n        this.MODE_INDX  = 8;\n        this.MODE_INDY  = 9;\n        this.MODE_ABS   = 10;\n        this.MODE_ZP    = 11;\n        this.MODE_DISP  = this.MODE_IMM16;\n\n        var sRegEx = \"\";\n        var iMode, sMode;\n\n        if (fClassic) {\n            this.aOpModes = [\n                            \"A\",            // MODE_ACC\n                /* 010b */  \"#$nn\",         // MODE_IMM\n                /* 111b */  \"$nnnn,X\",      // MODE_ABSX\n                /* 110b */  \"$nnnn,Y\",      // MODE_ABSY\n                            \"$nnnn\",        // MODE_IMM16\n                            \"($nnnn)\",      // MODE_ABS16\n                /* 101b */  \"$nn,X\",        // MODE_ZPX\n                            \"$nn,Y\",        // MODE_ZPY\n                /* 000b */  \"($nn,X)\",      // MODE_INDX\n                /* 100b */  \"($nn),Y\",      // MODE_INDY\n                /* 011b */  \"$nnnn\",        // MODE_ABS\n                /* 001b */  \"$nn\"           // MODE_ZP\n            ];\n            for (iMode=0; iMode < this.aOpModes.length; iMode++) {\n                sMode = this.aOpModes[iMode];\n                sRegEx += \"(\" + sMode.replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\").replace(/nnnn/g, \"[0-9A-F][0-9A-F][0-9A-F][0-9A-F]?\").replace(/nn/g, \"[0-9A-F][0-9A-F]?\").replace(/\\$/g, \"\\\\$\") + \"|)\";\n            }\n            this.regexOpModes = new RegExp(sRegEx);\n        }\n        else {\n            this.aOpModes = [\n                            \"A\",            // MODE_ACC\n                /* 010b */  \"nn\",           // MODE_IMM\n                /* 111b */  \"[nnnn+X]\",     // MODE_ABSX\n                /* 110b */  \"[nnnn+Y]\",     // MODE_ABSY\n                            \"nnnn\",         // MODE_IMM16\n                            \"[nnnn]\",       // MODE_ABS16\n                /* 101b */  \"[nn+X]\",       // MODE_ZPX\n                            \"[nn+Y]\",       // MODE_ZPY\n                /* 000b */  \"[[nn+X]]\",     // MODE_INDX\n                /* 100b */  \"[[nn]+Y]\",     // MODE_INDY\n                /* 011b */  \"[nnnn]\",       // MODE_ABS\n                /* 001b */  \"[nn]\"          // MODE_ZP\n            ];\n            for (iMode=0; iMode < this.aOpModes.length; iMode++) {\n                sMode = this.aOpModes[iMode];\n                sRegEx += \"(\" + sMode.replace(/\\[/g, \"\\\\[\").replace(/]/g, \"\\\\]\").replace(/nnnn/g, \"[0-9A-F][0-9A-F][0-9A-F][0-9A-F]?\").replace(/nn/g, \"[0-9A-F][0-9A-F]?\").replace(/\\+/g, \"\\\\+\") + \"|)\";\n            }\n            this.regexOpModes = new RegExp(sRegEx);\n        }\n        /*\n         * Regrettably, if \"classic\" operand syntax is in effect, then we will have to look at the context of the\n         * operand (ie, the operation code) whenever we have a MODE_IMM16 (or MODE_DISP) match, because it might actually\n         * be a MODE_ABS operand.  MODE_IMM16 is used with only 2 operations (OP_JSR and OP_JMP), and MODE_DISP only 8\n         * (OP_BPL, OP_BMI, OP_BVC, OP_BVS, OP_BCC, OP_BCS, OP_BNE, and OP_BEQ), so if the operation isn't one of those\n         * codes (in the following array), then we should convert MODE_IMM16 (aka MODE_DISP) into MODE_ABS.\n         */\n        this.aImm16Codes = [this.OP_JMP, this.OP_JSR, this.OP_BPL, this.OP_BMI, this.OP_BVC, this.OP_BVS, this.OP_BCC, this.OP_BCS, this.OP_BNE, this.OP_BEQ];\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    halt()\n    {\n        /*\n         * We ask the CPU to halt, but we can't assume it's stopped until it calls stop()\n         */\n        this.cpu.halt();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} s is any diagnostic string that you can print later using the Debugger's \"i\" command\n     */\n    info(s)\n    {\n        if (DEBUG) {\n            this.aInfoBuffer[this.iInfoBuffer++] = s;\n            if (this.iInfoBuffer >= this.aInfoBuffer.length)\n                this.iInfoBuffer = 0;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Component} component\n     * @param {number} addr\n     * @param {number|undefined} addrFrom\n     * @param {boolean} bitsMessage is a Debugger MESSAGE_* category flag\n     * @param {boolean|undefined} [fWrite] is true if this was a write, false (or undefined) if read\n     * @param {string|undefined} [name] of the port, if any\n     */\n    messageIO(component, addr, addrFrom, bitsMessage, fWrite, name)\n    {\n        if ((this.bitsMessage & bitsMessage) == bitsMessage) {\n            var b = this.cpu.getByte(addr);\n            this.message(component.id + \".\" + (fWrite? \"setByte\":\"getByte\") + \"(\" + Str.toHexWord(addr) + \")\" + (addrFrom !== undefined? (\" @\" + Str.toHexWord(addrFrom)) : \"\") + \": \" + (name? (name + \"=\") : \"\") + Str.toHexByte(b));\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sMessage is any caller-defined message string\n     */\n    message(sMessage)\n    {\n        this.println(sMessage);\n        this.cpu.yieldCPU();    // these print() calls are at risk of being called with high frequency, so we need to yieldCPU() more\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    init()\n    {\n        // this.doHelp();\n        this.println(\"Type ? for list of debugger commands\\n\");\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {boolean}\n     */\n    run()\n    {\n        if (!this.isCPUOK()) return false;\n        this.cpu.run();\n        return true;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} n (0 implies a single-step, and therefore breakpoints should be ignored)\n     * @return {boolean}\n     */\n    step(n)\n    {\n        if (!this.isCPUOK()) return false;\n        var fCompleted;\n        try {\n            fCompleted = this.cpu.step(n);\n        }\n        catch(e) {\n            fCompleted = undefined;\n            this.cpu.setError(e.stack || e.message);\n        }\n        if (fCompleted !== undefined) this.cIns++;\n        /*\n         * Because we called cpu.step() and not cpu.run(), we must\n         * nudge the CPU's update code, and then update our own state.\n         */\n        this.cpu.update(true);\n        this.update(true);\n        return fCompleted;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {boolean} [fStep]\n     */\n    update(fStep)\n    {\n        this.nextAddr = this.cpu.regPC;\n        if (fStep || this.fStepOver)\n            this.doUnassemble();\n        else\n            this.doRegisters();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {boolean}\n     *\n     * Make sure the CPU is ready (finished initializing), not busy (already running), and not in an error state.\n     */\n    isCPUOK()\n    {\n        if (!this.cpu)\n            return false;\n        if (!this.cpu.isReady())\n            return false;\n        if (this.cpu.isBusy())\n            return false;\n        return !this.cpu.isError();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     *\n     * This is a notification handler, called by the CPU, to inform us that the CPU has been reset.\n     */\n    reset()\n    {\n        var i;\n        if (!this.aStepHistory.length)\n            this.aStepHistory = new Array(1000);\n        for (i = 0; i < this.aStepHistory.length; i++)\n            this.aStepHistory[i] = -1;\n        if (!this.aaOpcodeFreqs.length)\n            this.aaOpcodeFreqs = new Array(256);\n        for (i = 0; i < this.aaOpcodeFreqs.length; i++)\n            this.aaOpcodeFreqs[i] = [i, 0];\n        if (this.cIns) this.update();\n        this.cIns = 0;\n        this.cReads = this.cWrites = this.cWritesZP = 0;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     *\n     * This is a notification handler, called by the CPU, to inform us that the CPU has started running.\n     */\n    start()\n    {\n        if (!this.fStepOver) this.println(\"running\");\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} msStart\n     * @param {number} nCycles\n     *\n     * This is a notification handler, called by the CPU, to inform us that the CPU has now stopped running.\n     */\n    stop(msStart, nCycles)\n    {\n        if (!this.fStepOver) {\n            this.println(\"stopped\");\n            if (nCycles) {\n                var msTotal = Usr.getTime();\n                msTotal -= msStart;\n                this.println(msTotal + \"ms (\" + nCycles + \" cycles)\");\n                if (DEBUG && msTotal > 0) {\n                    nCycles = nCycles * 1000 / msTotal;\n                    this.println(\"total cycles/second: \" + Math.round(nCycles));\n                    var percent = Math.round((this.cIns? this.cReads / this.cIns : 0) * 1000) / 10;\n                    this.println(\"total reads: \" + this.cReads + \" (\" + percent + \"%)\");\n                    percent = Math.round((this.cIns? this.cWrites / this.cIns : 0) * 1000) / 10;\n                    this.println(\"total writes: \" + this.cWrites + \" (\" + percent + \"%)\");\n                    percent = Math.round((this.cIns? this.cWritesZP / this.cIns : 0) * 1000) / 10;\n                    this.println(\"total zero-page writes: \" + this.cWritesZP + \" (\" + percent + \"%)\");\n                    this.println(\"total instructions: \" + this.cIns);\n                }\n            }\n        }\n        this.update();\n        this.setFocus();\n        if (!this.fStepOver) {\n            this.cIns = 0;\n            this.cReads = this.cWrites = this.cWritesZP = 0;\n        }\n        this.clearTempBreakpoint(this.cpu.regPC);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     *\n     * This is a check function, called by the CPU, indicating whether other instructions need to be checked.\n     */\n    checksEnabled()\n    {\n        return (DEBUG? true : (this.aExecBreak.length > 0 || this.aReadBreak.length > 0 || this.aWriteBreak.length > 0));\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} bOpCode\n     * @return {boolean} true to proceed, false to halt\n     *\n     * This is a check function, called by the CPU, to inform us about the next instruction to be executed, giving\n     * us an opportunity to look for \"exec\" breakpoints and update opcode frequencies and instruction history.\n     */\n    checkInstruction(addr, bOpCode)\n    {\n        var fBreak = false;\n        if (this.checkBreakpoint(addr, this.aExecBreak, \"exec\"))\n            fBreak = true;\n        else {\n            this.cIns++;\n            this.aaOpcodeFreqs[bOpCode][1]++;\n            this.aStepHistory[this.iStepHistory++] = this.cpu.regPC;\n            if (this.iStepHistory >= this.aStepHistory.length)\n                this.iStepHistory = 0;\n        }\n        return !fBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {boolean} true to proceed, false to halt\n     *\n     * This is a check function, called by the CPU, to inform us that a memory read occurred, giving us an\n     * opportunity to track the read if we want, and look for a matching \"read\" breakpoint, if any.\n     */\n    checkMemoryRead(addr)\n    {\n        var fBreak = false;\n        this.cReads++;\n        if (this.checkBreakpoint(addr, this.aReadBreak, \"read\"))\n            fBreak = true;\n        return !fBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} value written\n     * @return {boolean} true to proceed, false to halt\n     *\n     * This is a check function, called by the CPU, to inform us that a memory write occurred, giving us an\n     * opportunity to track the write if we want, and look for a matching \"write\" breakpoint, if any.\n     */\n    checkMemoryWrite(addr, value)\n    {\n        var fBreak = false;\n        this.cWrites++;\n        /*\n         * NOTE: We keep track of zero-page writes mainly as a reminder to look into whether it makes sense\n         * for the CPU to calculate zero-page EAs using a different variable (eg, regEAWriteZP instead of regEAWrite),\n         * because write-notification handlers never care about page zero accesses, and while write breakpoints *may*\n         * care, it may not be worth the cost of tracking writes to page zero if there's an associated perf penalty.\n         */\n        if (!(addr & 0xff00))\n            this.cWritesZP++;\n        if ((value & 0xff) != value) {\n            this.println(\"invalid value at \" + Str.toHexWord(addr) + \": \" + value);\n            fBreak = true;\n        }\n        if (this.checkBreakpoint(addr, this.aWriteBreak, \"write\"))\n            fBreak = true;\n        return !fBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} b\n     * @return {number}\n     */\n    addSignedByte(addr, b)\n    {\n        return addr + ((b << 24) >> 24);\n    }\n\n    /**\n     * getByte() should be used for all memory reads performed by the Debugger (eg, doDump, doUnassemble),\n     * to insure that the CPU is properly notified (and by extension, any device that's registered a\n     * notification handler with the CPU).\n     *\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {number|undefined}\n     */\n    getByte(addr)\n    {\n        var b;\n        if (addr >= this.offMem && addr < this.offLimit) {\n            this.cpu.checkReadNotify(addr);\n            b = this.abMem[this.offMem + addr];\n\n            b &= 0xff;\n        }\n        return b;\n    }\n\n    /**\n     * setByte() should be used for all memory writes performed by the Debugger (eg, doAssemble, doEdit),\n     * to insure that the CPU is properly notified (and by extension, any device that's registered a\n     * notification handler with the CPU).\n     *\n     * NOTE: Even though we call all write-notification handlers, we don't include a \"from\" address,\n     * because the write originated from the Debugger, not from a CPU instruction.  As a result, handlers should\n     * not refuse the write unless they have good reason; in particular, the ROM handlers will not refuse our writes,\n     * allowing the Debugger to modify ROM contents as needed.\n     *\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} b\n     */\n    setByte(addr, b)\n    {\n        if (addr < this.offMem || addr >= this.offLimit) {\n            this.println(\"invalid address: \" + Str.toHexWord(addr));\n            return;\n        }\n        this.abMem[this.offMem + addr] = (b & 0xff);\n        this.cpu.checkWriteNotify(addr);\n        this.cpu.update();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    clearBreakpoints()\n    {\n        this.aExecBreak = [];\n        this.aReadBreak = [];\n        this.aWriteBreak = [];\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {boolean}\n     */\n    addExecBreakpoint(addr)\n    {\n        if (!this.findExecBreakpoint(addr)) {\n            this.aExecBreak.push(addr);\n        }\n        return true;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {boolean}\n     */\n    addReadBreakpoint(addr)\n    {\n        if (!this.findReadBreakpoint(addr)) {\n            this.aReadBreak.push(addr);\n        }\n        return true;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @return {boolean}\n     */\n    addWriteBreakpoint(addr)\n    {\n        if (!this.findWriteBreakpoint(addr)) {\n            this.aWriteBreak.push(addr);\n        }\n        return true;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {Array}\n     */\n    getExecBreakpoints()\n    {\n        return this.aExecBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {Array}\n     */\n    getReadBreakpoints()\n    {\n        return this.aReadBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {Array}\n     */\n    getWriteBreakpoints()\n    {\n        return this.aWriteBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array} aBreak\n     * @param {number} addr\n     * @param {boolean} [fRemove]\n     * @return {boolean}\n     */\n    findBreakpoint(aBreak, addr, fRemove)\n    {\n        var fMatch = false;\n        for (var i=0; i < aBreak.length; i++) {\n            if (aBreak[i] == addr) {\n                if (fRemove) {\n                    aBreak.splice(i, 1);\n                }\n                fMatch = true;\n                break;\n            }\n        }\n        return fMatch;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {boolean} [fRemove]\n     * @return {boolean}\n     */\n    findExecBreakpoint(addr, fRemove)\n    {\n        return this.findBreakpoint(this.aExecBreak, addr, fRemove);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {boolean} [fRemove]\n     * @return {boolean}\n     */\n    findReadBreakpoint(addr, fRemove)\n    {\n        return this.findBreakpoint(this.aReadBreak, addr, fRemove);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {boolean} [fRemove]\n     * @return {boolean}\n     */\n    findWriteBreakpoint(addr, fRemove)\n    {\n        return this.findBreakpoint(this.aWriteBreak, addr, fRemove);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number|undefined} addr of new temp breakpoint\n     */\n    setTempBreakpoint(addr)\n    {\n        if (addr !== undefined) {\n            /*\n             * I don't want temporary breakpoints growing out of control, so I forcibly clear any\n             * existing temp breakpoint by feeding clearTempBreakpoint() the current temp address, if any;\n             * but you can remove the next line if you decide multiple temp breakpoints are a good thing.\n             */\n            this.clearTempBreakpoint(this.addrTempBP);\n            if (this.addExecBreakpoint(addr))\n                this.addrTempBP = addr;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr to compare to addrTempBP; the latter is cleared if there's a match\n     */\n    clearTempBreakpoint(addr)\n    {\n        if (this.addrTempBP !== undefined && addr == this.addrTempBP) {\n            if (this.findExecBreakpoint(this.addrTempBP, true)) {\n                this.addrTempBP = undefined;\n            }\n        }\n        this.fStepOver = false;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {Array} aBreakpoints\n     * @param {string} sType (ie, \"exec\" or \"write\")\n     * @return {boolean} true if breakpoint has been hit, false if not\n     */\n    checkBreakpoint(addr, aBreakpoints, sType)\n    {\n        /*\n         * Time to check for execution breakpoints; note that this should be done BEFORE updating any of the frequency\n         * or history data (see checkInstruction), since we might not actually execute the current instruction.\n         */\n        var fBreak = false;\n        for (var i=0; i < aBreakpoints.length; i++) {\n            if (aBreakpoints[i] == addr) {\n                if (addr != this.addrTempBP)\n                    this.println(\"breakpoint hit: \" + Str.toHexWord(addr) + \" (\" + sType + \")\");\n                fBreak = true;\n                break;\n            }\n        }\n        return fBreak;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {number} addr\n     * @param {number} [nIns] is an associated instruction number, or 0 (or undefined) if none\n     * @return {string}\n     */\n    getInstruction(addr, nIns)\n    {\n        var sLine = Str.toHex(addr, 4);\n        var bOpCode = this.getByte(addr++);\n        var b = (bOpCode === undefined? 0 : bOpCode);\n        var aOpDesc = this.aaOperations[b];\n        var abOperand = [];\n        var cb = (aOpDesc[1] === undefined? 0 : aOpDesc[1]);\n        do {\n            sLine += \" \" + Str.toHex(b, 2);\n            if (!(cb--)) break;\n            b = this.getByte(addr++);\n            if (b === undefined) break;\n            abOperand.push(b);\n        } while (true);\n        if (aOpDesc[0] === undefined) {\n            aOpDesc = [this.OP_DB, 1, this.MODE_IMM];\n            abOperand.push(bOpCode);\n        }\n        sLine = (sLine + \"        \").substr(0, 15);\n        sLine += this.aOpCodes[aOpDesc[0]];\n        var sOperand = null;\n        if (aOpDesc[2] !== undefined) {\n            var bOpMode = aOpDesc[2];\n            sOperand = this.aOpModes[bOpMode];\n            if (aOpDesc[1] == 1 && bOpMode == this.MODE_DISP) {\n                sOperand = sOperand.replace(/nnnn/, Str.toHex(this.addSignedByte(addr, b = abOperand.pop()), 4));\n            }\n            else {\n                while (abOperand.length) {\n                    sOperand = sOperand.replace(/nn/, Str.toHex(b = abOperand.pop(), 2));\n                }\n            }\n            if (bOpMode == this.MODE_IMM && aOpDesc[1] == 1) {\n                if (b >= 0x20 && b < 0x80)\n                    sOperand += \" ;'\" + String.fromCharCode(b) + \"'\";\n            }\n        }\n        if (bOpCode == this.cpu.OP_SIM) {\n            if (b < this.aOpSimCodes.length)\n                sOperand = this.aOpSimCodes[b];\n            if (b == this.cpu.SIMOP_MSG) {\n                cb = 0;\n                sOperand = \"\\\"\";\n                while ((b = this.getByte(addr++))) {\n                    if (cb < 16)\n                        sOperand += String.fromCharCode(b);\n                    else if (cb == 16)\n                        sOperand += \"\";\n                    cb++;\n                }\n                sOperand += \"\\\"\";\n            }\n        }\n        if (sOperand) sLine += \" \" + sOperand;\n        if (nIns) {\n            sLine += \"               \";\n            sLine = sLine.substr(0, 30);\n            sLine += \";\" + nIns.toString();\n        }\n        this.nextIns = addr;\n        return sLine;\n    }\n\n    /**\n     * parseInstruction(sCode, sOperand, addr)\n     *\n     * This generally requires an exact match of both the operation code (sCode) and mode operand (sOperand)\n     * against the aOpCodes[] and aOpModes[] arrays, respectively; however, the regular expression built from\n     * aOpModes and stored in regexOpModes does relax the matching criteria slightly; ie, a 4-digit hex value\n     * (\"nnnn\") will be satisfied with either 3 or 4 digits, and similarly, a 2-digit hex address (nn) will\n     * be satisified with either 1 or 2 digits.\n     *\n     * Note that this function does not actually store the instruction into memory, even though it requires\n     * a target address (addr); that parameter is currently needed ONLY for \"branch\" instructions, because in\n     * order to calculate the branch displacement, it needs to know where the instruction will ultimately be\n     * stored, relative to its target address.\n     *\n     * Another handy feature of this function is its ability to display all available modes for a particular\n     * operation. For example, while in \"assemble mode\", if one types:\n     *\n     *      ldy?\n     *\n     * the Debugger will display:\n     *\n     *      supported opcodes:\n     *           A0: LDY nn\n     *           A4: LDY [nn]\n     *           AC: LDY [nnnn]\n     *           B4: LDY [nn+X]\n     *           BC: LDY [nnnn+X]\n     *\n     * Use of a trailing \"?\" on any opcode will display all variations of that opcode; no instruction will be\n     * assembled, and the operand parameter, if any, will be ignored.\n     *\n     * Although this function is capable of reporting numerous errors, roughly half of them indicate internal\n     * consistency errors, not user errors; the former should really be asserts, but I'm not comfortable bombing\n     * out because of my error as opposed to their error.  The only errors a user should expect to see:\n     *\n     *      \"unknown operation\":    sCode is not a valid operation (per aOpCodes)\n     *      \"unknown operand\":      sOperand is not a valid operand (per aOpModes)\n     *      \"unknown instruction\":  the combination of sCode + sOperand does not exist (per aaOperations)\n     *      \"branch out of range\":  the branch address, relative to addr, is too far away\n     *\n     * @this {C1PDebugger}\n     * @param {string} sCode\n     * @param {string|undefined} sOperand\n     * @param {number} addr of memory where this instruction is being assembled\n     * @return {Array.<number>} of opcode bytes; if the instruction can't be parsed, the array will be empty\n     */\n    parseInstruction(sCode, sOperand, addr)\n    {\n        var aOpBytes = [];\n        if (sCode !== undefined) {\n            var iCode, iMode;\n            /*\n             * Find the iCode that corresponds to the given operation code\n             */\n            sCode = sCode.toUpperCase();\n            if (sCode.charAt(sCode.length-1) == \"?\") {\n                sOperand = \"?\";\n                sCode = sCode.substr(0, sCode.length-1);\n            }\n            for (iCode=0; iCode < this.aOpCodes.length; iCode++) {\n                if (sCode == this.aOpCodes[iCode]) {\n                    break;\n                }\n            }\n            if (iCode == this.aOpCodes.length) {\n                this.println(\"unknown operation: \" + sCode);\n                iCode = -1;\n            }\n            var sMode = \"\", aModeMatch, i;\n            if (iCode >= 0 && sOperand !== undefined) {\n                sMode = sOperand.toUpperCase();\n                if (sMode == \"?\") {\n                    var cModes = 0;\n                    for (i = 0; i < this.aaOperations.length; i++) {\n                        if (this.aaOperations[i][0] === iCode) {\n                            if (!cModes) this.println(\"supported opcodes:\");\n                            this.println(\"     \" + Str.toHex(i, 2) + \": \" + sCode + (this.aaOperations[i][2] !== undefined? (\" \" + this.aOpModes[this.aaOperations[i][2]]) : \"\"));\n                            cModes++;\n                        }\n                    }\n                    iCode = -1;\n                }\n                else {\n                    /*\n                     * Find the iMode that corresponds to the given operand\n                     */\n                    aModeMatch = sMode.match(this.regexOpModes);\n                    if (aModeMatch !== null && aModeMatch[0] == sMode) {\n                        /*\n                         * One of the sub-patterns must have matched as well; the index of the matching\n                         * sub-pattern will correspond to the proper aOpModes index, albeit off-by-one since\n                         * the regex match at [0] is the complete match, not a sub-pattern match.\n                         */\n                        for (i = 1; i < aModeMatch.length; i++) {\n                            if (aModeMatch[i] == sMode) {\n                                if (iMode === undefined)\n                                    iMode = i-1;\n                                else {\n                                    /*\n                                     * This is really an internal consistency error; regardless what the user types, this should not occur.\n                                     */\n                                    //noinspection JSUnusedAssignment\n                                    this.println(\"too many operand matches (both \" + this.aOpModes[iMode] + \" and \" + this.aOpModes[i-1] + \")\");\n                                    iCode = -1;\n                                    break;\n                                }\n                            }\n                        }\n                        /*\n                         * Regrettably, if \"classic\" operand syntax is in effect, then we must look at the context of the\n                         * operand (ie, the operation code) whenever we have a MODE_IMM16 (or MODE_DISP) match, because it might\n                         * actually be a MODE_ABS operand; see setOpModes() for details of the aImm16Codes array.\n                         */\n                        if (iMode == this.MODE_IMM16) {\n                            if (this.aImm16Codes.indexOf(iCode) < 0)\n                                iMode = this.MODE_ABS;\n                        }\n                        /*\n                         * Even in \"modern\" syntax mode, we have to look at the context of a MODE_ABS16 match, because unless\n                         * the operation is OP_JMP, then the mode must actually be MODE_ABS.\n                         */\n                        if (iMode == this.MODE_ABS16) {\n                            if (iCode != this.OP_JMP)\n                                iMode = this.MODE_ABS;\n                        }\n                    }\n                    else {\n                        this.println(\"unknown operand: \" + sMode);\n                        iCode = -1;\n                    }\n                }\n            }\n            if (iCode >= 0) {\n                /*\n                 * So we have an iCode and possibly an iMode; find the one (and hopefully only) aaOperations instruction entry that matches\n                 */\n                var bOpCode = -1;\n                for (i = 0; i < this.aaOperations.length; i++) {\n                    if (this.aaOperations[i][0] === iCode && this.aaOperations[i][2] === iMode) {\n                        if (bOpCode < 0)\n                            bOpCode = i;\n                        else {\n                            /*\n                             * This is really an internal consistency error; regardless what the user types, this should not occur.\n                             */\n                            this.println(\"too many instruction matches (both \" + Str.toHexByte(bOpCode) + \" and \" + Str.toHexByte(i) + \")\");\n                            bOpCode = -2;\n                            break;\n                        }\n                    }\n                }\n                if (bOpCode >= 0) {\n                    aOpBytes.push(bOpCode);\n                    if (iMode !== undefined) {\n                        var cb = this.aaOperations[bOpCode][1];\n                        var asHex = sMode.match(/[0-9A-F]+/);\n                        if (asHex !== null) {\n                            var nHex = parseInt(asHex[0], 16);\n                            if (cb == 1 && iMode == this.MODE_DISP) {\n                                nHex -= (addr + 2);\n                                if (nHex < -128 || nHex > 127) {\n                                    this.println(\"branch out of range (\" + nHex + \")\");\n                                    aOpBytes = [];\n                                    cb = 0;\n                                }\n                            }\n                            for (i = 0; i < cb; i++) {\n                                aOpBytes.push(nHex & 0xff);\n                                nHex >>>= 8;\n                            }\n                        }\n                        else if (cb) {\n                            /*\n                             * This is really an internal consistency error; regardless what the user types, this should not occur.\n                             */\n                            this.println(\"instruction missing \" + cb + \" bytes\");\n                        }\n                    }\n                }\n                else {\n                    this.println(\"unknown instruction: \" + sCode + \" \" + sMode + (DEBUG? (\" (\" + iMode + \")\") : \"\"));\n                }\n            }\n        }\n        return aOpBytes;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @return {string}\n     */\n    getRegs()\n    {\n        return \"A=\" + Str.toHex(this.cpu.regA, 2) +\n              \" X=\" + Str.toHex(this.cpu.regX, 2) +\n              \" Y=\" + Str.toHex(this.cpu.regY, 2) +\n              \" P=\" + Str.toHex(this.cpu.getRegP(), 2) +\n              \" S=\" + Str.toHex(this.cpu.regS, 4) +\n              \" PC=\" + Str.toHex(this.cpu.regPC, 4);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string|undefined} [sAddr]\n     * @return {number|undefined}\n     */\n    getUserAddr(sAddr)\n    {\n        var addr = this.nextAddr;\n        if (sAddr !== undefined) {\n            var nBase = 16;\n            if (sAddr.charAt(0) == \"$\")\n                sAddr = sAddr.substr(1);\n            else\n            if (sAddr.substr(0, 2) == \"0x\")\n                sAddr = sAddr.substr(2);\n            else\n            if (sAddr.charAt(sAddr.length-1) == \".\") {\n                nBase = 10;\n                sAddr = sAddr.substr(0, sAddr.length-1);\n            }\n            addr = parseInt(sAddr, nBase);\n            if (isNaN(addr)) {\n                this.println(\"invalid base-\" + nBase + \" address: \" + sAddr);\n                addr = undefined;\n            }\n        }\n        if (addr !== undefined && (addr < this.offMem || addr >= this.offLimit)) {\n            this.println(\"address out of range: \" + Str.toHex(addr));\n            addr = undefined;\n        }\n        return addr;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    doHelp()\n    {\n        this.println(\"\\ncommands:\\n?\\thelp\\na [#]\\tassemble\\nb [#]\\tbreakpoint\\nd [#]\\tdump memory\\ne [#]\\tedit memory\\nf\\tdump frequencies\\ng [#]\\trun to [#]\\nh\\thalt\\no\\toptions\\np [#]\\tdump history\\nr\\tdump/edit registers\\ns\\tstep over instruction\\nt [#]\\tstep instruction(s)\\nu [#]\\tunassemble\");\n        this.println(\"note: frequency and history commands operate only when breakpoints are set\");\n    }\n\n    /**\n     * doAssemble() always receives the complete argument array, where the order of the arguments is:\n     *\n     *      [0]: the assemble command (assumed to be \"a\")\n     *      [1]: the target address (eg, \"200\")\n     *      [2]: the operation code, aka mnemonic (eg, \"adc\")\n     *      [3]: the operation mode operand, if any (eg, \"14\", \"[1234]\", etc)\n     *\n     * The Debugger enters \"assemble mode\" whenever only the first (or first and second) arguments are present.\n     * As long as \"assemble mode is active, the user can omit the first two arguments on all later assemble commands\n     * until \"assemble mode\" is cancelled with an empty command line; the command processor automatically prepends \"a\"\n     * and the next available target address to the argument array.\n     *\n     * Entering \"assemble mode\" is optional; one could enter a series of fully-qualified assemble commands; eg:\n     *\n     *      a ff00 cld\n     *      a ff01 ldx 28\n     *      ...\n     *\n     * without ever entering \"assemble mode\", but of course, that requires more typing and doesn't take advantage\n     * of automatic target address advancement (see addrAssembleNext).\n     *\n     * NOTE: As the previous example implies, you can even assemble new instructions into ROM address space;\n     * as our setByte() function explains, the ROM write-notification handlers only refuse writes from the CPU.\n     *\n     * @this {C1PDebugger}\n     * @param {Array.<string>} asArgs is the complete argument array, beginning with the \"a\" command in asArgs[0]\n     */\n    doAssemble(asArgs)\n    {\n        var addr = this.getUserAddr(asArgs[1]);\n        if (addr === undefined)\n            return;\n        this.addrAssembleNext = addr;\n        if (asArgs[2] === undefined) {\n            this.println(\"begin assemble @\" + Str.toHexWord(this.addrAssembleNext));\n            this.fAssemble = true;\n            this.cpu.update();\n            return;\n        }\n        var aOpBytes = this.parseInstruction(asArgs[2], asArgs[3], this.addrAssembleNext);\n        if (aOpBytes.length) {\n            for (var i=0; i < aOpBytes.length; i++) {\n                // this.println(Str.toHexWord(this.addrAssembleNext) + \": \" + Str.toHexByte(aOpBytes[i]));\n                this.setByte(this.addrAssembleNext+i, aOpBytes[i]);\n            }\n            this.println(this.getInstruction(this.addrAssembleNext));\n            this.addrAssembleNext += aOpBytes.length;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} [sParm]\n     * @param {string} [sAddr]\n     */\n    doBreak(sParm, sAddr)\n    {\n        if (sParm === undefined || sParm == \"?\") {\n            this.println(\"\\nbreakpoint commands:\");\n            this.println(\"bp [a]\\tset exec breakpoint at [a]\");\n            this.println(\"br [a]\\tset read breakpoint at [a]\");\n            this.println(\"bw [a]\\tset write breakpoint at [a]\");\n            this.println(\"bc [a]\\tclear breakpoint at [a]\");\n            this.println(\"bl\\tlist all breakpoints\");\n            return;\n        }\n        if (sAddr === undefined && sParm.length > 1) {\n            sAddr = sParm.substr(1);\n            sParm = sParm.substr(0, 1);\n        }\n        if (sParm == \"l\") {\n            var cBreaks = 0, i;\n            var aAddrs = this.getExecBreakpoints();\n            for (i = 0; i < aAddrs.length; i++) {\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(aAddrs[i]) + \" (exec)\");\n                cBreaks++;\n            }\n            aAddrs = this.getReadBreakpoints();\n            for (i = 0; i < aAddrs.length; i++) {\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(aAddrs[i]) + \" (read)\");\n                cBreaks++;\n            }\n            aAddrs = this.getWriteBreakpoints();\n            for (i = 0; i < aAddrs.length; i++) {\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(aAddrs[i]) + \" (write)\");\n                cBreaks++;\n            }\n            if (!cBreaks)\n                this.println(\"no breakpoints\");\n            return;\n        }\n        if (sAddr === undefined) {\n            this.println(\"missing breakpoint address\");\n            return;\n        }\n        if (sParm == \"c\" && sAddr == \"*\") {\n            this.clearBreakpoints();\n            this.println(\"all breakpoints cleared\");\n            return;\n        }\n        var addr = this.getUserAddr(sAddr);\n        if (addr === undefined)\n            return;\n        if (sParm == \"p\") {\n            if (this.addExecBreakpoint(addr))\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(addr) + \" (exec)\");\n            else\n                this.println(\"breakpoint not set: \" + Str.toHexWord(addr));\n            return;\n        }\n        if (sParm == \"c\") {\n            if (this.findExecBreakpoint(addr, true))\n                this.println(\"breakpoint cleared: \" + Str.toHexWord(addr) + \" (exec)\");\n            else\n            if (this.findReadBreakpoint(addr, true))\n                this.println(\"breakpoint cleared: \" + Str.toHexWord(addr) + \" (read)\");\n            else\n            if (this.findWriteBreakpoint(addr, true))\n                this.println(\"breakpoint cleared: \" + Str.toHexWord(addr) + \" (write)\");\n            else\n                this.println(\"breakpoint missing: \" + Str.toHexWord(addr));\n            return;\n        }\n        if (sParm == \"r\") {\n            if (this.addReadBreakpoint(addr))\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(addr) + \" (read)\");\n            else\n                this.println(\"breakpoint not set: \" + Str.toHexWord(addr));\n            return;\n        }\n        if (sParm == \"w\") {\n            if (this.addWriteBreakpoint(addr))\n                this.println(\"breakpoint enabled: \" + Str.toHexWord(addr) + \" (write)\");\n            else\n                this.println(\"breakpoint not set: \" + Str.toHexWord(addr));\n            return;\n        }\n        this.println(\"unknown breakpoint command: \" + sParm);\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sAddr\n     * @param {string} sLen\n     */\n    doDump(sAddr, sLen)\n    {\n        if (sAddr == \"?\") {\n            this.println(\"\\ndump commands:\");\n            this.println(\"d [a] [#]    dump # lines of memory\");\n            return;\n        }\n        var addr = this.getUserAddr(sAddr);\n        if (addr === undefined)\n            return;\n        var cLines = 0;\n        if (sLen !== undefined) {\n            if (sLen.charAt(0) == \"l\")\n                sLen = sLen.substr(1);\n            cLines = parseInt(sLen, 10);\n        }\n        if (!cLines) cLines = 1;\n        for (var line=0; line < cLines; line++) {\n            var sBytes = \"\";\n            var sChars = \"\";\n            var addrLine = addr;\n            for (var i=0; i < 8 && addr < this.offLimit; i++) {\n                var b = this.getByte(addr);\n                if (b === undefined) b = 0;\n                sBytes += Str.toHex(b, 2) + \" \";\n                sChars += (b >= 32 && b < 127? String.fromCharCode(b) : \".\");\n                addr++;\n            }\n            this.println(Str.toHex(addrLine, 4) + \" \" + sBytes + sChars);\n        }\n        this.nextAddr = addr;\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array.<string>} asArgs\n     */\n    doEdit(asArgs)\n    {\n        var sAddr = asArgs[1];\n        if (sAddr === undefined) {\n            this.println(\"missing address\");\n            return;\n        }\n        var addr = this.getUserAddr(sAddr);\n        if (addr === undefined)\n            return;\n        for (var i=2; i < asArgs.length; i++) {\n            var b = parseInt(asArgs[i], 16);\n            this.setByte(addr++, b);\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sParm\n     */\n    doFreqs(sParm)\n    {\n        if (sParm == \"?\") {\n            this.println(\"\\nfrequency commands:\");\n            this.println(\"clear\\tclear all frequency counts\");\n            return;\n        }\n        var cData = 0, i;\n        if (this.aaOpcodeFreqs) {\n            if (sParm == \"clear\") {\n                for (i = 0; i < this.aaOpcodeFreqs.length; i++)\n                    this.aaOpcodeFreqs[i] = [i, 0];\n                this.println(\"frequency data cleared\");\n                cData++;\n            }\n            else if (sParm !== undefined) {\n                this.println(\"unknown frequency command: \" + sParm);\n                cData++;\n            }\n            else {\n                var aaSortedOpcodeFreqs = this.aaOpcodeFreqs.slice();\n                aaSortedOpcodeFreqs.sort(function(p, q) {return q[1] - p[1];});\n                for (i = 0; i < aaSortedOpcodeFreqs.length; i++) {\n                    var bOpcode = aaSortedOpcodeFreqs[i][0];\n                    var cFreq = aaSortedOpcodeFreqs[i][1];\n                    if (cFreq) {\n                        this.println(this.aOpCodes[this.aaOperations[bOpcode][0]] + \" (\" + Str.toHexByte(bOpcode) + \"): \" + cFreq + \" times\");\n                        cData++;\n                    }\n                }\n            }\n        }\n        if (!cData) {\n            this.println(\"no frequency data available\");\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    doHalt()\n    {\n        this.halt();\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sCount\n     */\n    doHistory(sCount)\n    {\n        var cLines = 10;\n        var iHistory = this.iStepHistory;\n        var aHistory = this.aStepHistory;\n        if (aHistory !== undefined) {\n            var n = (sCount === undefined? this.nextHistory : parseInt(sCount, 10));\n            if (n === undefined)\n                n = 10;\n            if (n > aHistory.length) {\n                this.println(\"note: only \" + aHistory.length + \" available\");\n                n = aHistory.length;\n            }\n            if (sCount !== undefined) {\n                this.nInsHistory = 0;\n                this.println(n + \" instructions earlier:\");\n            }\n            var nIns = (this.nInsHistory? this.nInsHistory : 1);\n            iHistory -= n;\n            if (iHistory < 0) iHistory = aHistory.length - 1;\n            while (cLines && iHistory != this.iStepHistory) {\n                var addr = aHistory[iHistory];\n                if (addr < 0) break;\n                this.println(this.getInstruction(addr, nIns++));\n                if (++iHistory == aHistory.length) iHistory = 0;\n                cLines--;\n                n--;\n            }\n            this.nextHistory = n;\n            this.nInsHistory = nIns;\n        }\n        if (cLines == 10) this.println(\"no history available\");\n    }\n\n    /**\n     * Prints the contents of the Debugger's \"info\" buffer (filled by calls like cpu.dbg.info())\n     * @this {C1PDebugger}\n     * @param {string|undefined} sCount\n     * @return {boolean|undefined} true only if the \"info\" command is supported\n     */\n    doInfo(sCount)\n    {\n        if (DEBUG) {\n            var cLines = (sCount === undefined? -1 : parseInt(sCount, 10));\n            var i = this.iInfoBuffer;\n            do {\n                var s = this.aInfoBuffer[i++];\n                if (s !== undefined) {\n                    this.println(s);\n                    cLines--;\n                }\n                if (i >= this.aInfoBuffer.length)\n                    i = 0;\n            } while (cLines && i != this.iInfoBuffer);\n            this.println(\"nYieldsPerSecond: \" + this.cpu.nYieldsPerSecond);\n            this.println(\"msPerYield: \" + this.cpu.msPerYield);\n            this.println(\"nCyclesPerBurst: \" + this.cpu.nCyclesPerBurst);\n            this.println(\"nCyclesPerYield: \" + this.cpu.nCyclesPerYield);\n            this.println(\"nCyclesPerVideoUpdate: \" + this.cpu.nCyclesPerVideoUpdate);\n            this.println(\"nCyclesPerStatusUpdate: \" + this.cpu.nCyclesPerStatusUpdate);\n            return true;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} [sAddr]\n     * @param {string} [sAddrEnd]\n     * @param {number} [n]\n     */\n    doUnassemble(sAddr, sAddrEnd, n)\n    {\n        var addr = this.getUserAddr(sAddr);\n        if (addr === undefined)\n            return;\n\n        if (n === undefined) n = 1;\n        var addrEnd = this.offLimit;\n        if (sAddrEnd !== undefined) {\n            addrEnd = this.getUserAddr(sAddrEnd);\n            if (addrEnd === undefined || addrEnd < addr)\n                return;\n            if (!DEBUG && (addrEnd - addr) > 0x100) {\n                /*\n                 * Limiting the amount of disassembled code to one \"memory page\" in non-DEBUG builds is partly\n                 * to prevent the user from wedging their browser, but also a recognition that, in non-DEBUG builds,\n                 * the println() output buffer is truncated to 8K, which is only enough for about two pages of\n                 * disassembled code anyway.\n                 */\n                this.println(\"range too large\");\n                return;\n            }\n            addrEnd++;\n            n = -1;\n        }\n\n        if (addr != this.nextAddr)\n            this.println();\n\n        while (n-- && addr < addrEnd) {\n            var sIns = this.getInstruction(addr, this.isBusy(false) || this.fStepOver? this.cIns : 0);\n            this.println(sIns);\n            this.nextAddr = addr = this.nextIns;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array.<string>} asArgs\n     */\n    doOptions(asArgs)\n    {\n        if (asArgs[1] === undefined || asArgs[1] == \"?\") {\n            this.println(\"\\noption commands:\");\n            this.println(\"max\\trun at maximum speed\");\n            this.println(\"fast\\trun faster (up to \" + this.cpu.mhzFast + \"Mhz)\");\n            this.println(\"slow\\trun at normal speed (1Mhz)\");\n            this.println(\"classic\\tuse classic operand syntax\");\n            this.println(\"modern\\tuse modern operand syntax\");\n            this.println(\"msg\\tenable message categories\");\n            return;\n        }\n        var sOption = asArgs[1];\n        switch(sOption) {\n        case \"slow\":\n            this.cpu.setSpeed(this.cpu.SPEED_SLOW);\n            break;\n        case \"fast\":\n            this.cpu.setSpeed(this.cpu.SPEED_FAST);\n            break;\n        case \"max\":\n            this.cpu.setSpeed(this.cpu.SPEED_MAX);\n            break;\n        case \"classic\":\n            this.setOpModes(true);\n            this.println(\"classic syntax enabled\");\n            break;\n        case \"modern\":\n            this.setOpModes(false);\n            this.println(\"modern syntax enabled\");\n            break;\n        case \"msg\":\n            var bitsMessage = 0;\n            if (asArgs[2] !== undefined) {\n                if (asArgs[2] == \"all\")\n                    bitsMessage = 0xff;\n                else if (this.aMessageCategories[asArgs[2]] !== undefined)\n                    bitsMessage = this.aMessageCategories[asArgs[2]];\n                if (bitsMessage) {\n                    if (asArgs[3] == \"on\") {\n                        this.bitsMessage |= bitsMessage;\n                    }\n                    else if (asArgs[3] == \"off\") {\n                        this.bitsMessage &= ~bitsMessage;\n                    }\n                }\n            }\n            for (var sCategory in this.aMessageCategories) {\n                if (asArgs[2] !== undefined && (asArgs[2] != \"all\" && asArgs[2] != sCategory)) continue;\n                bitsMessage = this.aMessageCategories[sCategory];\n                this.println(sCategory + \" messages: \" + ((this.bitsMessage & bitsMessage)? \"on\" : \"off\"));\n            }\n            break;\n        default:\n            this.println(\"unknown option: \" + sOption);\n            break;\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {Array.<string>} [asArgs]\n     */\n    doRegisters(asArgs)\n    {\n        if (asArgs && asArgs[1] == \"?\") {\n            this.println(\"\\nregister commands:\");\n            this.println(\"r to display all\");\n            this.println(\"r [target=value] to modify\");\n            this.println(\"supported targets:\");\n            this.println(\"A,X,Y,S,PC and flags C,Z,D,V,N\");\n            return;\n        }\n        var fIns = true;\n        if (asArgs !== undefined && asArgs.length > 1) {\n            fIns = false;\n            var sReg = asArgs[1];\n            var sValue = null;\n            var i = sReg.indexOf(\"=\");\n            if (i > 0) {\n                sValue = sReg.substr(i+1);\n                sReg = sReg.substr(0, i);\n            }\n            else if (asArgs.length > 2) {\n                sValue = asArgs[2];\n            }\n            else {\n                this.println(\"missing value for \" + asArgs[1]);\n                return;\n            }\n            var b = parseInt(sValue, 16);\n            if (!isNaN(b)) {\n                switch(sReg.toUpperCase()) {\n                case \"A\":\n                    this.cpu.regA = b & 0xff;\n                    break;\n                case \"X\":\n                    this.cpu.regX = b & 0xff;\n                    break;\n                case \"Y\":\n                    this.cpu.regY = b & 0xff;\n                    break;\n                case \"C\":\n                    if (b) this.cpu.setC(); else this.cpu.clearC();\n                    break;\n                case \"Z\":\n                    if (b) this.cpu.setZ(); else this.cpu.clearZ();\n                    break;\n                case \"D\":\n                    if (b) this.cpu.setBCD(); else this.cpu.clearBCD();\n                    break;\n                case \"V\":\n                    if (b) this.cpu.setV(); else this.cpu.clearV();\n                    break;\n                case \"N\":\n                    if (b) this.cpu.setN(); else this.cpu.clearN();\n                    break;\n                case \"S\":\n                    if ((b & ~0xff) != 0x100) {\n                        this.println(\"invalid stack pointer: \" + sValue);\n                        return;\n                    }\n                    this.cpu.regS = b;\n                    break;\n                case \"PC\":\n                    fIns = true;\n                    this.cpu.regPC = b & 0xffff;\n                    this.nextAddr = this.cpu.regPC;\n                    break;\n                default:\n                    this.println(\"unknown register: \" + sReg);\n                    return;\n                }\n            }\n            else {\n                this.println(\"invalid value: \" + sValue);\n                return;\n            }\n            this.cpu.update();\n        }\n        this.println(this.getRegs());\n        if (fIns) this.doUnassemble(Str.toHex(this.nextAddr = this.cpu.regPC, 4));\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} sAddr\n     */\n    doRun(sAddr)\n    {\n        if (sAddr !== undefined)\n            this.setTempBreakpoint(this.getUserAddr(sAddr));\n        if (!this.run()) {\n            this.cpu.setFocus();\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     */\n    doStep()\n    {\n        if (this.getByte(this.cpu.regPC) == this.cpu.OP_JSR) {\n            this.setTempBreakpoint(this.cpu.regPC+3);\n            this.fStepOver = true;\n            if (!this.run())\n                this.cpu.setFocus();\n        }\n        else {\n            this.doTrace();\n        }\n    }\n\n    /**\n     * @this {C1PDebugger}\n     * @param {string} [sCount]\n     */\n    doTrace(sCount)\n    {\n        var c = (sCount === undefined? 1 : parseInt(sCount, 10));\n        var n = (c == 1? 0 : 1);\n        Web.onCountRepeat(\n            c,\n            function(dbg) {\n                return function() {\n                    return dbg.setBusy(true) && dbg.step(n);\n                };\n            }(this),\n            function(dbg) {\n                return function() {\n                    dbg.setBusy(false);\n                };\n            }(this)\n        );\n    }\n\n    static input(dbg, sCmd)\n    {\n        if (!sCmd.length) {\n            if (dbg.fAssemble) {\n                dbg.println(\"ended assemble @\" + Str.toHex(dbg.addrAssembleNext, 4));\n                dbg.nextAddr = dbg.addrAssembleNext;\n                dbg.fAssemble = false;\n            }\n            else\n            if (dbg.prevCmd)\n                sCmd = dbg.prevCmd;\n        }\n        if (dbg.isReady() && !dbg.isBusy(true) && sCmd.length > 0) {\n\n            if (dbg.fAssemble) {\n                sCmd = \"a \" + Str.toHex(dbg.addrAssembleNext, 4) + \" \" + sCmd;\n            }\n            else if (sCmd.length > 1 && sCmd.indexOf(\" \") != 1) {\n                /*\n                 * For certain commands lacking a space after the first character,\n                 * insert an automatic space, so that split(\" \") has the desired effect.\n                 */\n                var ch = sCmd.charAt(0).toLowerCase();\n                sCmd = ch + \" \" + sCmd.substr(1);\n            }\n\n            var asArgs = sCmd.split(\" \");\n            dbg.prevCmd = asArgs[0];\n\n            switch(asArgs[0].toLowerCase()) {\n            case \"a\":\n                dbg.doAssemble(asArgs);\n                break;\n            case \"b\":\n                dbg.doBreak(asArgs[1], asArgs[2]);\n                break;\n            case \"d\":\n                dbg.doDump(asArgs[1], asArgs[2]);\n                break;\n            case \"e\":\n                dbg.doEdit(asArgs);\n                break;\n            case \"f\":\n                dbg.doFreqs(asArgs[1]);\n                break;\n            case \"g\":\n                dbg.doRun(asArgs[1]);\n                break;\n            case \"h\":\n                dbg.doHalt();\n                break;\n            case \"o\":\n                dbg.doOptions(asArgs);\n                break;\n            case \"p\":\n                dbg.doHistory(asArgs[1]);\n                break;\n            case \"r\":\n                dbg.doRegisters(asArgs);\n                break;\n            case \"s\":\n                dbg.doStep();\n                break;\n            case \"t\":\n                dbg.doTrace(asArgs[1]);\n                break;\n            case \"u\":\n                dbg.doUnassemble(asArgs[1], asArgs[2], 8);\n                break;\n            case \"?\":\n            case \"help\":\n                dbg.doHelp();\n                break;\n            case \"i\":\n                if (dbg.doInfo(asArgs[1])) break;\n                /* falls through */\n            default:\n                dbg.println(\"unknown command: \" + sCmd);\n                break;\n            }\n        }\n    }\n\n    /**\n     * C1PDebugger.init()\n     *\n     * This function operates on every HTML element of class \"debugger\", extracting the\n     * JSON-encoded parameters for the C1PDebugger constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PDebugger component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        var aeDbg = Component.getElementsByClass(document, C1PJS.APPCLASS, \"debugger\");\n        for (var iDbg=0; iDbg < aeDbg.length; iDbg++) {\n            var eDbg = aeDbg[iDbg];\n            var parmsDbg = Component.getComponentParms(eDbg);\n            var dbg = new C1PDebugger(parmsDbg);\n            Component.bindComponentControls(dbg, eDbg, C1PJS.APPCLASS);\n        }\n    }\n}\n\nif (DEBUGGER) {\n\n    /*\n     * Initialize every Debugger module on the page (as IF there's ever going to be more than one ;-))\n     */\n    Web.onInit(C1PDebugger.init);\n\n}   // endif DEBUGGER\n\n/**\n * @copyright http://pcjs.org/modules/c1pjs/lib/computer.js (C) Jeff Parsons 2012-2017\n */\n\n\n/**\n * TODO: The Closure Compiler treats ES6 classes as 'struct' rather than 'dict' by default,\n * which would force us to declare all class properties in the constructor, as well as prevent\n * us from defining any named properties.  So, for now, we mark all our classes as 'unrestricted'.\n *\n * @unrestricted\n */\nclass C1PComputer extends Component {\n    /**\n     * C1PComputer(parmsComputer, modules)\n     *\n     * The C1PComputer component expects the following (parmsComputer) properties:\n     *\n     *      modules[{}] (from the <module> definition(s) for the computer)\n     *\n     * This component processes all the <module> \"start\" and \"end\" specifications\n     * and \"wires\" everything to a common \"address buffer\"; namely, the abMemory array.\n     * abMemory encompasses the computer's entire address space, but every component must\n     * play nice and use only its assigned section of abMemory -- and pretend it's an array\n     * of bytes, when in fact it's an array of floating-point values (the only primitive\n     * numeric data type that JavaScript provides).\n     *\n     * This component also insures that all the other components are ready; in particular,\n     * this means that the ROM and Video components have finished loading their resources\n     * and are ready for operation.  Other components become ready as soon as we call their\n     * setBuffer() method (eg, CPU, RAM, Keyboard, Debugger, SerialPort, DiskController), and\n     * others, like Panel, become ready even earlier, at the end of their initialization.\n     *\n     * Once every component has indicated it's ready, we call its setPower() notification\n     * function (if it has one; it's optional).  We call the CPU's setPower() function last,\n     * so that the CPU is assured that all other components are ready and \"powered\".\n     *\n     * @this {C1PComputer}\n     * @param {Object} parmsComputer\n     * @param {Object} modules\n     */\n    constructor(parmsComputer, modules)\n    {\n        super(\"C1PComputer\", parmsComputer);\n\n        this.modules = modules;\n    }\n\n    /**\n     * reset(fPowerOn)\n     *\n     * @this {C1PComputer}\n     * @param {boolean} [fPowerOn] is true to indicate that we should start the CPU running\n     */\n    reset(fPowerOn)\n    {\n        var cpu = null;\n        for (var sType in this.modules) {\n            for (var i=0; i < this.modules[sType].length; i++) {\n                var component = this.modules[sType][i];\n                if (component && component.reset) {\n                    if (DEBUG) this.println(\"resetting \" + sType);\n                    component.reset();\n                    if (sType == \"cpu\") cpu = component;\n                }\n            }\n        }\n        if (cpu) {\n            cpu.update();\n            if (fPowerOn) cpu.run();\n        }\n    }\n\n    /**\n     * start()\n     *\n     * Called by the CPU to notify all component start() handlers.\n     *\n     * @this {C1PComputer}\n     */\n    start()\n    {\n        for (var sType in this.modules) {\n            if (sType == \"cpu\") continue;\n            for (var i=0; i < this.modules[sType].length; i++) {\n                var component = this.modules[sType][i];\n                if (component && component.start) {\n                    component.start();\n                }\n            }\n        }\n    }\n\n    /**\n     * stop(msStart, nCycles)\n     *\n     * Called by the CPU to notify all component stop() handlers\n     *\n     * @this {C1PComputer}\n     * @param {number} msStart\n     * @param {number} nCycles\n     */\n    stop(msStart, nCycles)\n    {\n        for (var sType in this.modules) {\n            if (sType == \"cpu\") continue;\n            for (var i=0; i < this.modules[sType].length; i++) {\n                var component = this.modules[sType][i];\n                if (component && component.stop) {\n                    component.stop(msStart, nCycles);\n                }\n            }\n        }\n    }\n\n    /**\n     * @this {C1PComputer}\n     * @param {string|null} sHTMLType is the type of the HTML control (eg, \"button\", \"list\", \"text\", \"submit\", \"textarea\")\n     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's \"data-value\" attribute (eg, \"reset\")\n     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)\n     * @param {string} [sValue] optional data value\n     * @return {boolean} true if binding was successful, false if unrecognized binding request\n     */\n    setBinding(sHTMLType, sBinding, control, sValue)\n    {\n        switch(sBinding) {\n        case \"reset\":\n            this.bindings[sBinding] = control;\n            control.onclick = function(computer) {\n                return function() {\n                    computer.reset();\n                };\n            }(this);\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * NOTE: If there are multiple components for a given type, we may need to provide a means of discriminating.\n     *\n     * @this {C1PComputer}\n     * @param {string} sType\n     * @param {string} [idRelated] of related component\n     * @param {Component|null} [componentPrev] of previously returned component, if any\n     * @return {Component|null}\n     */\n    getComponentByType(sType, idRelated, componentPrev)\n    {\n        if (this.modules[sType]) {\n            return this.modules[sType][0];\n        }\n        return null;\n    }\n\n    static power(computer)\n    {\n        /*\n         * Insure that the ROMs, Video and CPU are all ready before \"powering\" everything; always \"power\"\n         * the CPU last, to make sure it doesn't start asking other components to do things before they're ready.\n         */\n        var cpu = null;\n        for (var sType in computer.modules) {\n            for (var i=0; i < computer.modules[sType].length; i++) {\n                var component = computer.modules[sType][i];\n                if (!component) continue;\n                if (!component.isReady()) {\n                    component.isReady(function(computer) {\n                        return function() {\n                            C1PComputer.power(computer);\n                        };\n                    }(computer));   // jshint ignore:line\n                    return;\n                }\n                /*\n                 * The CPU component's setPower() notification handler is a special case: we don't want\n                 * to call it until the end (below), after all others have been called.\n                 */\n                if (sType == \"cpu\")\n                    cpu = component;\n                else if (component.setPower) {\n                    component.setPower(true, computer);\n                }\n            }\n        }\n\n        /*\n         * The entire computer is finally ready; we call our own setReady() for completeness, not because any\n         * other component actually cares when we're ready.\n         */\n        computer.setReady();\n\n        computer.println(C1PJS.APPNAME + \" v\" + C1PJS.APPVERSION + \"\\n\" + COPYRIGHT);\n\n        /*\n         * Once we get to this point, we're guaranteed that all components are ready, so it's safe to \"power\" the CPU;\n         * setPower() includes an automatic reset(fPowerOn), so the CPU should begin executing immediately, unless a debugger\n         * is attached.\n         */\n        if (cpu) cpu.setPower(true, computer);\n    }\n\n    /*\n     * C1PComputer.init()\n     *\n     * This function operates on every HTML element of class \"c1pjs-computer\", extracting the\n     * JSON-encoded parameters for the C1PComputer constructor from the element's \"data-value\"\n     * attribute, invoking the constructor to create a C1PComputer component, and then binding\n     * any associated HTML controls to the new component.\n     */\n    static init()\n    {\n        /*\n         * In non-COMPILED builds, embedMachine() may have set XMLVERSION.\n         */\n        if (!COMPILED && XMLVERSION) C1PJS.APPVERSION = XMLVERSION;\n\n        var aeComputers = Component.getElementsByClass(document, C1PJS.APPCLASS, \"computer\");\n\n        for (var iComputer=0; iComputer < aeComputers.length; iComputer++) {\n\n            var eComputer = aeComputers[iComputer];\n            var parmsComputer = Component.getComponentParms(eComputer);\n\n            var component;\n            var modules = {};\n\n            var abMemory;\n            var addrStart = 0, addrEnd = 0;\n\n            for (var iAddr=0; iAddr < parmsComputer['modules'].length; iAddr++) {\n                var addrInfo = parmsComputer['modules'][iAddr];\n                /*\n                 * The first address range (ie, the CPU range) must specify the range for the entire\n                 * address space (abMemory), which we allocate and zero-initialize.\n                 *\n                 * NOTE: We might consider doing what the Video component does on first reset: initializing\n                 * the entire memory buffer to random values.  However, a constant (eg, 0xA5) might be\n                 * more useful, acting as a crude indicator of memory the client code hasn't written yet.\n                 */\n                if (!iAddr) {\n                    if (addrInfo['type'] != \"cpu\") break;\n                    addrStart = addrInfo['start'];\n                    addrEnd = addrInfo['end'];\n                    abMemory = new Array(addrEnd+1 - addrStart);\n                    for (var addr=addrStart; addr < abMemory.length; addr++) {\n                        abMemory[addr] = 0;\n                    }\n                }\n                component = Component.getComponentByID(addrInfo['refID'], parmsComputer['id']);\n                if (component) {\n                    var sType = addrInfo['type'];\n                    if (modules[sType] === undefined)\n                        modules[sType] = [];\n                    modules[sType].push(component);\n                    if (component.setBuffer && addrInfo['start'] !== undefined) {\n                        component.setBuffer(abMemory, addrInfo['start'], addrInfo['end'], modules['cpu'][0]);\n                    }\n                }\n                else {\n                    Component.error(\"no component for <module refid=\\\"\" + addrInfo['refID'] + \"\\\">\");\n                    return;\n                }\n            }\n\n            if (abMemory === undefined) {\n                Component.error(\"<module type=\\\"cpu\\\"> definition must appear first in the <computer> specification\");\n                return;\n            }\n\n            /*\n             * Let's see if the Debugger is installed (NOTE: its ID must be \"debugger\", and only one per machine is supported);\n             * the Debugger needs our setBuffer(), setPower() and reset() notifications, and this relieves us from having an explicit\n             * <module> entry for type=\"debugger\".\n             */\n            component = Component.getComponentByID('debugger', parmsComputer['id']);\n            if (component) {\n                modules['debugger'] = [component];\n                if (component.setBuffer) {\n                    component.setBuffer(abMemory, addrStart, addrEnd, modules['cpu'][0]);\n                }\n            }\n\n            var computer = new C1PComputer(parmsComputer, modules);\n\n            /*\n             * Let's see if the Control Panel is installed (NOTE: its ID must be \"panel\", and only one per machine is supported);\n             * the Panel needs our setPower() notifications, and this relieves us from having an explicit <module> entry for type=\"panel\".\n             */\n            var panel = Component.getComponentByID('panel', parmsComputer['id']);\n            if (panel) {\n                modules['panel'] = [panel];\n                /*\n                 * Iterate through all the other components and update their print methods if the Control Panel has provided overrides.\n                 */\n                var controlPrint = panel.bindings['print'];\n                if (controlPrint) {\n                    var aComponents = Component.getComponents(parmsComputer['id']);\n                    for (var iComponent = 0; iComponent < aComponents.length; iComponent++) {\n                        component = aComponents[iComponent];\n                        if (component == panel) continue;\n                        component.notice = panel.notice;\n                        component.print = panel.print;\n                        component.println = panel.println;\n                    }\n                }\n            }\n\n            /*\n             *  We may eventually add a \"Power\" button, but for now, all we have is a \"Reset\" button\n             */\n            Component.bindComponentControls(computer, eComputer, C1PJS.APPCLASS);\n\n            /*\n             * \"Power\" the computer automatically\n             */\n            C1PComputer.power(computer);\n        }\n    }\n}\n\n/*\n * Initialize every Computer on the page.\n */\nWeb.onInit(C1PComputer.init);\n\n/**\n * @copyright http://pcjs.org/modules/shared/lib/embed.js (C) Jeff Parsons 2012-2017\n */\n\n\n/*\n * We now support asynchronous XML and XSL file loads; simply set fAsync (below) to true.\n *\n * NOTE: For that support to work, we have to keep track of the number of machines on the page\n * (ie, how many embedMachine() calls were issued), reduce the count as each machine XML file\n * is fully transformed into HTML, and when the count finally returns to zero, notify all the\n * machine component init() handlers.\n *\n * Also, to prevent those init() handlers from running prematurely, we must disable all page\n * notification events at the start of the embedding process (Web.enablePageEvents(false)) and\n * re-enable them at the end (Web.enablePageEvents(true)).\n */\nvar fAsync = true;\nvar cAsyncMachines = 0;\n\n/**\n * loadXML(sFile, idMachine, sAppName, sAppClass, sParms, fResolve, display, done)\n *\n * This is the preferred way to load all XML and XSL files. It uses getResource()\n * to load them as strings, which parseXML() can massage before parsing/transforming them.\n *\n * For example, since I've been unable to get the XSLT document() function to work inside any\n * XSL document loaded by JavaScript's XSLT processor, that has prevented me from dynamically\n * loading any XML machine file that uses the \"ref\" attribute to refer to and incorporate\n * another XML document.\n *\n * To solve that, I've added an fResolve parameter that tells parseXML() to fetch any\n * referenced documents ITSELF and insert them into the XML string prior to parsing, instead\n * of relying on the XSLT template to pull them in.  That fetching is handled by resolveXML(),\n * which iterates over the XML until all \"refs\" have been resolved (including any nested\n * references).\n *\n * Also, XSL files with a <!DOCTYPE [...]> cause MSIE's Microsoft.XMLDOM.loadXML() function\n * to choke, so I strip that out prior to parsing as well.\n *\n * TODO: Figure out why the XSLT document() function works great when the web browser loads an\n * XML file (and the associated XSL file) itself, but does not work when loading documents via\n * JavaScript XSLT support. Is it broken, is it a security issue, or am I just calling it wrong?\n *\n * @param {string} sXMLFile\n * @param {string|null|undefined} idMachine\n * @param {string|null|undefined} sAppName\n * @param {string|null|undefined} sAppClass\n * @param {string|null|undefined} sParms\n * @param {boolean} fResolve is true to resolve any \"ref\" attributes\n * @param {function(string)} display\n * @param {function(string,Object)} done (string contains the unparsed XML string data, and Object contains a parsed XML object)\n */\nfunction loadXML(sXMLFile, idMachine, sAppName, sAppClass, sParms, fResolve, display, done)\n{\n    var doneLoadXML = function(sURLName, sXML, nErrorCode) {\n        if (nErrorCode) {\n            if (!sXML) sXML = \"unable to load \" + sXMLFile + \" (\" + nErrorCode + \")\";\n            done(sXML, null);\n            return;\n        }\n        parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, fResolve, display, done);\n    };\n    display(\"Loading \" + sXMLFile + \"...\");\n    Web.getResource(sXMLFile, null, fAsync, doneLoadXML);\n}\n\n/**\n * parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, fResolve, display, done)\n *\n * Generates an XML document from an XML string. This function also provides a work-around for XSLT's\n * lack of support for the document() function (at least on some browsers), by replacing every reference\n * tag (ie, a tag with a \"ref\" attribute) with the contents of the referenced file.\n *\n * @param {string} sXML\n * @param {string|null} sXMLFile\n * @param {string|null|undefined} idMachine\n * @param {string|null|undefined} sAppName\n * @param {string|null|undefined} sAppClass\n * @param {string|null|undefined} sParms\n * @param {boolean} fResolve is true to resolve any \"ref\" attributes; default is false\n * @param {function(string)} display\n * @param {function(string,Object)} done (string contains the unparsed XML string data, and Object contains a parsed XML object)\n */\nfunction parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, fResolve, display, done)\n{\n    var buildXML = function(sXML, sError) {\n        if (sError) {\n            done(sError, null);\n            return;\n        }\n        if (idMachine) {\n\n            /*\n             * A more sensible place to record the machine XML would be embedMachine(), like we do for the\n             * XSL file, but since we're about to modify the original machine XML, it's best to record it now.\n             */\n            Component.addMachineResource(idMachine, sXMLFile, sXML);\n\n            var sURL = sXMLFile;\n            if (sURL && sURL.indexOf('/') < 0 && window.location.pathname.slice(-1) == '/') {\n                sURL = window.location.pathname + sURL;\n            }\n            /*\n             * We embed the URL of the XML file both as a separate \"xml\" attribute for easy access from the\n             * XSL file, and as part of the \"parms\" attribute for easy access from machines (see getMachineParm()).\n             */\n            if (!sParms) {\n                sParms = '{';\n            } else if (sParms.slice(-1) == '}') {\n                sParms = sParms.slice(0, -1);\n                if (sParms.length > 1) sParms += ',';\n            } else {            // sParms must just be a \"state\" file, so encode it as a \"state\" property\n                sParms = '{state:\"' + sParms + '\",';\n            }\n            sParms += 'url:\"' + sURL + '\"}';\n            /*\n             * Note that while we no longer generate a machine XML file with a \"state\" attribute (because it's\n             * encoded inside the \"parms\" attribute), the XSL file must still cope with \"state\" attributes inside\n             * other XML files; for example, manifest XML files like /apps/pc/1981/visicalc/manifest.xml contain\n             * machine elements with \"state\" attributes that must still be passed down to the computer element\n             * \"the old fashioned way\".\n             *\n             * Until/unless that changes, components.xsl cannot be simplified as much as I might have hoped.\n             */\n            if (typeof resources == 'object') sURL = null;      // turn off URL inclusion if we have embedded resources\n            sParms = sParms.replace(/\\$/g, \"$$$$\");\n            sXML = sXML.replace(/(<machine[^>]*\\sid=)(['\"]).*?\\2/, \"$1$2\" + idMachine + \"$2\" + (sParms? \" parms='\" + sParms + \"'\" : \"\") + (sURL? ' url=\"' + sURL + '\"' : ''));\n        }\n\n        if (!fResolve) {\n            /*\n             * I'm trying to switch to a shared components.xsl (at least for all PC-class machines),\n             * but in the interim, that means hacking the XSL file on the fly to reflect the actual class.\n             */\n            sXML = sXML.replace(/(<xsl:variable name=\"APPNAME\">).*?(<\\/xsl:variable>)/, \"$1\" + sAppName + \"$2\");\n            sXML = sXML.replace(/(<xsl:variable name=\"APPCLASS\">).*?(<\\/xsl:variable>)/, \"$1\" + sAppClass + \"$2\");\n\n            /*\n             * Non-COMPILED kludge to replace the version number template in the XSL file (which we assume we're reading,\n             * since fResolve is false) with whatever XMLVERSION we extracted from the XML file (see corresponding kludge below).\n             *\n             * ES6 ALERT: Template strings.\n             */\n            if (!COMPILED && XMLVERSION) {\n                sXML = sXML.replace(/<xsl:variable name=\"APPVERSION\">1.x.x<\\/xsl:variable>/, `<xsl:variable name=\"APPVERSION\">${XMLVERSION}</xsl:variable>`);\n            }\n        }\n\n        /*\n         * If the resource we requested is not really an XML file (or the file didn't exist and the server simply returned\n         * a message like \"Cannot GET /devices/pc/machine/5150/cga/64kb/donkey/machine.xml\"), we'd like to display a more\n         * meaningful message, because the XML DOM parsers will blithely return a document that contains nothing useful; eg:\n         *\n         *      This page contains the following errors:error on line 1 at column 1:\n         *      Document is empty Below is a rendering of the page up to the first error.\n         *\n         * Supposedly, the IE XML DOM parser will throw an exception, but I haven't tested that, and unless all other\n         * browsers do that, that's not helpful.\n         *\n         * The best I can do at this stage (assuming Web.getResource() didn't drop any error information on the floor)\n         * is verify that the requested resource \"looks like\" valid XML (in other words, it begins with a '<').\n         */\n        var xmlDoc = null;\n        if (sXML.charAt(0) == '<') {\n            try {\n                /*\n                 * Another hack for MSIE, which fails to load XSL documents containing a <!DOCTYPE [...]> tag.\n                 *\n                 * This is also why the XSLTProcessor 'transformToFragment' method in Microsoft Edge silently failed,\n                 * so I had pull this hack out of the \"ActiveXObject\" code.  And rather than add yet-another Microsoft\n                 * browser check, I'm going to try doing this across the board, and hope that none of the other XSLT\n                 * processors fail *without* the DOCTYPE tag.\n                 */\n                if (!fResolve) {\n                    sXML = sXML.replace(/<!DOCTYPE(.|[\\r\\n])*]>\\s*/g, \"\");\n                }\n                /*\n                 * Beginning with Microsoft Edge and the corresponding release of Windows 10, all the\n                 * 'ActiveXObject' crud has gone away; but of course, this code must remain in place if\n                 * we want to continue supporting older Internet Explorer browsers (ie, back to IE9).\n                 */\n                /** @namespace window.ActiveXObject */\n                if (window.ActiveXObject || 'ActiveXObject' in window) {        // second test is required for IE11 on Windows 8.1\n                    xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n                    xmlDoc.async = false;\n                    xmlDoc['loadXML'](sXML);\n                } else {\n                    /** @namespace window.DOMParser */\n                    xmlDoc = (new window.DOMParser()).parseFromString(sXML, \"text/xml\");\n                }\n            } catch(e) {\n                xmlDoc = null;\n                sXML = e.message;\n            }\n        } else {\n            sXML = \"unrecognized XML: \" + (sXML.length > 255? sXML.substr(0, 255) + \"...\" : sXML);\n        }\n        done(sXML, xmlDoc);\n    };\n    if (sXML) {\n        if (PRIVATE) sXML = sXML.replace(/\\/library.xml/, \"/private/library.xml\");\n        if (fResolve) {\n            resolveXML(sXML, display, buildXML);\n            return;\n        }\n        buildXML(sXML, null);\n        return;\n    }\n    done(\"no data\" + (sXMLFile? \" for file: \" + sXMLFile : \"\"), null);\n}\n\n/**\n * resolveXML(sXML, display, done)\n *\n * Replaces every tag with a \"ref\" attribute with the contents of the corresponding file.\n *\n * TODO: Fix some of the limitations of this code, such as: 1) requiring the \"ref\" attribute\n * to appear as the tag's first attribute, 2) requiring the \"ref\" attribute to be double-quoted,\n * and 3) requiring the \"ref\" tag to be self-closing.\n *\n * @param {string} sXML\n * @param {function(string)} display\n * @param {function(string,(string|null))} done (the first string contains the resolved XML data, the second is for any error message)\n */\nfunction resolveXML(sXML, display, done)\n{\n    var matchRef;\n    var reRef = /<([a-z]+)\\s+ref=\"(.*?)\"(.*?)\\/>/g;\n\n    if ((matchRef = reRef.exec(sXML))) {\n\n        var sRefFile = matchRef[2];\n\n        var doneReadXML = function(sURLName, sXMLRef, nErrorCode) {\n            if (nErrorCode || !sXMLRef) {\n                done(sXML, \"unable to resolve XML reference: \" + matchRef[0] + \" (\" + nErrorCode + \")\");\n                return;\n            }\n            /*\n             * If there are additional attributes in the \"referring\" XML tag, we want to insert them\n             * into the \"referred\" XML tag; attributes that don't exist in the referred tag should be\n             * appended, and attributes that DO exist should be overwritten.\n             */\n            var sRefAttrs = matchRef[3];\n            if (sRefAttrs) {\n                var aXMLRefTag = sXMLRef.match(new RegExp(\"<\" + matchRef[1] + \"[^>]*>\"));\n                if (aXMLRefTag) {\n                    var sXMLNewTag = aXMLRefTag[0];\n                    /*\n                     * Iterate over all the attributes in the \"referring\" XML tag (sRefAttrs)\n                     */\n                    var matchAttr;\n                    var reAttr = /( [a-z]+=)(['\"])(.*?)\\2/gi;\n                    while ((matchAttr = reAttr.exec(sRefAttrs))) {\n                        if (sXMLNewTag.toLowerCase().indexOf(matchAttr[1].toLowerCase()) < 0) {\n                            /*\n                             * This is the append case....\n                             */\n                            sXMLNewTag = sXMLNewTag.replace(\">\", matchAttr[0] + \">\");\n                        } else {\n                            /*\n                             * This is the overwrite case....\n                             */\n                            sXMLNewTag = sXMLNewTag.replace(new RegExp(matchAttr[1] + \"(['\\\"])(.*?)\\\\1\"), matchAttr[0]);\n                        }\n                    }\n                    if (aXMLRefTag[0] != sXMLNewTag) {\n                        sXMLRef = sXMLRef.replace(aXMLRefTag[0], sXMLNewTag);\n                    }\n                } else {\n                    done(sXML, \"missing <\" + matchRef[1] + \"> in \" + sRefFile);\n                    return;\n                }\n            }\n\n            /*\n             * Apparently when a Windows Azure server delivers one of my XML files, it may modify the first line:\n             *\n             *      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n\n             *\n             * I didn't determine exactly what it was doing at this point (probably just changing the \\n to \\r\\n),\n             * but in any case, relaxing the following replace() solved it.\n             */\n            sXMLRef = sXMLRef.replace(/<\\?xml[^>]*>[\\r\\n]*/, \"\");\n\n            sXML = sXML.replace(matchRef[0], sXMLRef);\n\n            resolveXML(sXML, display, done);\n        };\n\n        display(\"Loading \" + sRefFile + \"...\");\n        Web.getResource(sRefFile, null, fAsync, doneReadXML);\n        return;\n    }\n    done(sXML, null);\n}\n\n/**\n * embedMachine(sAppName, sAppClass, sVersion, idMachine, sXMLFile, sXSLFile, sParms)\n *\n * This allows to you embed a machine on a web page, by transforming the machine XML into HTML.\n *\n * @param {string} sAppName is the app name (eg, \"PCx86\")\n * @param {string} sAppClass is the app class (eg, \"pcx86\"); also known as the machine class\n * @param {string} sVersion is the app version (eg, \"1.15.7\")\n * @param {string} idMachine\n * @param {string} sXMLFile\n * @param {string} sXSLFile\n * @param {string} [sParms]\n * @return {boolean} true if successful, false if error\n */\nfunction embedMachine(sAppName, sAppClass, sVersion, idMachine, sXMLFile, sXSLFile, sParms)\n{\n    var eMachine, eWarning, fSuccess = true;\n\n    cAsyncMachines++;\n    Component.addMachine(idMachine);\n\n    var doneMachine = function() {\n\n        if (!--cAsyncMachines) {\n            if (fAsync) Web.enablePageEvents(true);\n        }\n    };\n\n    var displayError = function(sError) {\n        Component.log(sError);\n        displayMessage(\"Error: \" + sError);\n        if (fSuccess) doneMachine();\n        fSuccess = false;\n    };\n\n    var displayMessage = function(sMessage) {\n        if (eWarning === undefined) {\n            /*\n             * Our MarkOut module (in convertMDMachineLinks()) creates machine containers that look like:\n             *\n             *      <div id=\"' + sMachineID + '\" class=\"machine-placeholder\"><p>Embedded PC</p><p class=\"machine-warning\">...</p></div>\n             *\n             * with the \"machine-warning\" paragraph pre-populated with a warning message that the user will\n             * see if nothing at all happens.  But hopefully, in the normal case (and especially the error case),\n             * *something* will have happened.\n             *\n             * Note that it is the HTMLOut module (in processMachines()) that ultimately decides which scripts to\n             * include and then generates the embedXXX() call.\n             */\n            var aeWarning = (eMachine && Component.getElementsByClass(eMachine, \"machine-warning\"));\n            eWarning = (aeWarning && aeWarning[0]) || eMachine;\n        }\n        if (eWarning) eWarning.innerHTML = Str.escapeHTML(sMessage);\n    };\n\n    try {\n        eMachine = document.getElementById(idMachine);\n        if (eMachine) {\n\n            /*\n             * If we have a 'css' resource, add it to the page first.\n             */\n            var css;\n            if (typeof resources == \"object\" && (css = resources['css'])) {\n                var head = document.head || document.getElementsByTagName('head')[0];\n                var style = document.createElement('style');\n                style.type = 'text/css';\n                if (style.styleSheet) {\n                    style.styleSheet.cssText = css;\n                } else {\n                    style.appendChild(document.createTextNode(css));\n                }\n                head.appendChild(style);\n            }\n\n            if (!sXSLFile) {\n                /*\n                 * Now that PCjs is an open-source project, we can make the following test more flexible,\n                 * and revert to the internal template if DEBUG *or* internal version (instead of *and*).\n                 *\n                 * Third-party sites that don't use the PCjs server will ALWAYS want to specify a fully-qualified\n                 * path to the XSL file, unless they choose to mirror our folder structure.\n                 */\n                var sAppFolder = sAppClass;\n                if (DEBUG || sVersion == \"1.x.x\") {\n                    if (sAppClass != \"c1pjs\") sAppFolder = \"shared\";\n                    sXSLFile = \"/modules/\" + sAppFolder + \"/templates/components.xsl\";\n                } else {\n                    if (sAppClass.substr(0, 3) == \"pdp\") sAppFolder = \"pdpjs\";\n                    sXSLFile = \"/versions/\" + sAppFolder + \"/\" + sVersion + \"/components.xsl\";\n                }\n            }\n\n            var processXML = function(sXML, xml) {\n                if (!xml) {\n                    displayError(sXML);\n                    return;\n                }\n\n                /*\n                 * Non-COMPILED kludge to extract the version number from the stylesheet path in the machine XML file;\n                 * we don't need this code in COMPILED (non-DEBUG) releases, because APPVERSION is hard-coded into them.\n                 */\n                if (!COMPILED) {\n                    var aMatch = sXML.match(/<\\?xml-stylesheet[^>]* href=(['\"])[^'\"]*?\\/([0-9.]*)\\/([^'\"]*)\\1/);\n                    if (aMatch) XMLVERSION = aMatch[2];\n                }\n\n                var transformXML = function(sXSL, xsl) {\n                    if (!xsl) {\n                        displayError(sXSL);\n                        return;\n                    }\n\n                    /*\n                     * Record the XSL file, in case someone wants to save the entire machine later.\n                     */\n                    Component.addMachineResource(idMachine, sXSLFile, sXSL);\n\n                    /*\n                     * The <machine> template in components.xsl now generates a \"machine div\" that makes\n                     * the div we required the caller of embedMachine() to provide redundant, so instead\n                     * of appending this fragment to the caller's node, we REPLACE the caller's node.\n                     * This works only because because we ALSO inject the caller's \"machine div\" ID into\n                     * the fragment's ID during parseXML().\n                     *\n                     *      eMachine.innerHTML = sFragment;\n                     *\n                     * Also, if the transform function fails, make sure you're using the appropriate\n                     * \"components.xsl\" and not a \"machine.xsl\", because the latter will not produce valid\n                     * embeddable HTML (and is the most common cause of failure at this final stage).\n                     */\n                    displayMessage(\"Processing \" + sXMLFile + \"...\");\n\n                    /*\n                     * Beginning with Microsoft Edge and the corresponding release of Windows 10, all the\n                     * 'ActiveXObject' crud has gone away; but of course, this code must remain in place if\n                     * we want to continue supporting older Internet Explorer browsers (ie, back to IE9).\n                     */\n                    if (window.ActiveXObject || 'ActiveXObject' in window) {        // second test is required for IE11 on Windows 8.1\n                        var sFragment = xml['transformNode'](xsl);\n                        if (sFragment) {\n                            eMachine.outerHTML = sFragment;\n                            doneMachine();\n                        } else {\n                            displayError(\"transformNodeToObject failed\");\n                        }\n                    }\n                    else if (document.implementation && document.implementation.createDocument) {\n                        var xsltProcessor = new XSLTProcessor();\n                        xsltProcessor['importStylesheet'](xsl);\n                        var eFragment = xsltProcessor['transformToFragment'](xml, document);\n                        if (eFragment) {\n                            /*\n                             * This fails in Microsoft Edge...\n                             *\n                            var machine = eFragment.getElementById(idMachine);\n                            if (!machine) {\n                                displayError(\"machine generation failed: \" + idMachine);\n                            } else\n                            */\n                            if (eMachine.parentNode) {\n                                eMachine.parentNode.replaceChild(eFragment, eMachine);\n                                doneMachine();\n                            } else {\n                                /*\n                                 * NOTE: This error can occur if our Node web server, when processing a folder with\n                                 * both a manifest.xml with a machine.xml reference AND a README.md containing a\n                                 * machine link, generates duplicate embedXXX() calls for the same machine; if the\n                                 * first embedXXX() call finds its target, subsequent calls for the same target will\n                                 * fail.\n                                 *\n                                 * Technically, such a folder is in a misconfigured state, but it happens, in part\n                                 * because when we switched to the Jekyll web server, we had to add machine links to\n                                 * all README.md files where we had previously relied on manifest.xml or machine.xml\n                                 * processing.  This is because the Jekyll web server currently doesn't process XML\n                                 * files, nor is support for that likely to be added any time soon; it was a nice\n                                 * feature of the Node web server, but it's not clear that it's worth doing for Jekyll.\n                                 */\n                                displayError(\"invalid machine element: \" + idMachine);\n                            }\n                        } else {\n                            displayError(\"transformToFragment failed\");\n                        }\n                    } else {\n                        /*\n                         * Perhaps I should have performed this test at the outset; on the other hand, I'm\n                         * not aware of any browsers don't support one or both of the above XSLT transformation\n                         * methods, so treat this as a bug.\n                         */\n                        displayError(\"unable to transform XML: unsupported browser\");\n                    }\n                };\n                loadXML(sXSLFile, null, sAppName, sAppClass, null, false, displayMessage, transformXML);\n            };\n\n            if (sXMLFile.charAt(0) != '<') {\n                loadXML(sXMLFile, idMachine, sAppName, sAppClass, sParms, true, displayMessage, processXML);\n            } else {\n                parseXML(sXMLFile, null, idMachine, sAppName, sAppClass, sParms, false, displayMessage, processXML);\n            }\n        } else {\n            displayError(\"missing machine element: \" + idMachine);\n        }\n    } catch(e) {\n        displayError(e.message);\n    }\n    return fSuccess;\n}\n\n/**\n * embedC1P(idMachine, sXMLFile, sXSLFile)\n *\n * @param {string} idMachine\n * @param {string} sXMLFile\n * @param {string} sXSLFile\n * @return {boolean} true if successful, false if error\n */\nfunction embedC1P(idMachine, sXMLFile, sXSLFile)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"C1Pjs\", \"c1pjs\", APPVERSION, idMachine, sXMLFile, sXSLFile);\n}\n\n/**\n * embedPCx86(idMachine, sXMLFile, sXSLFile, sParms)\n *\n * @param {string} idMachine\n * @param {string} sXMLFile\n * @param {string} sXSLFile\n * @param {string} [sParms]\n * @return {boolean} true if successful, false if error\n */\nfunction embedPCx86(idMachine, sXMLFile, sXSLFile, sParms)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"PCx86\", \"pcx86\", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms);\n}\n\n/**\n * embedPC8080(idMachine, sXMLFile, sXSLFile, sParms)\n *\n * @param {string} idMachine\n * @param {string} sXMLFile\n * @param {string} sXSLFile\n * @param {string} [sParms]\n * @return {boolean} true if successful, false if error\n */\nfunction embedPC8080(idMachine, sXMLFile, sXSLFile, sParms)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"PC8080\", \"pc8080\", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms);\n}\n\n/**\n * embedPDP10(idMachine, sXMLFile, sXSLFile, sParms)\n *\n * @param {string} idMachine\n * @param {string} sXMLFile\n * @param {string} sXSLFile\n * @param {string} [sParms]\n * @return {boolean} true if successful, false if error\n */\nfunction embedPDP10(idMachine, sXMLFile, sXSLFile, sParms)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"PDPjs\", \"pdp10\", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms);\n}\n\n/**\n * embedPDP11(idMachine, sXMLFile, sXSLFile, sParms)\n *\n * @param {string} idMachine\n * @param {string} sXMLFile\n * @param {string} sXSLFile\n * @param {string} [sParms]\n * @return {boolean} true if successful, false if error\n */\nfunction embedPDP11(idMachine, sXMLFile, sXSLFile, sParms)\n{\n    if (fAsync) Web.enablePageEvents(false);\n    return embedMachine(\"PDPjs\", \"pdp11\", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms);\n}\n\n/**\n * findMachineComponent(idMachine, sType)\n *\n * @param {string} idMachine\n * @param {string} sType\n * @return {Component|null}\n */\nfunction findMachineComponent(idMachine, sType)\n{\n    return Component.getComponentByType(sType, idMachine + \".machine\");\n}\n\n/**\n * commandMachine(control, fSingle, idMachine, sComponent, sCommand, sValue)\n *\n * Use Component methods to find the requested component for a specific machine, and if the component is found,\n * then check its 'exports' table for an entry matching the specified command string, and if an entry is found, then\n * the corresponding function is called with the specified data.\n *\n * @param {Object} control\n * @param {boolean} fSingle\n * @param {string} idMachine\n * @param {string} sComponent\n * @param {string} sCommand\n * @param {string} [sValue]\n * @return {boolean}\n */\nfunction commandMachine(control, fSingle, idMachine, sComponent, sCommand, sValue)\n{\n    if (sCommand == \"script\") {\n        if (Component.processScript(idMachine, sValue)) {\n            if (fSingle) control.disabled = true;\n            return true;\n        }\n        return false;\n    }\n    if (sComponent) {\n        var component = Component.getComponentByType(sComponent, idMachine + \".machine\");\n        if (component) {\n            var exports = component['exports'];\n            if (exports) {\n                var fnCommand = exports[sCommand];\n                if (fnCommand) {\n                    if (fnCommand.call(component, sValue)) {\n                        if (fSingle) control.disabled = true;\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }\n    }\n    console.log(\"unimplemented: commandMachine('\" + idMachine + \"','\" + sComponent + \"','\" + sCommand + \"','\" + sValue + \"')\");\n    return false;\n}\n\n/**\n * Prevent the Closure Compiler from renaming functions we want to export, by adding them as global properties.\n *\n * TODO: Consider making all these functions properties on a single global object (eg, 'PCjs'), to minimize global\n * pollution and risk of name collision.\n */\nif (APPNAME == \"C1Pjs\") {\n    window['embedC1P']    = embedC1P;\n}\nif (APPNAME == \"PCx86\") {\n    window['embedPC']     = embedPCx86;         // WARNING: embedPC() deprecated as of v1.23.0\n    window['embedPCx86']  = embedPCx86;\n}\nif (APPNAME == \"PC8080\") {\n    window['embedPC8080'] = embedPC8080;\n}\nif (APPNAME == \"PDPjs\") {\n    window['embedPDP10']  = embedPDP10;\n    window['embedPDP11']  = embedPDP11;\n}\n\nwindow['commandMachine'] = commandMachine;\n\nwindow['enableEvents'] = Web.enablePageEvents;\nwindow['sendEvent']    = Web.sendPageEvent;\n"]}